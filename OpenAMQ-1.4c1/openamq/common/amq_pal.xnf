<?xml?>
<!--
    *** GENERATED FROM amq.asl BY asl_gen USING GSL/4 ***

    
    Copyright (c) 1996-2009 iMatix Corporation
    
    This file is licensed under the GPL as follows:
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or (at
    your option) any later version.
    
    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.
    
    For information on alternative licensing for OEMs, please contact
    iMatix Corporation.
 -->
<xnf
    name      = "amq_pal"
    script    = "xnf_gen.gsl"
    version   = "1.0"
    >
This is the protocol automation language grammar for the amq
protocol. The PAL grammar is generated automatically from the client-side
protocol specifications.

<inherit xnf = "xnf_base" />

<produce filename = "amq_pal_gen.gsl" type = "wrap" />
<produce filename = "amq_pal_preproc.gsl" type = "preproc" />
<produce filename = "amq_pal_inherit.gsl" type = "inherit" />
<produce filename = "amq_pal_parse.gsl" type = "parse" />
<produce filename = "amq_pal_codegen.gsl" type = "codegen" />
<produce filename = "amq_pal_doc.txt" type = "gurudoc" />

<rule phase = "wrap" when = "after">
if global.errno = 0
    [gsl].include ("amq_pal_$(global.top.target).gsl")
    generate_automation (global.top)
endif
</rule>

<entity name = "pal" template = "top">
    Defines the automation language.
    <allow entity = "doc" />
    <allow entity = "macro" />
    <allow entity = "include" />
    <inherit name = "scripting" />
    <attr name = "name" short = "script name">
    Specifies the name of the script. This name will used as the filename
    for generated code.
    </attr>
    <attr name = "comment" short = "Short description">
    An optional one-line comment that describes the script.
    </attr>
    <attr name = "target" default = "stdc" short = "Target platform">
    Specifies the name of the target environment; the target is implemented by
    a PAL back-end script in GSL that generates code for a specific language
    environment. The target can be inherited from a parent script.
    </attr>
    <attr name = "export" default = "default" >
    Specifies how this item may be inherited.
        <restrict value = "none" >may not be inherited</restrict>
        <restrict value = "default">inherited in the default manner</restrict>
        <restrict value = "before" >inherited before existing items</restrict>
        <restrict value = "after" >inherited after existing items</restrict>
    </attr>
    <rule phase = "parse">
    pal.in_session = 0
    pal.name ?= file.basename (filename)
    </rule>
</entity>

<entity name = "doc" cdata = "1" unique = "0">
    Documentation for the test script. Should be in iMatix gurudoc
    format.
</entity>

<entity name = "include">
    The 'include' element permits textual-inclusion from another file.
    <attr name = "filename" required = "1" phase = "preproc">
    The name of the XML-format file to be included in place of the
    'include' element.
    </attr>
    <rule phase = "preproc" when = "attrs">
    xml after include from filename
    </rule>
</entity>

<entity name = "macro" disconnect = "1">
    Defines a macros, a block of scripting code that can defined
    once and then used many times.
    <inherit name = "scripting" />
    <attr name = "name" required = "1" short = "name of macro" />
</entity>

<entity name = "scripting" abstact = "1">
    <allow entity = "session" inherit = "none" />
    <allow entity = "invoke"  inherit = "none" />
    <allow entity = "server"  inherit = "none" />
    <allow entity = "timer"   inherit = "none" />
    <allow entity = "set"     inherit = "none" />
    <allow entity = "inc"     inherit = "none" />
    <allow entity = "dec"     inherit = "none" />
    <allow entity = "read"    inherit = "none" />
    <allow entity = "random"  inherit = "none" />
    <allow entity = "echo"    inherit = "none" />
    <allow entity = "assert"  inherit = "none" />
    <allow entity = "repeat"  inherit = "none" />
    <allow entity = "while"   inherit = "none" />
    <allow entity = "break"   inherit = "none" />
    <allow entity = "if"      inherit = "none" />
    <allow entity = "else"    inherit = "none" />
    <allow entity = "elsif"   inherit = "none" />
    <allow entity = "wait"    inherit = "none" />
    <allow entity = "sleep"   inherit = "none" />
    <allow entity = "abort"   inherit = "none" />
    <allow entity = "exit"    inherit = "none" />
    <allow entity = "channel_flow" inherit = "none" />
    <allow entity = "channel_flow_ok" inherit = "none" />
    <allow entity = "exchange_declare" inherit = "none" />
    <allow entity = "exchange_declare_nowait" inherit = "none" />
    <allow entity = "exchange_delete" inherit = "none" />
    <allow entity = "exchange_delete_nowait" inherit = "none" />
    <allow entity = "queue_declare" inherit = "none" />
    <allow entity = "queue_declare_nowait" inherit = "none" />
    <allow entity = "queue_bind" inherit = "none" />
    <allow entity = "queue_bind_nowait" inherit = "none" />
    <allow entity = "queue_purge" inherit = "none" />
    <allow entity = "queue_purge_nowait" inherit = "none" />
    <allow entity = "queue_delete" inherit = "none" />
    <allow entity = "queue_delete_nowait" inherit = "none" />
    <allow entity = "queue_unbind" inherit = "none" />
    <allow entity = "queue_unbind_nowait" inherit = "none" />
    <allow entity = "basic_qos" inherit = "none" />
    <allow entity = "basic_consume" inherit = "none" />
    <allow entity = "basic_consume_nowait" inherit = "none" />
    <allow entity = "basic_cancel" inherit = "none" />
    <allow entity = "basic_cancel_nowait" inherit = "none" />
    <allow entity = "basic_publish" inherit = "none" />
    <allow entity = "basic_get" inherit = "none" />
    <allow entity = "basic_ack" inherit = "none" />
    <allow entity = "basic_reject" inherit = "none" />
    <allow entity = "restms_pipe_create" inherit = "none" />
    <allow entity = "restms_pipe_delete" inherit = "none" />
    <allow entity = "restms_feed_create" inherit = "none" />
    <allow entity = "restms_feed_delete" inherit = "none" />
    <allow entity = "restms_join_create" inherit = "none" />
    <allow entity = "restms_join_delete" inherit = "none" />
    <allow entity = "basic_content" inherit = "none" />
    <allow entity = "basic_arrived" inherit = "none" />
    <allow entity = "basic_returned" inherit = "none" />
    <allow entity = "empty"   inherit = "none" />
</entity>

<entity name = "session">
    Defines a new session within the main connection.
    <inherit name = "scripting" />
    <attr name = "virtual_host" default = "/" />
    <attr name = "server" short = "Name of server">
    If specified, forces the session to connect to this server
    address.  Otherwise the address is supplied by default or
    specified by the user. 
    </attr>
    <attr name = "timeout" short = "Timeout" default = "30000">
    Specifies the connection timeout for synchronous commands, in 
    milliseconds.  If the server does not respond within this timeout
    the script will end with a failure.  Defaults to 30 seconds.
    </attr>
    <attr name = "failover" short = "Failover">
    If an integer greater than zero, on a broken connection the script
    will pause for the specified number of seconds, and then try to
    reconnect to the same or alternate server.  To use alternate
    servers, specify multiple server names in the 'server' attribute,
    seperated by spaces.
    </attr>
    <attr name = "direct" short = "Use Direct Mode" default = "0">
    If not zero, the script will use Direct Mode to publish and receive
    messages.  This is a fast out-of-band protocol documented on 
    http://wiki.amqp.org.
    </attr>
    <rule phase = "parse" when = "before">
    if pal.in_session
        abort "E: session not allowed inside another session"
    endif
    pal.in_session = 1
    </rule>
    <rule phase = "parse" when = "after">
    pal.in_session = 0
    </rule>
    <rule phase = "codegen" when = "before">
    pal.session_index = (pal.session_index?0) + 1
    produce_session_header ()
    </rule>
    <rule phase = "codegen" when = "after">
    produce_session_footer ()
    </rule>
</entity>

<entity name = "invoke">
    Invokes a macro.  The macro is inserted after the contents of the
    invoke block, if any.
    <inherit name = "scripting" />
    <attr name = "macro" required = "1" short = "macro name to invoke" />
    <rule phase = "parse">
    for pal.macro where name = .macro
        for . as child
            copy child to invoke
        endfor
    endfor
    </rule>
</entity>

<entity name = "server">
    Starts or restarts a protocol server.  If the server was already running
    (from the test script), stops and then restarts it.  The server is always
    killed when the script ends.  The script can optionally redirect the
    server's stderr and stdout output.
    <inherit name = "scripting" />
    <attr name = "name"   required = "1" short = "name of server executable" />
    <attr name = "port"                  short = "specific port to run on" />
    <attr name = "stdout" default = ""   short = "redirect standard output" />
    <attr name = "stderr" default = ""   short = "redirect standard error" />
    <attr name = "where"  default = "."  short = "where to run server" />
    <rule phase = "codegen">
    produce_server ()
    </rule>
</entity>

<entity name = "timer">
    Restarts the script timer.
    <attr name = "action" default = "reset" short = "timer action">
        <restrict value = "reset">reset timer</restrict>
        <restrict value = "show">show timer</restrict>
    </attr>
    <rule phase = "codegen">
    produce_timer ()
    </rule>
</entity>

<entity name = "set">
    Define a variable.  Variables can be strings or integers.  You
    can use variables in repeat, while, and if blocks, and as symbols
    for templating arguments and strings.  Untyped variables are typed
    according to their value.
    <attr name = "name"  required = "1" short = "name of variable" />
    <attr name = "value" default = "" short = "new value of variable" />
    <attr name = "type" short = "variable type">
        <restrict value = "string">string variable</restrict>
        <restrict value = "integer">integer variable</restrict>
    </attr>
    <attr name = "cmdline" short = "command line switch" />
    <rule phase = "parse">
    set.value ?= ""
    if !defined (set.type)
        if regexp.match ("^[0-9]+$", set.value)
            set.type = "integer"
        else
            set.type = "string"
        endif
    endif

    assume_variable (name, type, value)
    if defined (.cmdline)
        new pal.option
            option.name   = name
            option.type   = type
            option.value  = value
            option.switch = cmdline
        endnew
    endif
    </rule>
    <rule phase = "codegen">
    produce_set ()
    </rule>
</entity>

<rule phase = "wrap" when = "before">
function assume_variable (name, type, value)
    if count (pal.variable, variable.name = my.name) = 0
        new pal.variable
            variable.name  = my.name
            variable.type  = my.type
            variable.value = my.value
        endnew
    else
        for pal.variable where name = my.name
            if variable.type <> my.type
                abort "E: '$(my.name)' was previously defined as '$(variable.type)'"
            endif
        endfor
    endif
endfunction
</rule>

<entity name = "inc">
    Increments an integer variable.
    <attr name = "name" required = "1" short = "name of variable" />
    <rule phase = "parse">
    assume_variable (name, "integer", 0)
    </rule>
    <rule phase = "codegen">
    produce_inc ()
    </rule>
</entity>

<entity name = "dec">
    Decrements an integer variable.  Decrementing a variable below zero
    is illegal and raises a fatal error.
    <attr name = "name" required = "1" short = "name of variable" />
    <rule phase = "parse">
    assume_variable (name, "integer", 0)
    </rule>
    <rule phase = "codegen">
    produce_dec ()
    </rule>
</entity>

<entity name = "read">
    Read a line of input from the console and assign it to a string
    variable.
    <attr name = "name" required = "1" short = "name of variable" />
    <attr name = "prompt" short = "prompt to user" />
    <rule phase = "parse">
    read.value ?= ""
    read.type = "string"
    assume_variable (name, type, value)
    </rule>
    <rule phase = "codegen">
    produce_read ()
    </rule>
</entity>

<entity name = "random">
    Define an integer variable, set to a random value within the
    specified interval.
    <attr name = "name"  required = "1" short = "name of variable" />
    <attr name = "min"   default = "0"  short = "minimum value" />
    <attr name = "max"   required = "1" short = "maximum value" />
    <rule phase = "parse">
    random.value ?= ""
    random.type = "integer"
    assume_variable (name, type, value)
    </rule>
    <rule phase = "codegen">
    produce_random ()
    </rule>
</entity>

<entity name = "echo" cdata = "1">
    Echoes a line of text, which can include connection or session
    properties as symbols specified by $name, e.g. $version_major.
    <attr name = "trace" default = "0" short = "trace level">
    If 0, the echo is printed all the time.  If 1 to 3, is printed
    only at the corresponding trace level.
    </attr>
    <rule phase = "codegen">
    produce_echo ()
    </rule>
</entity>

<entity name = "assert" key = "" cdata = "1">
    Define an assertion that tests a condition and aborts the script if
    the condition is false.  If the assert tag contains a message, will
    first print the message.
    <inherit name = "condition" />
    <rule phase = "codegen">
    produce_assert ()
    </rule>
</entity>

<entity name = "condition" abstract = "1">
    The conditional variable can be
    any connection or session property, or a variable.  The value
    can be a literal string or number, with templating of properties
    and variables done using the $name syntax.  The default test if
    a test and value is not specified is "not empty" for strings
    and "not zero" for numbers.  If a value is specified, the default
    test is "eq".
    <attr name = "name" required = "1" short = "conditional variable" />
    <attr name = "test" short = "type of test">
        <restrict value = "eq">test equals, as strings</restrict>
        <restrict value = "ne">test not equals, as stringsd</restrict>
        <restrict value = "gt">test greater than, numeric</restrict>
        <restrict value = "lt">test less than, numeric</restrict>
        <restrict value = "ge">test greater, numeric</restrict>
        <restrict value = "le">test less or equal to, numeric</restrict>
    </attr>
    <attr name = "value" short = "value to test against" />
</entity>

<entity name = "repeat">
    Defines an iterative loop, which can run forever or for a specified
    number of times.  The counter is global to the session (do not use
    the same counter for two nested loops).  To access the counter within
    the repeat loop, use the $name syntax.
    <attr name = "counter"  short = "name of counter" />
    <attr name = "times"    short = "number of iterations" />
    <attr name = "progress" short = "show progress indicator" />
    <inherit name = "scripting" />
    <rule phase = "parse" when = "before">
    pal.nesting = (pal.nesting?0) + 1
    if defined ([0].counter)
        repeat.show_counter = 1
    else
        pal.counters = (pal.counters?0) + 1
        repeat.counter = "repeat_counter_$(pal.counters)"
        repeat.show_counter = 0
    endif
    counter = "$(counter:c)"
    assume_variable (counter, "integer", 0)
    </rule>
    <rule phase = "parse" when = "after">
    pal.nesting = pal.nesting - 1
    </rule>
    <rule phase = "codegen" when = "before">
    produce_repeat_header ()
    </rule>
    <rule phase = "codegen" when = "after">
    produce_repeat_footer ()
    </rule>
</entity>

<entity name = "while" key = "">
    Defines a conditional loop, which runs so long as a specified
    condition is true. The conditional variable can be any connection
    or session property, or a variable.  The value can be a literal
    string or number, with templating of properties and variables
    done using the $name syntax.  The default test if a test and value
    is not specified is "not empty" for strings and "not zero" for
    numbers.  If a value is specified, the default test is "eq".
    The counter is global to the session (do not use the same counter
    for two nested loops). To access the counter within the while loop,
    use the $name syntax.    
    <attr name = "counter" short = "name of counter" />
    <attr name = "progress" short = "show progress indicator" />
    <inherit name = "condition" />
    <inherit name = "scripting" />
    <rule phase = "parse" when = "before">
    pal.nesting = (pal.nesting?0) + 1
    if defined ([0].counter)
        counter = "$(counter:c)"
        assume_variable (counter, "integer", 0)
    endif
    </rule>
    <rule phase = "parse" when = "after">
    pal.nesting = pal.nesting - 1
    </rule>
    <rule phase = "codegen" when = "before">
    produce_while_header ()
    </rule>
    <rule phase = "codegen" when = "after">
    produce_while_footer ()
    </rule>
</entity>

<entity name = "if" key = "">
    Defines a conditional block.
    <inherit name = "condition" />
    <inherit name = "scripting" />
    <rule phase = "codegen" when = "before">
    produce_if_header ()
    </rule>
    <rule phase = "codegen" when = "after">
    produce_if_footer ()
    </rule>
</entity>

<entity name = "else">
    Defines an else block, used after an if block.
    <inherit name = "scripting" />
    <rule phase = "codegen" when = "before">
    produce_else_header ()
    </rule>
    <rule phase = "codegen" when = "after">
    produce_else_footer ()
    </rule>
</entity>

<entity name = "elsif" key = "">
    Defines a conditional else block, used after an if block.
    <inherit name = "condition" />
    <inherit name = "scripting" />
    <rule phase = "codegen" when = "before">
    produce_elsif_header ()
    </rule>
    <rule phase = "codegen" when = "after">
    produce_elsif_footer ()
    </rule>
</entity>

<entity name = "wait">
    Pauses the script for up to timeout milliseconds, or until content is 
    received from the server, whichever is sooner.
    <attr name = "timeout" default = "0" short = "timeout in milliseconds" />
    <rule phase = "codegen">
    produce_wait ()
    </rule>
</entity>

<entity name = "sleep">
    Pauses the script for timeout milliseconds.  Unlike the &lt;wait&gt;
    command, the sleep time is not affected by any traffic on the session.
    <attr name = "timeout" required = "1" short = "timeout in milliseconds" />
    <rule phase = "codegen">
    produce_sleep ()
    </rule>
</entity>

<entity name = "break">
    Exits the parent repeat or while loop.
    <rule phase = "parse">
    if (pal.nesting?0) = 0
        abort "E: break not valid outside a repeated block"
    endif
    </rule>
    <rule phase = "codegen">
    produce_break ()
    </rule>
</entity>

<entity name = "abort" cdata = "1">
    Echoes a line of text and halts the script.
    <rule phase = "codegen">
    produce_abort ()
    </rule>
</entity>

<entity name = "exit" cdata = "1">
    Halts the script, optionally with a return status.
    <attr name = "status" default = "0" short = "exit status" />
    <rule phase = "codegen">
    produce_exit ()
    </rule>
</entity>


<entity name = "channel_flow">
    <attr name = "active" short = "start/stop content frames" />
    <rule phase = "parse">
    if !in_session
        abort "E: channel_flow only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_channel_flow ()
    </rule>
</entity>

<entity name = "channel_flow_ok">
    <attr name = "active" short = "current flow setting" />
    <rule phase = "parse">
    if !in_session
        abort "E: channel_flow_ok only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_channel_flow_ok ()
    </rule>
</entity>

<entity name = "exchange_declare">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "type" short = "exchange type" />
    <attr name = "passive" short = "do not create exchange" />
    <attr name = "durable" short = "request a durable exchange" />
    <attr name = "auto_delete" short = "auto-delete when unused" />
    <attr name = "internal" short = "create internal exchange" />
    <allow entity = "exchange_declare_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: exchange_declare only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_exchange_declare ()
    </rule>
</entity>

<entity name = "exchange_declare_nowait">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "type" short = "exchange type" />
    <attr name = "passive" short = "do not create exchange" />
    <attr name = "durable" short = "request a durable exchange" />
    <attr name = "auto_delete" short = "auto-delete when unused" />
    <attr name = "internal" short = "create internal exchange" />
    <allow entity = "exchange_declare_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: exchange_declare only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_exchange_declare_nowait ()
    </rule>
</entity>

<entity name = "exchange_declare_arguments" tag = "arguments">
    Defines a arguments field table.
    <allow entity = "table field" />
</entity>

<entity name = "table field" tag = "field">
    <attr name = "name" required = "1" short = "name of field" />
    <attr name = "value" short = "field value" />
    <attr name = "type" default = "string" short = "field type">
        <restrict value = "string">string field</restrict>
        <restrict value = "integer">integer field</restrict>
        <restrict value = "void">void field</restrict>
    </attr>
</entity>

<entity name = "exchange_delete">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "if_unused" short = "delete only if unused" />
    <rule phase = "parse">
    if !in_session
        abort "E: exchange_delete only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_exchange_delete ()
    </rule>
</entity>

<entity name = "exchange_delete_nowait">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "if_unused" short = "delete only if unused" />
    <rule phase = "parse">
    if !in_session
        abort "E: exchange_delete only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_exchange_delete_nowait ()
    </rule>
</entity>

<entity name = "queue_declare">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "passive" short = "do not create queue" />
    <attr name = "durable" short = "request a durable queue" />
    <attr name = "exclusive" short = "request an exclusive queue" />
    <attr name = "auto_delete" short = "auto-delete queue when unused" />
    <allow entity = "queue_declare_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_declare only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_declare ()
    </rule>
</entity>

<entity name = "queue_declare_nowait">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "passive" short = "do not create queue" />
    <attr name = "durable" short = "request a durable queue" />
    <attr name = "exclusive" short = "request an exclusive queue" />
    <attr name = "auto_delete" short = "auto-delete queue when unused" />
    <allow entity = "queue_declare_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_declare only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_declare_nowait ()
    </rule>
</entity>

<entity name = "queue_declare_arguments" tag = "arguments">
    Defines a arguments field table.
    <allow entity = "table field" />
</entity>

<entity name = "queue_bind">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "routing_key" short = "message routing key" />
    <allow entity = "queue_bind_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_bind only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_bind ()
    </rule>
</entity>

<entity name = "queue_bind_nowait">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "routing_key" short = "message routing key" />
    <allow entity = "queue_bind_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_bind only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_bind_nowait ()
    </rule>
</entity>

<entity name = "queue_bind_arguments" tag = "arguments">
    Defines a arguments field table.
    <allow entity = "table field" />
</entity>

<entity name = "queue_purge">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_purge only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_purge ()
    </rule>
</entity>

<entity name = "queue_purge_nowait">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_purge only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_purge_nowait ()
    </rule>
</entity>

<entity name = "queue_delete">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "if_unused" short = "delete only if unused" />
    <attr name = "if_empty" short = "delete only if empty" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_delete only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_delete ()
    </rule>
</entity>

<entity name = "queue_delete_nowait">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "if_unused" short = "delete only if unused" />
    <attr name = "if_empty" short = "delete only if empty" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_delete only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_delete_nowait ()
    </rule>
</entity>

<entity name = "queue_unbind">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "routing_key" short = "message routing key" />
    <allow entity = "queue_unbind_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_unbind only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_unbind ()
    </rule>
</entity>

<entity name = "queue_unbind_nowait">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "routing_key" short = "message routing key" />
    <allow entity = "queue_unbind_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: queue_unbind only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_queue_unbind_nowait ()
    </rule>
</entity>

<entity name = "queue_unbind_arguments" tag = "arguments">
    Defines a arguments field table.
    <allow entity = "table field" />
</entity>

<entity name = "basic_qos">
    <attr name = "prefetch_size" short = "prefetch window in octets" />
    <attr name = "prefetch_count" short = "prefetch window in messages" />
    <attr name = "global" short = "apply to entire connection" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_qos only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_qos ()
    </rule>
</entity>

<entity name = "basic_consume">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "consumer_tag" short = "consumer tag" />
    <attr name = "no_local" short = "do not deliver own messages" />
    <attr name = "no_ack" short = "no acknowledgement needed" />
    <attr name = "exclusive" short = "request exclusive access" />
    <allow entity = "basic_consume_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_consume only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_consume ()
    </rule>
</entity>

<entity name = "basic_consume_nowait">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "consumer_tag" short = "consumer tag" />
    <attr name = "no_local" short = "do not deliver own messages" />
    <attr name = "no_ack" short = "no acknowledgement needed" />
    <attr name = "exclusive" short = "request exclusive access" />
    <allow entity = "basic_consume_arguments" occurs = "0/1" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_consume only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_consume_nowait ()
    </rule>
</entity>

<entity name = "basic_consume_arguments" tag = "arguments">
    Defines a arguments field table.
    <allow entity = "table field" />
</entity>

<entity name = "basic_cancel">
    <attr name = "consumer_tag" short = "consumer tag" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_cancel only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_cancel ()
    </rule>
</entity>

<entity name = "basic_cancel_nowait">
    <attr name = "consumer_tag" short = "consumer tag" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_cancel only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_cancel_nowait ()
    </rule>
</entity>

<entity name = "basic_publish">
    <attr name = "content" short = "content buffer to transfer" />
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "exchange" short = "exchange name" />
    <attr name = "routing_key" short = "Message routing key" />
    <attr name = "mandatory" short = "indicate mandatory routing" />
    <attr name = "immediate" short = "request immediate delivery" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_publish only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_publish ()
    </rule>
</entity>

<entity name = "basic_get">
    <attr name = "ticket" short = "access ticket granted by server" />
    <attr name = "queue" short = "queue name" />
    <attr name = "no_ack" short = "no acknowledgement needed" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_get only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_get ()
    </rule>
</entity>

<entity name = "basic_ack">
    <attr name = "delivery_tag" short = "server-assigned delivery tag" />
    <attr name = "multiple" short = "acknowledge multiple messages" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_ack only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_ack ()
    </rule>
</entity>

<entity name = "basic_reject">
    <attr name = "delivery_tag" short = "server-assigned delivery tag" />
    <attr name = "requeue" short = "requeue the message" />
    <rule phase = "parse">
    if !in_session
        abort "E: basic_reject only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_reject ()
    </rule>
</entity>

<entity name = "restms_pipe_create">
    <attr name = "pipe_type" short = "pipe type" />
    <attr name = "pipe_name" short = "Name of pipe" />
    <rule phase = "parse">
    if !in_session
        abort "E: restms_pipe_create only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_restms_pipe_create ()
    </rule>
</entity>

<entity name = "restms_pipe_delete">
    <attr name = "pipe_name" short = "pipe name" />
    <rule phase = "parse">
    if !in_session
        abort "E: restms_pipe_delete only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_restms_pipe_delete ()
    </rule>
</entity>

<entity name = "restms_feed_create">
    <attr name = "feed_type" short = "Feed type" />
    <attr name = "feed_name" short = "Name of feed" />
    <rule phase = "parse">
    if !in_session
        abort "E: restms_feed_create only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_restms_feed_create ()
    </rule>
</entity>

<entity name = "restms_feed_delete">
    <attr name = "feed_name" short = "feed name" />
    <rule phase = "parse">
    if !in_session
        abort "E: restms_feed_delete only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_restms_feed_delete ()
    </rule>
</entity>

<entity name = "restms_join_create">
    <attr name = "pipe_name" short = "Name of pipe" />
    <attr name = "feed_name" short = "Name of feed" />
    <attr name = "address" short = "Join address" />
    <rule phase = "parse">
    if !in_session
        abort "E: restms_join_create only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_restms_join_create ()
    </rule>
</entity>

<entity name = "restms_join_delete">
    <attr name = "pipe_name" short = "Name of pipe" />
    <attr name = "feed_name" short = "Name of feed" />
    <attr name = "address" short = "Join address" />
    <rule phase = "parse">
    if !in_session
        abort "E: restms_join_delete only valid in a session"
    endif
    </rule>
    <rule phase = "codegen">
    produce_restms_join_delete ()
    </rule>
</entity>

<entity name = "basic_content" cdata = "1">
    Creates a content buffer for use by the script.  Content buffers
    are automatically destroyed when the script ends. The body of the
    content provides the body unless the random fill is used.
    <attr name = "name" short = "name of content buffer">
    Specifies the name of the content buffer.
    </attr>
    <attr name = "size" short = "size of content buffer">
    Specifies the size in octets of the content buffer.  If not specified
    takes the size of the content where supplied, otherwise defaults to
    1024 bytes.
    </attr>
    <attr name = "fill" default = "random" short = "fill mode">
    Specifies the fill mode.  If the basic_content entity has a
    non-blank body, that is used for the content body and the fill mode
    is ignored unless it is "repeat".
        <restrict value = "random">random values</restrict>
        <restrict value = "null">binary zeroes</restrict>
        <restrict value = "repeat">repeat the entity body</restrict>
    </attr>
    <attr name = "exec" short = "command to read content from">
    Specifies the name of a command to run, and get content from.  The
    command's standard output is used as the content body.  The size
    attribute is ignored, and the content body is always the size of
    the command's stdout.  The current content body, if any, is sent
    to the command's stdin.
    </attr>
    <attr name = "headers" default = "1" short = "parse headers?">
    Used only in combination with exec.  If zero, the output of the
    executed program is not reparsed. If one, the output is reparsed
    to collect message properties and headers as follows: each line
    specifies a header field name, followed by ":", followed by a
    space and a value.  Field names starting with "x-table-" are
    stored as-is (minus the x-table- prefix) in a field table with
    that name.  Other fields must match known content properties.
    Hyphens are allowed in field names.  The headers are ended with
    a blank line. Parsed headers create a CGI-like interface for
    calling programs.
    </attr>
    <attr name = "read" short = "file to read content from">
    Specifies the name of a file to read the content body from.  The
    size attribute is ignored, and the content body is always the size
    of the file. Do not define 'read' if 'exec' is defined.  Note: the
    name of the file can be specified using variables, allowing a PAL
    script to "serve up" arbitrary files.
    </attr>
    <attr name = "content_type" short = "MIME content type" />
    <attr name = "content_encoding" short = "MIME content encoding" />
    <allow entity = "basic_content_headers" occurs = "0/1" />
    <attr name = "delivery_mode" short = "Non-persistent (1) or persistent (2)" />
    <attr name = "priority" short = "The message priority, 0 to 9" />
    <attr name = "correlation_id" short = "The application correlation identifier" />
    <attr name = "reply_to" short = "The destination to reply to" />
    <attr name = "expiration" short = "Message expiration specification" />
    <attr name = "message_id" short = "The application message identifier" />
    <attr name = "timestamp" short = "The message timestamp" />
    <attr name = "type" short = "The message type name" />
    <attr name = "user_id" short = "The creating user id" />
    <attr name = "app_id" short = "The creating application id" />
    <attr name = "sender_id" short = "Identifier of connection sending the message" />
    <rule phase = "parse">
    if defined (content.)
        size = string.length (content.)
    endif
    </rule>
    <rule phase = "codegen">
    produce_basic_content ()
    </rule>
</entity>

<entity name = "basic_content_headers" tag = "headers">
    Defines a headers field table.
    <allow entity = "table field" />
</entity>

<entity name = "basic_arrived">
    Repeat script block for each arrived content.
    <attr name = "counter" short = "name of counter" />
    <inherit name = "scripting" />
    <rule phase = "parse" when = "before">
    pal.nesting = (pal.nesting?0) + 1
    if defined ([0].counter)
        counter = "$(counter:c)"
        assume_variable (counter, "integer", 0)
    endif
    </rule>
    <rule phase = "parse" when = "after">
    pal.nesting = pal.nesting - 1
    </rule>
    <rule phase = "codegen" when = "before">
    produce_basic_arrived_header ("arrived")
    </rule>
    <rule phase = "codegen" when = "after">
    produce_basic_arrived_footer ("arrived")
    </rule>
</entity>

<entity name = "basic_returned">
    Repeat script block for each returned content.
    <attr name = "counter" short = "name of counter" />
    <inherit name = "scripting" />
    <rule phase = "parse" when = "before">
    pal.nesting = (pal.nesting?0) + 1
    if defined ([0].counter)
        counter = "$(counter:c)"
        assume_variable (counter, "integer", 0)
    endif
    </rule>
    <rule phase = "parse" when = "after">
    pal.nesting = pal.nesting - 1
    </rule>
    <rule phase = "codegen" when = "before">
    produce_basic_arrived_header ("returned")
    </rule>
    <rule phase = "codegen" when = "after">
    produce_basic_arrived_footer ("returned")
    </rule>
</entity>

<entity name = "empty">
    Conditional block executed if previous arrived or returned block
    did not process any content.
    <inherit name = "scripting" />
    <rule phase = "codegen" when = "before">
    produce_empty_header ()
    </rule>
    <rule phase = "codegen" when = "after">
    produce_empty_footer ()
    </rule>
</entity>

</xnf>
