#
#   makefile.gsl - generate project makefiles
#
#   Copyright (c) 1996-2009 iMatix Corporation
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   For information on alternative licensing for OEMs, please contact
#   iMatix Corporation.
#

#   Invoked by the 'execute' action at configure time.  Generates
#   a set of makefiles and configuration scripts at the product
#   level as follows:
#
#       configure          - configure product (Unix)
#       configure.bat      - configure product (Win32)
#       Makefile.unix      - make product (Unix)
#       Makefile.win32     - make product (Win32)
#
#   And at the project level as follows:
#
#       configure          - configure project (Unix)
#       configure.bat      - configure project (Win32)
#       Makefile.unix      - make project (Unix)
#       Makefile.win32     - make project (Win32)
#
#
#   Currently makefiles are built only for sources in the main
#   directory.
#

function generate_project_makefiles
    #   Calculate list of libraries to build
    if count (pdl.library) = 0
        for pdl.file
            for build where count (replace, (count.[as]?"c") = "c", count)
                if count (pdl.library, count.name = library, count) = 0
                    new library to pdl
                        library.name = library
                        library.list = ""
                    endnew
                endif
                for pdl.library where name = library
                    library.list += "$(basename)\$(OBJ) "
                endfor
            endfor
        endfor
    endif

    if target.name = "unix"
        unix_configure ()
        generate_project_makefile ("Makefile.unix", 1)
    elsif target.name = "win32"
        win32_configure ()
        generate_project_makefile ("Makefile.win32", 1)
    endif
endfunction

function generate_product_makefiles
    if target.name = "unix"
        unix_configure ()
        generate_product_makefile ("Makefile.unix")
    elsif target.name = "win32"
        win32_configure ()
        generate_product_makefile ("Makefile.win32")
    endif
endfunction


##############################################################################
#
#   Unix configure

.macro unix_configure ()
.   assert_dependency ("configure", "generated")
.   stream_output ("configure")
#!/bin/sh
#   $(pdl.name) configuration script
#
#   Generated by iMatix Boom
#
#   This script is provided to assist users new to Boom.  It displays the
#   configuration settings in effect.
.   bsd_license ("#")
#
#   Utility functions for parsing BOOM_MODEL
#

#   Returns a list of all BOOM_MODEL_$MODEL variables set
boom_model_list () {
    set |
        awk 'BEGIN                      { FS="[=_]" }
             /^BOOM_MODEL_[A-Z0-9]*=1$/ { print $3  }'
}

#   Expands $BOOM_MODEL into individual BOOM_MODEL_$MODEL variables
boom_model_expand () {
    #   Clear any existing settings
    for MODEL in `boom_model_list`; do
        eval unset BOOM_MODEL_$MODEL
    done
    #   Iterate over BOOM_MODEL using ',' as FS
    OLD_IFS=$IFS
    IFS=,
    for MODEL in $BOOM_MODEL; do
        MODEL=`echo $MODEL | tr \\[a-z\\] \\[A-Z\\]`
        eval BOOM_MODEL_$MODEL=1
        eval export BOOM_MODEL_$MODEL
    done
    IFS=$OLD_IFS
}

#
#   Set default values for BOOM_MODEL
#
#   Default is release,st on all platforms except Linux and Solaris.
#
if [ -s /usr/bin/uname ]; then BOOM_PLATFORM=`/usr/bin/uname`; fi
if [ -s /bin/uname ];     then BOOM_PLATFORM=`/bin/uname`;     fi
if [ -z "$BOOM_MODEL" ]; then
    if [ "$BOOM_PLATFORM" = "Linux" -o "$BOOM_PLATFORM" = "SunOS" ]; then
        BOOM_MODEL=release,mt
    else
        BOOM_MODEL=release,st
    fi
fi
boom_model_expand
if [ "$BOOM_MODEL_RELEASE" != "1" ]; then
    if [ "$BOOM_MODEL_DEBUG" != "1" ]; then
        BOOM_MODEL_RELEASE=1
        BOOM_MODEL="$BOOM_MODEL,release"
    fi
fi
if [ "$BOOM_MODEL_ST" != "1" ]; then
    if [ "$BOOM_MODEL_MT" != "1" ]; then
        if [ "$BOOM_PLATFORM" = "Linux" -o "$BOOM_PLATFORM" = "SunOS" ]; then
            BOOM_MODEL_MT=1
            BOOM_MODEL="$BOOM_MODEL,mt"
        else
            BOOM_MODEL_ST=1
            BOOM_MODEL="$BOOM_MODEL,st"
        fi
    fi
fi

#   Check that IBASE has been configured
if [ -z "$IBASE" ]; then
    echo "boom E: The IBASE variable is not set.  Please set it to the"
    echo "boom E: location where $(pdl.name) should be installed."
    exit 1
fi

echo "boom I: $(pdl.name) configured for model    : $BOOM_MODEL"
echo "boom I: $(pdl.name) will be installed into  : $IBASE"
echo "boom I: Run './boomake build' to build $(pdl.name)"
exit 0
.   stream_pop ()
.endmacro


##############################################################################
#
#   Windows configure

.macro win32_configure ()
.   assert_dependency ("configure.bat", "generated")
.   stream_output ("configure.bat")
@echo off
:-  $(pdl.name) configuration script
:-
:-  Generated on by iMatix Boom
:-
:-  This script is provided to assist users new to Boom.  It displays the
:-  configuration settings in effect.
.   bsd_license (":-")
:-
:-  Start CMD.EXE version detection
verify other 2>nul
setlocal enableextensions
if errorlevel 0 goto __cmd_ok
echo %0: This command requires command extensions version 2 in CMD.EXE.
echo %0: Please use a supported system (Windows 2000 or newer).
exit
:__cmd_ok
setlocal enabledelayedexpansion
:-  End CMD.EXE version detection

goto :init

:-
:-  Subroutine: boom_model_init
:-  Initialises BOOM_MODEL to default if not set
:-  Expands BOOM_MODEL components into individual environment variables
:-
:boom_model_init
if "!BOOM_MODEL!"=="" (
    set BOOM_MODEL=release,st
)
set BOOM_MODEL__PLACEHOLDER=1
for /f "usebackq delims==" %%v in (`set BOOM_MODEL_`) do set %%v=
set BOOM_MODEL__PLACEHOLDER=
for %%m in (!BOOM_MODEL!) do set BOOM_MODEL_%%m=1
:-  If the user set BOOM_MODEL but did not include release/debug or st/mt
:-  set these to defaults.
if not "!BOOM_MODEL_RELEASE!"=="1" (
    if not "!BOOM_MODEL_DEBUG!"=="1" (
        set BOOM_MODEL_RELEASE=1
        set BOOM_MODEL=!BOOM_MODEL!,release
    )
)
if not "!BOOM_MODEL_ST!"=="1" (
    if not "!BOOM_MODEL_MT!"=="1" (
        set BOOM_MODEL_ST=1
        set BOOM_MODEL=!BOOM_MODEL!,st
    )
)
goto :eof

:init
setlocal
call :boom_model_init
if .!IBASE!==. (
        echo boom E: The IBASE variable is not set.  Please set it to the
        echo boom E: location where $(pdl.name) should be installed.
    exit /b 1
)

echo boom I: $(pdl.name) configured for model    : !BOOM_MODEL!
echo boom I: $(pdl.name) will be installed into  : !IBASE!
echo boom I: Run 'boomake build' to build $(pdl.name)
exit /b 0
.   stream_pop ()
.endmacro


##############################################################################
#
#   Return dependencies for specified C source file

function dependencies (filename)
    if !defined (pdl.dep_$(my.filename)) & file.exists (my.filename)
        pdl.dep_$(my.filename) = ""
        my.deps = ""
        my.input = file.open (my.filename)?
        if !defined (my.input)
            abort "E: can't open $(my.filename)"
        endif
        my.line = file.read (my.input)?""
        while defined (my.line)
            if regexp.match ('#\\s*include\\s+"([^"]+)"',my.line,my.header)
                if file.exists (my.header) & !defined (pdl.dep_$(my.header))
                    my.deps += " " + my.header + dependencies (my.header)
                endif
            endif
            my.line = file.read (my.input)?
        endwhile
        file.close (my.input)
        pdl.dep_$(my.filename) = my.deps
    endif
    return (pdl.dep_$(my.filename)?"")
endfunction


##############################################################################
#
#   Generates project makefile, with or without code generation phase

.macro generate_project_makefile (filename, regen)
.   assert_dependency (my.filename, "generated")
.   stream_output (my.filename)
#
#   Makefile for $(pdl.name:)
#
#   Generated by iMatix Boom
.   bsd_license ("#")
#
#   Default values for object, library, and executable extensions.
#
.   if target.name = "unix"
OBJ = .o
LIB = .a
EXE =
.   elsif target.name = "win32"
OBJ = .obj
LIB = .lib
EXE = .exe
.   endif
CC  = c -q

#   Reset the suffixes that will be considered to just our own list.
#
#   Make programs use the .SUFFIXES psuedo rule for this

\.SUFFIXES:
\.SUFFIXES: \$(EXE) \$(LIB) \$(OBJ) .c .d .i .l

#   Objects depend on source files with the same name; and are compiled
#   with the iMatix c script without any arguments.
#
\.c\$(OBJ):
\t$\(CC) $<
.   if target.name = "unix"
#   And .c files _do_not_ depend on .l files (.l files are Libero files,
#   not lex input files as the default rules think).
#
#   The semicolon forces make to accept the rule as an override.
#
\.l.c: ;

.   endif
#
#   Default rule -- all depends on everything.
#   We do this so that we can define the rule at the end.
#
all: everything
#
#   The following targets are not files. Mark them as such.
#
\.PHONY: all generate everything install regen clean
#
#   Dependencies
#
.   for pdl.library
$(library.name)\$(LIB): $(library.list:)
\t$\(CC) -r $(library.name)\$(LIB) $(library.list:)
.   endfor
.   for pdl.file where filetype = "" & model?"" = ""
.       for build where count (compile, (count.[as]?"c") = "c", count)
$(basename)\$(OBJ): $(basename).c$(dependencies (basename + ".c"))
.       endfor
.       for build where count (link, (count.[as]?"c") = "c", count)
$(basename)\$(EXE): $(basename)\$(OBJ) \
.           for pdl.library
$(library.name)\$(LIB) \
.           endfor

\t$\(CC) -L $(basename)
.       endfor
.       if my.regen & defined (file.derived_from)
.           for pdl.file as parent where parent.name = file.derived_from
.               file.targetted = 0
.               for generate where generate.model?"" = ""
.                   for execute where (execute.target?target.name) = target.name
.                       if file.targetted = 0
$(file.name): $(file.derived_from)
.                           file.targetted = 1
.                       endif
\t$(command:) $(parent.name?)$(parent.ext?)
.                   endfor
.               endfor
.           endfor
.       endif
.   endfor

everything: generate \
.   for pdl.library
$(library.name)\$(LIB) \
.   endfor
.   for pdl.file where file.model?"" = ""
.       for build where count (link)
$(basename)\$(EXE) \
.       endfor
.   endfor

install:
.   if target.name = "unix"
\tsh boomake install
.   else
\tboomake install
.   endif
generate: stamp_generate
stamp_generate:
.   if target.name = "unix"
\tsh boomake regen
.   else
\tboomake regen
.   endif
regen:
.   if target.name = "unix"
\tsh boomake regen
.   else
\tboomake regen
.   endif
clean:
.   if target.name = "unix"
\tsh boomake clean
.   else
\tboomake clean
.   endif

.   stream_pop ()
.endmacro


##############################################################################
#
#   Generate product makefile

.macro make_projects (rule)
.   for pdl.project
.       if target.name = "unix"
\tcd $(directory); if test -f Makefile; then make $(my.rule); fi
.       else
\tcd $(directory)
\tif exist Makefile call nmake $(my.rule)
\tcd ..
.       endif
.   endfor
.endmacro

.macro generate_product_makefile (filename)
.   assert_dependency (my.filename, "generated")
.   stream_output (my.filename)
#
#   Makefile for $(pdl.name:)
#
#   Generated by Boom -- www.imatix.com
.   bsd_license ("#")
#
all:
.   make_projects ("")
regen:
.   make_projects ("regen")
install:
.   make_projects ("install")
clean:
.   make_projects ("clean")
.   stream_pop ()
.endmacro
