The Generator Script Language
*****************************

Author:
  iMatix Corporation <tools@imatix.com>
Revised:
  2002/03/23

Introduction
************

What is GSL?

- Generator Script Language (GSL) is a simple and powerful scripting
  language designed to work with data from Extensible Markup Language
  (XML) files.
- GSL is interpreted by GSLgen, either as a stand-alone tool or integrated
  into an application.

What can GSL do?

- GSLgen is a general-purpose file generator.
- GSL is a powerful tool for transforming XML.
- GSLgen is a reporting tool.
- GSL is a web scripting language (integrated into the Xitami
  web server).

To use GSLgen, you should be comfortable with the basic concepts of the
Extensible Markup Language (XML).  However, GSLgen does not use DTDs,
stylesheets, or the other many layers that can render XML complex to use.
When you use GSLgen, XML can be as simple as `<hello>world</hello>'.

What are the alternatives?

- A lot of work by hand.

Copyright and Distribution
==========================

GSLgen is copyright (c) 1996-2002 iMatix Corporation, and is distributed
under one of two possible licenses: the GNU General Public License (GPL),
or an commercial iMatix license.  You can use GSLgen freely under the terms
of either license.  In practice this means that if you are developing a
GPL application, you can use GSLgen source code in any way.  If you want to
incorporate GSLgen's source code in a commercial product you must contact
iMatix Corporation for a commercial license.  The GSLgen GPL license allows
you to use the command-line tool for code generation even in commercial
applications.


Installing GSLgen
*****************

GSLgen is provided as a ready-to-run executable for Windows (95/98 and NT),
OS/2 (requires EMX), and Linux.  For other platforms you can rebuild GSLgen
from the provided sources very easily.  Install and build the SFL library
from imatix.com, then build GSLgen using the `build' script provided in the
src subdirectory.  You do need to copy libsfl and sfl.h from the SFL
directory into the src subdirectory.

Using GSLgen 
************

Command-line Syntax
-------------------

To run GSLgen, use the following syntax
    gslgen -<option> ... -<attr>[:<value>] ... filename ...

If the filename has no extension, GSLgen tries to find an XML file with
that name, or with the extension `.xml' (recognised by the <?xml... tag on
the first line).  If it finds no XML file it tries to find a file with
that name or the extension `.gsl', which it interprets as a GSL file.

Options currently recognised by GSLgen are:

q, quiet:
    Suppresses copyright and other messages from GSLgen.

Command-line attributes are loaded with an XML file and are available to
a script.  This allows paramaters to be passed from the command line to the
script.  The attribute script can be set to the name of a GSL file to be
interpreted.

If GSLgen found an XML file, it loads it, then looks for an attribute named
script of the top-level item.  This name is used to find a GSL script to
interpret.  If GSLgen found a GSL file, it begins interpreting it without
loading an XML file.

Getting Started
---------------

How do I use GSLgen?

- If you have an XML file entitled test.xml, the simplest way to
  invoke GSLgen is

    gslgen test

- In this case the script must be defined as an attribute of the top-level
  item defined in test.xml.  If this is not the case, or if you wish to
  use a different script, use the form

    gslgen -script:xxxxxxx.gsl test.xml

A Hello World Example
---------------------

Try a `hello world' test:

Create a file called `hello.gsl':

    echo "hello world"

Run this using `gslgen hello'.  This shows a trivial GSL script running
without any XML data.  The script does some work, and ends.  Let's look at
how we process an XML data file.

Create a file called `hello.xml':

    <HWML>
    <WORLD NAME="World">
        <HELLO NAME="Hello" />
    </WORLD>
    </HWML>

Change `hello.gsl' (we now use a dot in the first column):

    .for world
    .  for hello
    .    echo "$(name) $(world.name)"
    .  endfor
    .endfor

Then, run GSLgen:

    gslgen -script:hello.gsl hello.xml


A More Complex Example
----------------------

This is a script which generates a simple DOS batch file to install programs
by copying them into various directories.  It's something you might want to
generate for specific projects:

    .-
    .- install.gsl   Generates install script from install.xml
    .-
    .output "install.bat"
    @echo off
    rem generated by gslgen from install.xml, $(script)
    .for file
    .  if    type = "binary"
    echo $(name) -- \\usr\\bin
    copy $(name) \\usr\\bin >nul
    .  elsif type = "script"
    echo $(name) -- \\usr\\lib
    copy $(name) \\usr\\lib >nul
    .  elsif type = "doc"
    echo $(name) -- \\usr\\doc
    copy $(name) \\usr\\doc >nul
    .  endif
    copy $(name) install >nul
    .endfor

The input is an XML file like this:

    <?xml version="1.0"?>
    <INSTALL script="install.gsl">
    <FILE name="gslgen.exe"  type="binary" />
    <FILE name="gslgen.htm"  type="doc"    />
    <FILE name="install.gsl" type="script" />
    <FILE name="hello.gsl"   type="script" />
    </INSTALL>

We run GSLgen to process the XML file:

    gslgen install

This is the result:

    @echo off
    rem generated by gslgen from install.xml, install.gsl
    echo gslgen.exe -- \usr\bin
    copy gslgen.exe \usr\bin >nul
    copy gslgen.exe install >nul
    echo gslgen.htm -- \usr\doc
    copy gslgen.htm \usr\doc >nul
    copy gslgen.htm install >nul
    echo install.gsl -- \usr\lib
    copy install.gsl \usr\lib >nul
    copy install.gsl install >nul
    echo hello.gsl -- \usr\lib
    copy hello.gsl \usr\lib >nul
    copy hello.gsl install >nul

What's Going On?
----------------

The scripts hello.gsl and install.gsl contain lines with a point (`.')
in the first column.  These are called script lines and contain
instructions to be interpreted.  The script install.gsl also contains
lines which do not begin with a point.  These are called template
lines and contain text to be output when the line is interpreted.
They may also contain substitution symbols which look like the text
`$(name)'.  Notice that each occurrence of the backslash character is
repeated in the script, but not in the output file.  This is because
GSLgen, like many programs, uses the backslash to introduce a special
character, and two backslashes are required to output one backslash.

The `for' instruction requires some explanation; it is the way to
iterate through XML data.  This is somewhat redundant in the case of
`hello.gsl' since there is only one instance of the XML items `WORLD'
and `HELLO'.  The `for' instruction makes available the attributes of
the XML item of the same name.  Thus the attributes `name' and `type'
of the items  named `FILE' in `install.xml' can be used in the lines
between the `for' and corresponding `endfor'.  Notice that in the
first example, the items `WORLD' and `HELLO' both contain an attribute
`NAME' which the script accesses independently by specifying
`$(world.name)' or `$(name)'.  It could also use `$(hello.name)' in
the second case; if the attribute name appears alone then GSLgen
searches for an attribute with that name in all open XML items
beginning with the most recently opened.

Another Complex Example
-----------------------

Try this command:

    gslgen -script:xmlfile.gsl spfper.dbm

This generates a C function, spfper.c, which handles a data table (in this
case a list of persons) as an XML file, with functions to read, save, and
update data in this table.  This is a good example of a complex GSL script,
and one that is used in real life to handle data objects in iMatix Studio.

The Generator Script Language (GSL) 
*********************************

Description
===========

GSL is a scripting language developed by iMatix Corporation. It was first
designed as a schema language for code generation and has grown into a
powerful tool for manipulating XML data.

GSL is related to a reporting language such as is used to
generate reports from a relational database, in that it provides a mechanism
for iterating through the data, performing calculations and outputing text
based on the data. Unlike a reporting language it can also manipulate, create,
load and save data.

Many GSL concepts are borrowed directly from database terminology, to which
it is closely related.

Important Concepts
==================

Data Types
----------

GSL recognises two data types: numeric and string.  It generally makes
no formal distinction between them; if a value looks numeric then it
is treated as such, otherwise it is treated as a string.  If strict typing
is required, the type conversion functions `conv.number' and `conv.string'
can be used.

Constants
---------

A string constant is specified with either single- or double-quotes as
delimiters, for example: "ABC".   String constants may continue over
several source lines.  The line break is considered part of the string
constant, unless the last character in the line is a single backslash
(`\') in which case neither the backslash nor the line break is part
of the string.  A numeric constant is a simple number with an optional
sign and optional decimal characters, for example 123 and -0.3.

Scopes
------

A scope corresponds to an XML item or, more precisely, it is the presentation
of an XML item to a piece of GSL script.  It typically, although not
necessarily, has the same name as the XML item.  A scope is created by the
`for' and `new' instructions and closed by the corresponding `endfor' and
`endnew'.  In between these lines, the value and attributes of the XML item
can be defined and accessed.  Child items (henceforth children) of the XML
item can also be made available by introducing another scope with another
`for' instruction.

Referencing Scopes
------------------

Scopes may be referred to in a variety of ways.  The default
behaviour works well in most situations.  However in difficult situations,
such as when there scopes referring to multiple XML items with the same name,
or to the same item, or when the name of the scope is unavailable, it may
be necessary to understand the following details.

A scope generally has a name, referred to as its alias.  This is generally
the same as the name of the XML item to which it refers.  A scope may also
be specified without an alias.  A scope with an alias may be referred to by
that alias.

Scopes may be either stacked or unstacked.  This affects the way in which
they can be referred to.  Stacked scopes may be referred to by number.  A
positive number n refers to the n-th stacked scope.  A negative number -n
refers to the (n+1)-th most recently opened stacked scope.  Zero, or no scope
specification at all refers to the most recently opened stacked scope.

A unstacked scope with no alias could not be referred to at all and is thus
disallowed.

A scope may be recast with a new alias, stacked or unstacked, with the
`.scope' instruction.

Predefined Scopes
-----------------

Before processing a script, GSLGen defines several scopes.  These need to
be taken into account when referring to a scope with a positive number.

The first is called `gsl', is stacked and points to an XML item called
`gsl' which can be used to hold global variables.  The second is called
`global', in unstacked and points to the same XML item.  The reason for this
is for backwards compatibility, and because a scope called `gsl' can clash
with the instruction `gsl'.  It is best to refer to this item by number (1),
or as `global'; otherwise square brackets may be required (`[gsl]') to
avoid the clash.

The next scope points to the top-level item of the XML file, if one was
specified.  It has the same name as the XML item and is stacked.

Finally there is an unstacked scope named `switches' which holds the
command-line switches.  These are copied at start-up time into the global
item referred to by the scopes `gsl' and `global'.

One more complication:

Extended Scopes
---------------

An extended scope also corresponds to an XML item.  In its simplest
form it is just a scope specification.  It may also contain any number
of `member' specifications (`->'); these refer to children of the XML
item, their children, and so on.  This allows you to avoid introducing
a new scope to access an only child or when you are only interested in
the first child of that name.

Some examples of extended scopes:

    world

The simplest form - this refers to a scope named `world'.

    .

Shorthand for the most recently opened scope.

    1-> field

The first child named `field' of the XML item corresponding to the
first open scope.

    -> parent-> baby

The first child named `baby' of the first child named `parent' of the
XML item corresponding to the most recently opened scope.

Identifiers
-----------

GSL identifiers refer to XML attribute or item values.  (An item value
is the text between its open and close tags.)  It generally consists of an
extended scope specification and an attribute name.  If the attribute name is
missing then the identifier refers to the item value.  There are also some
short-hand forms.

There are a total of five different forms of identifier specification:

<extended-scope>.<attr>:
    A full attribute specification.
<attr>:
    An attribute specification with no scope specified.  In this case GSL
    will search for an attribute with the given name in all stacked
    scopes, starting with the most recently opened.
.<attr>:
    An attribute specification with an empty scope specification.  This refers
    to the specified attribute in the most recently opened stacked scope and is
    equivalent to `0.<attr>'.
<extended-scope>.:
    An item value specification.  This refers to the value of
    the XML item referred to by the extended scope specification.
.:
    An item value specification with no scope specified.  This refers 
    to the value of the item corresponding to the most recently opened
    stacked scope.

To avoid clashes with GSL reserved words, the names of scopes, attributes
and items may be enclosed in square brackets, for example: [for].

Some examples:

    TABLE.FIELD:
    LENGTH:
    .NAME:
    TABLE-> INDEX. FIELD:
    .:
    [OUTPUT].

Case Sensitivity
----------------

GSLgen has two modes of handling the case of XML item and attribute
names.  In the default mode, GSLgen matches names without regard to
the case (upper or lower) used to specify them.  In certain
substitutions  GSLgen modifies the case of the value of the identifier
to match the case used to specify the attribute name.  In
case-sensitive mode, GSLgen matches names taking into account the
case, and does not modify the case of the result.  See the description
of subsitutions for details.

To change modes, set the value of the identifier `ignorecase' in the
global scope to 0 or 1.  Eg: `global.ignorecase = 0'

Expressions
-----------

GSL expressions are much the same as expressions in other high-level
programming languages.  They include the following operators:

Multiplicative:
    *, /
Additive:
    +, -
Default:
    ?
Comparative:
    =, <>, >, >=, <, <=
Safe comparative:
    ?=, ?<>, ?>, ?>=, ?<, ?<=
Logical:
    |, &, !

Operator precedence is standard (multiplicative, additive, default, 
comparative, logical) and brackets are treated as you would expect.

Logical operators treat zero as FALSE and non-zero as TRUE.

GSLgen optimises expression evaluation to the extent that the second
operand of a binary logical operator (`|', `&') is not evaluated if
the result of the expression is determined by the first operand.  This
allows you to use expressions such as

    defined (X) & X

since the second operator is not evaluated when X is undefined.

The default operator allows undefined expressions to be replaced by another
expression.  The value of

    <expr1> ? [<expr2>]

is equal to the value of <expr1>, if defined; otherwise it is equal to the
value of <expr2>, whether or not the latter is defined.  If the second operand
<expr2> is omitted then the evaluation of the expression is `safe', that is,
GSLgen does not object (when this is feasible) to the result of the expression
being undefined.  This feature can be used in symbol definitions and
substitutions to make GSLgen accept an undefined expression.  See the
description of these instructions for details.

The safe comparative operators return the same result as their equivalent
comparative operators when both operands are defined.  If one or both 
operator is undefined, the safe operators return FALSE while the normal
operators produce an error.  Notice that `a ?<> b' returns TRUE if both
a and b are defined and they are not equal and FALSE otherwise.

If an operand is not a constant then its type depends its value; if it looks
like a number then it is treated as a number, otherwise it is treated as a
string.

Generally, additive, multiplicative and logical operators only apply to
numeric operands.  There are two cases where an arithmetic operator can
apply to string values:

+:
    "ABC" + "DEF" results in "ABCDEF"
*:
    "AB" * 3 results in "ABABAB"

Built-In Functions
------------------

count  ([<scope> .] <child> [, <expr> [, [<alias>]]]):
    counts the number of children of the supplied or most recently opened scope
    of the given name.  If an expression is specified, it is treated as
    a condition to determine which children are counted.  In this case,
    a new stacked scope is implicitly defined while the condition is
    evaluated.  The name of this scope is the name of the XML item, unless
    an alias is specified.  For compatibility with earlier versions of GSL,
    if no alias is specified then a second, unstacked scope called `count'
    and referring to the same XML item is created.
:
    For example: count (ITEM, ITEM.NAME = "ABC")
    returns the number of children of the most recently opened scope whose
    attribute NAME has the value `ABC'.
index  ([<scope>]):
    returns the index of the item associated with the supplied or most
    recently opened scope.  This differs from the item function in
    that the  index number is assigned after filtering (`by') and
    sorting (`where'), and is undefined within `by' and `where'
    clauses.  See the description of the `for' command.
item ([<scope>]):
    returns the item number corresponding to the supplied or most
    recently opened scope.  This differs from the index function in
    that the item number is unaffected by sorting or filtering, and is
    available for use within a `where' or `by' clause.  scope.  See
    the description of the `for' command.
total ([<scope>]):
    returns the total number of iterations of a `.for' loop.
name ([<scope>]):
    returns the name of the XML item currently associated with the supplied
    or most recently opened scope.  See the description of the `for' command.
alias ([<scope>]):
    returns the name of the scope.   This can be used to find the name of
    a scope referred to by number.
defined (<expression>):
    returns a logical value (1 or 0) depending on whether the specified
    expression is defined or not.
deleted ([<scope>]):
    returns a logical value (1 or 0) depending on whether the XML item
    associated with the specified scope has been deleted.
macro (name):
    returns a logical value (1 or 0) depending on whether ot not a macro
    or function with the given name is defined or not.  The name may be
     prefixed with 'global .' - see the .macro command description for details.
scope (name):
    returns a logical value (1 or 0) depending on whether a scope exists
    with the given name.

conv.number (<expression>):
    returns the value of the expression expressed as a number, or undefined
    if the value is not numeric.
conv.string (<expression>):
    returns the value of the expression expressed as a string.
conv.chr (number):
    returns the ASCII character of the given number.
conv.ord (character):
    returns the ASCII code of the given character.

file.exists (<FileName>):
    returns a logical value (1 or 0) depending on whether a file of the given
    name exists of not.
file.timestamp (<FileName>):
    returns the modification time of the file as a sixteen-character string
    CCYYMMDDHHMMSS00; undefined if the file does not exist.
file.error ():
    returns the error message from the last file error.
file.locate (<FileName>, <path>):
    searches the path specified for the file.  If the path argument is not
    provided, searches the current PATH.  Returns the fully-specified file
    if found, otherwise returns an empty string value.
file.rename (<OldName>, <NewName>):
    renames a file from <OldName> to <NewName>.  Returns 0 if the operation
    was completed successfully, -1 otherwise.  In this case the error message
    can be obtained with file.error.
file.delete (<FileName>:
    deletes the file <FileName>.  Returns 0 if the operation
    was completed successfully, -1 otherwise.  In this case the error message
    can be obtained with file.error.
file.open (<Filename>, <mode>):
    opens a file and returns a handle to that file or undefined if the file
    could not be opened.  In the latter case, use file.error to find the
    error message..  Valid modes are 'r' (read), 'w' (write) and 'a'
    (append).   
file.read (<handle>):
    Reads from a file previously opened with file.open.  Returns a line of
    text from the file, or undefined if the end of the file has been reached.
file.write (<handle>, <text>):
    Writes the text to a file previously opened with file.open.  Returns
    zero normally or -1 if an error occured.  In this case, the error message
    can be obtained with file.error.
file.tell (<handle>):
    Returns the current offset in an open file for read/write operations.
    You can manipulate this offset using the file.seek() method.
file.seek (<handle>):
    Sets the read/write offset in the file, which must be open.  You can use
    this to read specific lines from a file.
file.close (<handle>):
    Closes a file previously opened with file.open.  Returns zero if
    successful  or -1 if an error occured.  In this case, the error message
    can be obtained with file.error.
file.copy (<FileNameSrc>, <FileNameDest>, <Mode>)
    Copies the file <FileNameSrc> to the file <FileNameDest>. The dest file
    may not already exist. If <Mode> is 'b', copies a binary file (default);
    if mode is 't', copies a text file. This distinction only applies to
    MS-DOS file systems; on other platforms the two modes are equivalent.
    Returns 0 if no problems occurred, -1 if an error occurred, 1 if the
    destination file already exists. In this case, the error message can be
    obtained with file.error.
file.basename (<FileName>):
    Removes dot and extension from the name, if any was present. If the name
    contained multiple extensions, removes the last one only. Returns name.

env.get (<Var>):
    returns the value of an environment variable <Var>.
env.set (<Var>, <Value>):
    sets the value of the environment variable <Var> to <Value>.  Returns 1 if
    if the variable was defined, 0 if it was undefined (ie <Value> is missing
    or undefined).

string.length (string):
    returns the length of a string (or number considered as a string).
string.locate (haystack, needle):
    returns the index of the first occurence of the string needle in the
    string haystack or undefined if there is none.
string.substr (string, start, end, length):
    returns a substring of the given string.  This may be used in a number of
    ways:
    
        string.substr (string, start, end, )    - specify start and end offsets
        string.substr (string, start, , length) - specify start offset and length
        string.substr (string, , end, length)   - specify end offset and length
        string.substr (string, start, , )       - end of string from start offset
        string.substr (string, , end, )         - same as substr (0, end, )
        string.substr (string, , , length)      - end of string of given length
    
string.trim (string):
    trims a string by removing trailing white space.
string.justify (string, width, prefix):
    justifies the string according to the specified width, prefixing each
    line by the string `prefix'.  If the width is zero, reformats the string
    into a single line.
string.certify (number, code-pays):
    Returns the number in litteral form. Number have to be positive and less
    or equal to 999999999. Code-pays must be in (default : en-gb):

        "fr"    : French (France)
        "en-gb" : English (United Kingdom)
        "nl"    : Dutch (Netherlands)
        "de"    : German (Germany)
        "es"    : Spanish (Traditional Sort)
        "it"    : Italian (Italy)
        "pt"    : Portuguese (Portugal)
        "fr-be" : French (Belgium)
        "da"    : Danish
        "no"    : Norwegian (Bokmal)
        "sv"    : Swedish
        "is"    : Icelandic
        "rm"    : Roman (for number)

:
    This may be used in this way:
    certify (number, ) - use default
string.replace (string, pattern):
    This function searches for known strings, and replaces them with
    another string. Example: string.replace (str, "sqv|sqr,ruv|run,h_v|h")
    This example would replace all occurences of sqv, with sqr, ruv with
    run and h_v with h.
string.match (string1, string2):
    Calculates a similarity index for the two strings. This is a value from 0
    to 32767 with higher values indicating a closer match. The two strings are
    compared without regard for case.
string.prefixed (string, prefix):
    If string starts with specified prefix, returns TRUE.
    If string does not start with specified prefix, returns FALSE.
string.prefix (string, delims):
    Looks for one of the delimiter characters in the string.
    If found, returns a string that contains the text up to that delimiter.
    If not found, returns NULL.
string.defix (string, delims):
    Looks for one of the delimiter characters in the string.
    If found, returns a string that contains the text after that delimiter.
    If not found, returns original string.
string.hash (string):
    Calculates a 32-bit hash value for the string.  The string must end in
    a null.  To use the result as a hash key, take the modulo over the hash
    table size.
string.convch (string, from, to):
    Converts all instances of one character in a string to some other character.
    Returns string. Does nothing if the string is NULL.
string.lexcmp (string1, string2):
    Performs an unsigned comparison of two strings without regard to the case
    of any letters in the strings. Returns a value that is
    
        <  0    if string1 is less than string2
        == 0    if string1 is equal to string2
        >  0    if string1 is greater than string2

string.lexncmp (string1, string2, count):
    Performs an unsigned comparison of two strings without regard to the case
    of specified number of letters in the strings. Returns a value that is

        <  0    if string1 is less than string2
        == 0    if string1 is equal to string2
        >  0    if string1 is greater than string2

string.lexwcmp (string, pattern):
    Compares two strings ignoring case, and allowing wildcards in the second
    string (the pattern). Two special characters are recognised in the
    pattern: '?' matches any character in the string, and '*' matches the
    remainder of the string. Returns a value that is:

        <  0    if string1 is less than pattern
        == 0    if string1 is equal to pattern
        >  0    if string1 is greater than pattern

string.matchpat (string, pattern, ignore_case):
    Compares two strings and allowing wildcards in the second string (the
    pattern).
:
    Two special characters are recognised in the pattern: '?' matches any
    character in the string, and '*' matches the remainder of the string, you
    can use a range of character in pattern between bracket character like
    '[aeioy]' or '[a-z0-9]'.
:
    Returns a value that is TRUE if string match the pattern.
    
string.soundex (string):
    Calculates the SOUNDEX code for the string.  Returns the address of a
    static area that holds the code.  This area is overwritten by each call to
    the soundex function.  The SOUNDEX encoding converts letters to uppercase,
    and translates each letter according to this table: A0 B1 C2 D3 E0 F1 G2
    H0 I0 J2 K2 L4 M5 N5 O0 P1 Q2 R6 S2 T3 U0 V1 W0 X2 Y0 Z2.  Non-letters are
    ignored, letters that translate to zero, and multiple occurences of the
    same value are also ignored.  This function always returns a 4-letter
    encoding: the first letter of the string followed by the first three
    significant digits.
    
string.cntch (string, value):
    Returns number of instances of a character in a string.

string.xml (scope)
    Returns the XML value of the specified scope.

string.html_encode (value)
    Returns an HTML-encoded representation of the supplied string.
    
string.html_decode (value)
    Decodes escaped XML/HTML characters in the string and returns the result.
    
math.abs (n):
    Returns the absolute value of the number n, undefined if n is not
    numeric.

math.ceil (n):
    Returns the smallest integer not less than the number n, or undefined 
    if n is not numeric.

math.floor (n):
    Returns the largest integer not greater than the number n, or undefined 
    if n is not numeric.

math.mod (x, y):
    Returns the remainder of dividing x by y, or undefined if x or y is not
    numeric or if y is zero.
math.rand:
    Generate a random number between 0 and 1.
math.sqrt (n):
    Returns the square root of the number n, undefined if n is not numeric
    or if n is negative.
math.exp (n):
    Returns e (2.7182818) raised to the n power.
math.log (n):
    Returns the natural logarithm of the number n, or undefined if n is not
    numeric or if n is negative.
math.log10 (n):
    Returns the base 10 logarithm of the number n, or undefined if n is not
    numeric or if n is negative.
math.pow (x, y):
    Returns x raised to the y power, or undefined if x or y is not numeric,
    or if x is zero and y is less than or equal to zero, or if x is negative
    and y is not an integer.
math.pi:
    Returns the value of PI (3.141592654...)
math.sin (n):
    Returns the sine of n, where n is expressed in radians. 
math.cos (n):
    Returns the cosine of n, where n is expressed in radians. 
math.tan (n):
    Returns the tangent of n, where n is given in radians.
math.asin (n):
    Returns the arc sine of n. n should be between -1 and 1.
math.acos (n):
    Returns the arc cosine of n. n should be between -1 and 1.
math.atan (n):
    Returns the arc tangent of n.
math.atan2 (x, y):
    Computes the arc tangent of y/x, using the signs of the arguments to
    compute the quadrant of the return value.
math.sinh (n):
    Returns the hyperbolic sine of n. 
math.cosh (n):
    Returns the hyperbolic cosine of n. 
math.tanh (n):
    Returns the hyperbolic tangent of n.
math.asinh (n):
    Returns the inverse hyperbolic sine of n.
math.acosh (n):
    Returns the inverse hyperbolic cosine of n. n should be greater than 1.
math.atanh (n):
    Returns the arc tangent of n. n should be between -1 and 1.

dir.load (scope, path, recurse):
    Loads the specified directory under the specified scope. All the
    parameters are optional - no scope means the top-most scope, no path
    means the current directory and no recurse means no recursion. The
    directory is loaded as one XML item per file with the following attributes:

        name
        size
        date in format YYYYMMDD
        time in format HHMMSSCC
        mode   \\
        attrs   \\
        links    >  as per sfldir.c
        owner   /
        group  /
        path
        directory as a boolean
        
dir.create (path):
    Create a new directory. Returns 0 if the directory was created; -1 if there was
    an error. Under Windows and OpenVMS, accepts directory names with '/'. Will
    create multiple levels of directory if required.
dir.delete (path, recurse):
    Remove a directory and optionally all directories below that. Returns 0
    if the directory could be removed; -1 if there was an error or the
    number of files deleted. Excludes directories from the count and
    excludes hidden files. Under Windows and OpenVMS accepts a directory name
    in UNIX format, i.e. containing '/' delimiters.
dir.cwd:
    Returns the current working directory.
dir.setcwd (path):
    Sets the current working directory with the specified directory.
dir.files (path, recurse):
    Calculates the number of files in a directory and optionally all directories
    below that. Excludes directories from the count (thus, a directory containing
    only '.' and '..' contains 0 files. Returns 0 if there was an error. Excludes
    hidden files.
    
zip.extract (zipfile, directory):
    Extracts the specified zip file into the specified directory. The directory
    parameter is optional - no directory means the current directory.
zip.load (scope, zipfile):
    Loads the specified zip file under the specified scope. The scope parameter is
    optional - no scope means the top-most scope.
    The zip file is loaded as one XML item per file with the following attributes:
    
        name
        path
        length
        method
        size
        ratio
        date in format YYYYMMDD
        time in format HHMMSSCC
        crc

zip.create (scope, zipfile, compresslevel):
    Creates the specified zip file from files under the specified scope with the
    specified compress level [1-9]. The two last parameters are optional - no scope
    means the top-most scope and no compress level means level 6 (default).
zip.new (zipfile):
    Create a new zip file and returns a handle to that zip file or undefined if
    the zip file could not be opened. In the latter case, use file.error to
    find the error message.
zip.add (handle, file):
    Add the specified file into the zip file previously created with
    zip.new.
zip.close (handle):
    Closes a zip file previously created with zip.new. Returns zero if
    successful or -1 if an error occured. In this case, the error message
    can be obtained with file.error.

date.picture (date, picture):
    Converts a date to a string using a picture.  The picture is composed
    of any combination of these formats:
    
        cc        century 2 digits, 01-99
        y         day of year, 1-366
        yy        year 2 digits, 00-99
        yyyy      year 4 digits, 100-9999
        m         month, 1-12
        mm        month, 01-12
        mmm       month, 3 letters
        mmmm      month, full name
        MMM       month, 3 letters, ucase
        MMMM      month, full name, ucase
        d         day, 1-31
        dd        day, 01-31
        ddd       day of week, Sun-Sat
        dddd      day of week, Sunday-Saturday
        DDD       day of week, SUN-SAT
        DDDD      day of week, SUNDAY-SATURDAY
        w         day of week, 1-7 (1=Sunday)
        ww        week of year, 1-53
        q         year quarter, 1-4
        \x        literal character x
        other     literal character

:
    Returns the formatted result.  If date is zero, returns an empty string.
    The 'm' and 'd' formats output a leading space when used at the start
    of the picture.  This is to improve alignment of columns of dates.
    The 'm' and 'd' formats also output a space when the previous character
    was a digit; otherwise the date components stick together and are illegible.
date.number (date):
    Converts a string date (YYYY/MM/DD) to a date number (YYYYMMDD).

time.picture (time, picture):
    Converts a time to a string using a picture.  The picture is composed of
    any combination of these formats:
    
        h         hour, 0-23
        hh        hour, 00-23
        m         minute, 0-59
        mm        minute, 00-59
        s         second, 0-59
        ss        second, 00-59
        c         centisecond, 0-99
        cc        centisecond, 00-99
        a         a/p indicator - use 12-hour clock
        aa        am/pm indicator - use 12-hour clock
        A         A/P indicator - use 12-hour clock
        AA        AM/PM indicator - use 12-hour clock
        \x        literal character x
        other     literal character
        
:
    Returns the formatted result.  If time is zero, returns an empty string.
    The 'h', 'm', 's', and 'c' formats output a leading space when used at
    the start of the picture.  This is to improve the alignment of a column
    of times.  If the previous character was a digit, these formats also
    output a space in place of the leading zero.
time.number (time):
    Converts a string time (hh:mm:ss) to a date number (hhmmsscc).

regexp.match (pattern, string, variable...)
    Implements Perl 5 compatible regular expressions via the PCRE library.
    Returns true if the string matched the pattern.  Copies matched substrings
    specified in the pattern by ($1), ($2), etc. into the variables listed
    after the string.

sock.passive (port):
    Opens the port to accept passive connections.  Returns a handle to the
    opened port.  You can use this handle in sock.accept () calls.  When you
    have finished with the port, you can close it using sock.close ().
    
sock.accept (handle [,timeout]):
    Accepts a connection on the specified handle, which must have been created
    using sock.passive ().  Returns the handle for the new connection.  If
    you specify a timeout, in seconds, will return 0 after this timeout has
    expired without a connection.
    
sock.close (handle [,timeout]):
    Closes the specified socket, after flushing all requests.  You can specify
    a timeout in seconds, after which the command will return if not completed.
    Returns zero if the close succeeded, -1 if it failed.
    
sock.connect (host, service [,timeout]):
    Connects to the specified host, and port, and returns a socket handle for
    the connection.  If you specify a timeout, in seconds, and the connection
    is not made before that time, returns -1.  Returns -1 if the connection fails
    for other reasons.

sock.error ():
    Returns the last error message produce by the socket layer.  You can use
    this function to get a printable error message for log files, etc.
    
sock.read (handle, buffer [,minimum [,timeout]]):
    Reads a number of bytes from an opened socket.  The data is placed into a
    buffer variable that you must specify.  You can also specify a minimum
    number of bytes to read.  Without this, GSL will read an unpredictable
    quantity of data from the socket.  Returns the actual number of bytes
    read.  The optional timeout, in seconds, tells GSL how long to wait.
    After this timeout passes without data being read, sock.read() will
    return 0.
    
sock.write (handle, buffer [,timeout]):
    Writes data to an opened socket.  The data is taken from the specified
    buffer.  The optional timeout, in seconds, tells GSL how long to wait
    if the socket is busy.  Returns the actual number of bytes written.

mail.send:
    To be completed.
mail.error:
    To be completed.

thread.create (command):
    Starts a new GSL thread running the specified GSL command, which is can
    be any valid GSL statement including (usefully) the name of a function
    plus arguments.  The thread is created as a child of the current thread.
    [todo: explain threaded execution, data sharing, etc.]

Template and Script Modes
-------------------------

GSL is useful as both a template and a scripting language.  In template mode,
the default mode when GSLgen starts with an XML file, script lines begin with
a point (`.') and all other lines are template lines.  In script mode, the
default mode when GSLgen starts with a GSL script, template
lines begin with a `>' (not necessarily in the first column) and all other
lines are script lines.  You can perform exactly the same operations in
template and script modes - the only difference is convenience for the type
of application.

You can change between template and script mode with the `template' and
`endtemplate' commands.  See the description of these commands below for 
details.

Template Lines
--------------

The simplest template line is just text, which is copied verbatim
to the current output file.  If no output file has been opened, or if the
last output file has been closed, the output is copied to the standard
output.

The backslash ('\') serves several special functions in a template
line.  Firstly, if the last character of an template line is a
backslash then the line is output with no line terminator; otherwise a
line terminator follows the template line.  Secondly, a backslash
introduces one of three special character sequences: '\n', '\r' and '\t' which
are replaced by a line feed, carriage return and a tabulation character (TAB)
respectively.  Thirdly, a backslash followed by and other character is
replaced by that character; this allows characters which would
normally be interpreted as script commands to be output literally.

In template mode an template line is any line which does not begin with a
point (`.').  If an template line must begin with a point, use a backslash
immediately before the point.

In script mode, an template line begins with a greater-than sign (`>'),
which is dropped before the line in output.

Script Lines
------------

In template mode, these are introduced by a point (`.') as the first
non-space character in the line.  In script mode, any line that does
not begin with a greater-than sign (`>') is a command line.  In script
mode, a script line may also begin with a point; this allows script
commands to work in case the current mode is unknown.

The script commands are described below.

If a script command line ends with a backslash (`\') then the following 
script line is treated as a continuation of the current line.

Comments
--------

There are three ways to include comments in GSL scripts.  The first is
to place a hyphen (`-') immediately after the point (`.') in a
template mode or as the first character in script mode.  The second is
to place a hash (`#') after a GSL command.  Any characters following
the hyphen are ignored by GSLGen.  The third way (pace Tony Blair) is
to enclose comment text (which may continue over more than one line)
inside comment markers (`/*' and `*/') just as in C.  However if
GSLGen finds these characters in a template line (but not inside a
substitution) it assumes that they are destined for output, so does
not treat them as a comment.

Examples:

    .- This entire line is a comment

    .output "file"  # This is a trailing comment

    .output /* This is an embedded 
    multi-line comment */ "file"

    If this is a template line then /* this is not a comment */

    $("but "/* this is */)

Substituting Symbols and Expressions
------------------------------------

At any point within a template line, and in many places (described
below) in a script line, a substitute construct may be used instead of
literal text.  The format for expression subsitution is:

    $( <expr> [% format] [: pretty-print] )

The order of the format and pretty-print modifiers is not important.

If the expression has a default operator with no second operand, and its
result is undefined then the substitution resolves to an empty string.

If a format string is provided, it is used to format the result before
continuing.  The format string is similar to that used by the printf
function in C.  It must contain exactly one conversion specification,
consisting of zero or more of the flags `#', `0', `-', ` ' and `+', an
optional minimem field width, an optional precision consisting of a
point (`.') followed by an optional number, and a mandatory conversion
specifier among the following: `d', `i', `o', `u', `x', `X', `e', `E',
`f', `g', `c' and `s'.  The data are always converted to the appropriate
type (one of long int, double, char or char *) for the conversion string.
Note that not all legal C format strings are allowed in GSL.

The pretty-print modifier specifies how case modification and replacement
of certain characters takes place.  The valid pretty-print modifiers (not
case-sensitive) are:

UPPER:
    UPPER CASE
lower:
    lower case
Neat:
    Neat Case Modification
c:
    substitute_non_alpha_to_make_c_identifier
cobol:
    SUBSTITUTE-NON-ALPHA-TO-MAKE-COBOL-IDENTIFIER
left:
    Text is left justified within available space
block:
    Text over multiple lines is formatted into a block

More than one pretty-print modifier may be specified; they should be
separated by commas.

If GSLgen is in ignore case mode, and a substition expression consists
of a single identifier and no case-modifier is specified (c or cobol
may still be specified), the case in which the identifier name is
specified is used as an example to determine whether the case of the
result should be modified to UPPER, lower or Neat.  A final exception
is that if an empty pretty-print string is provided, no case
modification is performed.

Some examples:  Assume the identifier IDENT has the value `IDENT value'
and identifer XXX is undefined.

$(XXX):
    produces a run-time GSLgen error: Undefined expression.
$(XXX?"Undefined"):
    `Undefined'
$(XXX?):
    `'
$(IDENT%12s):
    ` IDENT VALUE'
$(ident:upper):
    `IDENT VALUE'
$(Ident):
    `Ident Value'
$(ident:c):
    `ident_value'
$(IDENT:):
    `IDENT value'
$(1 + 1):
    `2'
$(ident:left   ):
    Text over
    multiple lines
    is formatted.
/*  $("Description:":block)
               \ $(desc:left,block)                     */:
    /*  Description:  Here the description will be formatted   */
    /*                into a block to make a nicely formatted  */
    /*                piece of code like this...               */

What You Can Substitute
-----------------------

A substitution can appear at any place inside straight text (template line
or string constant) or an operand in an expression.  It can also replace a
single name in an identifier specification, but not a point (`.') or member
(`->').

Some examples:  Assume the identifier IDENT has the value `NUM'
and identifer NUM has the value `1'.

$($(ident)):
    `1'
$($(ident)).NAME:
    `1.NAME'  This may used in another expression as an identifer.
$(ident)+1:
    `NUM1'
$($(ident))+1:
    `2'


Shuffle
-------

GSLgen can help to keep code neat by enlarging or shrinking white space
so that column numbers match as far as possible between the script and
the output file.  For instance, in the value of the identifier X is
ABCDEF then:

    $(X)   .

evaluates to

    ABCDEF .

but

    $(X?"Undefined") .

evaluates to

    ABCDEF .

The shuffle algorithm uses a parameter `shuffle' (actually an
attribute of the global scope) whose numeric value influences the
operation.  It expands a block of white space longer than `shuffle' as
much as necessary so that the text following the white space is output
in the same column.  It also shrinks white space down to a minimum of
`shuffle' to make space for text preceeding the white space.  If
`shuffle' is zero, then shuffle is disabled.  The default value of
`shuffle' is 1; this is the value which produces the results shown
above.

If the current output ends with a backslash, then the shuffle continues on
the following line.  Thus

    $(X?"Undefined")\\
             .

evaluates to

    ABCDEF   .

Shuffle can cause problems in some cases, for example when outputting
literal text where the size of white space is important.  In this case
shuffle should be disabled with

    .shuffle = 0

COBOL
-----

GSLgen helps you make neat COBOL code by automatically filling the first
six characters of each line with the four-digit line number followed 
by two zeroes.  To enable this function, define an attribute `cobol' of the
root item either using

    .cobol = 1

or

    gslgen -cobol etc.

when you invoke GSLgen, or even (yuk) define an attribute COBOL right in
your XML file.

Line Terminators
----------------
By default, GSL uses as its line terminator the value of of the attribute
'terminator' of the root item.  Otherwise it uses a linefeeed ('\n');

Predefined Identifiers
----------------------

There are some identifiers whose value is maintained by GSLgen in the global
space referred to by the predefined scopes `gsl' and `global'.  They are
defined as attributes of the global item.

script:
  The name of GSL or template script file currently being processed.
filename:
  The name of the XML file being processed.
outfile:
  The name of the current output file; undefined if there is none.
line:
  The line number of the line currently being output to the output file.
me:
  The name of the current application: gslgen.
version:
  The version of the current application.
date:
  The current date in the format YYYY/MM/DD
time:
  The current time in the format hh:mm:ss


Script Commands
***************

Output File Manipulation
========================

.output
-------
    .output <filename>

closes the current output file, if one is open, and opens a new one.

Examples:

    .output "myfile.c"
    .output FILENAME

where FILENAME is an identifier whose value is the desired file name.

.append
-------
    .append <filename>

closes the current output file, if one is open, and
opens a previously existing one and prepares to extend it.

See the description of the output command for examples.

.close
------
    .close

closes the current output file, if one is open.

.literal
--------
    .literal [ from <filename> | " <text> " | << <terminator> ]

Copies text directly to the output file, without substition.  The text
can come from another file, a GSL expression, or from lines in the
script, ending with a line beginning with the specified terminator.

Examples:

    .literal from "file.txt"

    .literal "whatever you want"

    .literal << .endliteral
    Lines are now copied without substitution of
    things like $(abc).
    .endliteral

Control Structures
==================

.for
----
    .for [[<extended-scope>] .] <name> [as <alias> | noalias] [nostack] [where <expr>] [by <expr>]
    .for  [<extended-scope>] .         [as <alias> | noalias] [nostack] [where <expr>] [by <expr>]

opens a scope and introduces a loop.  The following block of code is
processed once for each item specified.  If no scope if specified, the
most recently opened scope is assumed.  The items processed are those
children of the XML item corresponding to this scope.  If the first
form is used only children with the specified name are processed; if
the second form is used, all children are processed.

The alias allows you to give the new scope a name other than the
specified item name; use this when you nest scopes which would
otherwise have the same name or to supply a scope name when using the
second form.

The where clause allows you to specify a condition which must be
satisfied for the code to be processed; the expression is evaluated
before any processing occurs.

The by clause allows you to sort the items according to the result of
evaluating the expression for each item.  If no by clause is specified
the items are processed from the oldest to the youngest, the same
order in which they are described in the XML file.

The expressions in the where and by clauses are evaluated within the
new scope.  This means that they can access attributes of the iterating
item.

During the evaluation of the `by' and `where' expressions, as well as
during the processing of the code, the function `item (name)' returns
the number of the child (1, 2, ...) of the current item.  This number
is associated with the XML item itself and is not affected by a `by'
or `where' clause.

Within the loop, but not within `by' and `where' expressions, the function
`index (name)' returns the index of the current iteration.  This is associated
with the loop, so that it always takes consecutive values.

.endfor
-------
    .endfor [<scope>]

terminates a .for loop, closing the scope.  The scope name is optional and
does not affect the operation.  GSLGen confirms that its value is the name of
the scope to be closed and reports an error if this is not the case.  In this
way, GSLGen can be made to validate nested .for loops for you.

Examples:

    .for RECORD.FIELD by NAME
    $(FIELD.NAME)
    .endfor

outputs the names of the fields of the current record, sorted in alphabetical
order.

    .for FIELD as PASTURE where item () = 2
    something
    .endfor PASTURE

processes only the second item named FIELD.

.if
---
    .if <expr>

starts conditional processing of the following block of code if the result
of evaluating the expression is non-zero.

.elsif
------

    .elsif <expr>

may follow an `if' construct.  Any number of `elsif' constructs may be used.

.else
-----

    .else

may follow an `if' or `elsif' construct.  The following block of code is
processed if the logical value of all the expressions is FALSE.

.endif
------
    .endif

terminates a conditional processing construct.

Examples:

    .if NAME = "JAMES"
    something
    .elsif NAME = "JAIME"
    something else
    .else
    everything else
    .endif

.while
------
    .while <expr>

introduces a loop.  The following block of code is processed repeatedly as long
as the expression evaluates to a logical value of TRUE, that is not equal to
zero.  Expression evaluation takes place before the code is processed, so that
the code will never be processed if the expression evaluates to FALSE the first
time.

.endwhile
---------
    .endwhile

terminates a `while' loop.

Examples:

    .define I = 0
    .while I < 5
    loop iteration number $(I)
    .endwhile

.next
-----
    .next [<scope>]

inside a `for' or `while' loop causes immediate iteration, skipping execution
of any code between the `next' command and the `endfor' or `endwhile'
statement.  If the scope is specified then the `for' loop corresponding to
that scope is iterated.

.last
-----
    .last [<scope>]

inside a `for' or `while' loop causes the loop to terminate iteration
immediately.  Control passes to the line following the `endfor' or `endwhile'
statement.  If the scope is specified then the `for' loop corresponding to
that scope is terminated.

Scope Manipulation
==================

.scope
------
    .scope <extended-scope> [as <alias> | noalias] [nostack]

Opens an extended scope as a new scope.

.endscope
---------
    .endscope [<scope>]

terminates a block opened with a .scope command, closing the scope.
The scope name is optional and does not affect the operation.  GSLGen
confirms that its value is the name of the scope to be closed and
reports an error if this is not the case.  In this way, GSLGen can be
made to validate nested .scope blocks for you.

Symbol Definition
=================

.define
-------

    .[define] <identifier> [<operator>]= [ <expr> ] 

defines or undefines an XML attribute or item value.  Note that the word
`define' is itself optional; any GSL line which does not begin with a
reserved GSL word is an implied `define'.  There are several different forms,
described below:

If the scope is omitted from the identifier specification, GSLgen searches
open scopes for one in which an attribute of the specified name exists.  If
none is found, it uses the first open scope, which effectively makes 
the identifier a global variable.

If the name is omitted from an identifier, the value of the XML item is 
modified, rather than that of an attribute.

If neither scope nor name is specified, GSLgen defines the value of the XML
item associated with the most recently open scope.  This removes any existing
value and appends the new value after any children.

If the expression is left empty then the symbol becomes undefined.  If the
expression ends with a default operator `?' but no default expression then
an undefined expression causes the symbol to becume undefined rather than
producing a runtime error.

If a multiplicative, additive or default operator is specified then the
value assigned to the symbol is the result of that operator and the
supplied expression to the former value of the operator.

Examples:

    .define x = 1

assigns the value 1 to the identifier x in the most recently opened 
open scope where x is already defined, or in the global scope if x is
undefined.

    .define ->child. = "Value"

assigns the string `Value' to the value of the first XML item child
which is a child of the XML item corresponding to the most recently 
opened scope.

    .x *= 2

multiplies the value of the identifier x by 2.

    .x ?= y ? z ?

does nothing if x is already defined; otherwise assigns it the value of y,
or if y is undefined then the value of z, or if z is undefined, x remains
undefined.

XML Manipulation
================

.new
----

    .new [[<extended-scope>] .] [before <before-scope> | after <after-scope>] [as <alias> | noalias] [nostack]
    .new <name> [to <extended-scope> | before <before-scope> | after <after-scope>] [as <alias> | noalias] [nostack]

creates a new XML item.  This allows you to build new items in the
data tree.  The new item has the specified name and is a child of the
XML item corresponding to th specified scope, or the most recently
opened scope if none is specified.  If a `before-scope' or
`after-scope' is specified, then then it must be the name of an open
scope corresponding to a child of <extended-scope>, and the new item is
inserted just before <before-scope> or just after <after-scope>;
otherwise the  new item is inserted after any existing children.  The
construct creates a new scope with the name specified by the alias or
the item name if there is no alias.  The following block of code is
processed exactly once within this new scope.  It would typically done
some attributes of the new XML item.  These values can then be
retrieved during a future iteration of a `for' construct through the
new item.

.endnew
-------

    .endnew [<scope>]

terminates a `new' construct.    The scope name is optional and
does not affect the operation.  GSLGen confirms that its value is the name of
the scope to be closed and reports an error if this is not the case.  In this
way, GSLGen can be made to validate nested .new blocks for you.

Examples:

    .new RECORD.FIELD
    .    define FIELD.NAME = "NEW FIELD"
    .endnew

    .for RECORD.FIELD as OLDFIELD where NAME = "OLD FIELD"
    .    new RECORD.FIELD before OLDFIELD
    .        define FIELD.NAME = "NEW FIELD"
    .    endnew
    .endfor

.delete
-------
    .delete <extended-scope>


deletes the XML item (and any descendents) corresponding to the specified
scope.  Once the item has been deleted, any attempt to reference it produces
an error.

The function `delete (name)' allows you to determine whether the XML item
associated with a scope has been deleted.

Examples:

    .for RECORD.FIELD where TYPE = "COMMENT"
    .    delete FIELD
    .endfor

.copy
-----
    .copy [<from-scope>] [ to <parent-scope> | after <after-scope> | before <before-scope> ] [as <name>]


makes a copy the XML item associated with <from-scope> (or the most
recently opened scope if not specified) at the point 
specified by either the new parent (`to') or new sibling (`after' or
`before'), or as a child of the XML item of the most recently opened
scope if no parent of sibling is specified.  The `as' clause allows
you to the new item to have a different name from the old item.

Examples:

    .for DATABASE.TABLE
    .    for RECORD.FIELD
    .        copy FIELD to TABLE
    .    endfor
    .endfor

.move
-----
    .move [<from-scope>] [ to <parent-scope> | after <after-ident> | before <before-ident> ] [as <name>]


re-attaches an XML item at the point specified by  a `to', `after' or
`before' clause, renaming it to the name specified in the
`as' clause, if specified.

GSLgen detects any attempt to make an XML item its own descendent.

Note that moving an XML does not invalidate any scope associated with it.
If the moved XML item is associated with a future iteration of a `for' loop,
the iteration will still take place even if the item is no longer a child
of the extended scope from the `for' instruction.

Examples:

    .for TABLE.RECORD
    .    for RECORD.FIELD
    .        move FIELD to RECORD
    .    endfor
    .endfor

.sort
-----

    .sort [[<extended-scope>] .] [<name>] [as <alias>] by <expr>

Sorts the specified XML items.  A scope is created with each item in
turn and is used to evaluate the expression.  The result is then used
to sort the items.  The `as' clause allows you to give the created
scope a different name.  After execution, the specified XML items are
in order and after any other children of the same parent.

.load
-----
    .load <filename> [ to <parent-scope> | after <after-ident> | before <before-ident> ] [as <name>]


Loads the contents of an XML file at the place specified by a `to', `after' or
`before' clause, renaming the items to the name specified in the `as'
clause, if specified.

Note that `load' is deprecated.  Use `xml' instead.

.xml
----
    .xml [ to <parent-scope> | after <after-ident> | before <before-ident> ] [as <name>] [ from <filename> | <expr> || << <terminator> ]

imports XML data into the the specified point.  The data can come from a file,
an expression, or from lines in the script, ending with a line beginning with
the specified terminator.  Note that in this form, GSLgen uses the lines
literally, without substitution.

Examples:

    .xml from "data.xml"

    .xml to RECORD '<field name="date"/><field name="time"/>'

    .xml after SISTER << .endxml
    <text>
    All this text is used literally even though it contains stuff
    that looks like a substitution, eg $(abc).
    </text>
    .endxml

If the XML data is invalid, GSL aborts the script with an error message.
You can override this using the '-robust:1' command-line switch or by
including the statement 'robust = 1' in the root scope. When the robust
option is enabled, bad XML is simply discarded. Any script using this
option will have to test whether the XML was successfully loaded or not.

.save
-----

    .save <extended-scope> as <filename>

creates an XML file representing the XML item corresponding to the specified
scope.  This recursively includes all child items.

Script Manipulation
===================

.include
--------

    .include <filename>

includes another script file.  Deprecated - see `gsl'

.gsl
----

    .gsl [ from <filename> | <expr> ]

interprets the contents of the specified file or expression as GSL,
just as though it were part of the script.

Examples:

    .gsl from "header.gsl"
    .gsl GSL.TEXT

.template
---------
    .template (0 | 1)


Turns template mode on or off.

.endtemplate
------------

Terminates the block introduced by a `template' instruction.

Macros and Functions
====================

Macros and functions are pieces of GSL which can be invoked with parameters.
The only difference between a macro and as function is that macros are
interpreted in template mode and functions in script mode.

The optional prefix 'global .' in the .macro and .function commands indicate
that the function or macro should be defined globally.  This means that it
is defined for all GSL scripts for the life of the GSL interpreter, not just
the script currently executing.

When a macro or function executes, an unstacked scope is opened with the same
name as the macro or function.  An unstacked alias to this scope called `my'
is also created.  This scope holds the parameter values, and can also be used
for local variables.  Full recursion can thus be achieved.

.macro
------
    .macro [global .] <name> [(<param> [, <param>] ...)]


introduces a macro definition with the specified name.

.endmacro
---------
    .endmacro

terminates a macro definition.

.function
---------
    .function [global .] <name> [([<param>] [, <param>] ...)]


introduces a function definition with the specified name.

.endfunction
------------
    .endfunction <name>

terminates a function definition.

.return
-------

    .return [<expression>]

exits the current function, optionally returning a value.

.invoke
-------
    .[invoke] <name> [([<expr>] [, [<expr>]])] ...)]


causes a previously defined macro or function to be processed.  Note that
the keyword `invoke' is optional, so that a function can be invoked by simply
giving its name and a (possibly empty) parameter list.

A macro or function can also be invoked as an expression.  In this case,
the value of is that returned, or is undefined if there is no `.return'
statement.

This creates a special scope with the name of the macro or function,
and attributes corresponding to the parameters value of the
parameters.  This scope does not count in numeric scope specifications
and cannot have children.  It can be used to define local variables,
but must in this case be specified by name.

The number of expressions (or empty expressions) must match exactly
the number of parameters in the definition.  An empty expression or an
expression whose value is undefined causes the corresponding parameter
to be undefined during processing of the macro code.

Examples:

    .macro echotwice (text)
    .    echo text
    .    echo text
    .endmacro
    ...
    .echotwice ("Hello")

    .function recursive (N)
        recursive.localvar = N - 1
        recursive (localvar)
    .endfunction

    .function assign (dest, source)
        .$(dest) = source
    .endfunction

Miscellaneous
=============

.echo
-----

    .echo <expr>

outputs the given expression to the standard output.

.abort
------

    .abort <expr>

outputs the given expression to the standard output and halts GSLgen
operation.


