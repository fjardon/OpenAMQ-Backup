<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
  <title>The ASL PAL System</title>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <link rel="stylesheet" href="gdstyle.css" type="text/css">
</head>

<body leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">

<table border="0" cellspacing="0" cellpadding="0" height="100%" width="100%">
  <tr height="60">
    <td width="20%" align="left"><img src="mainlogo.jpg" alt="Logo" border="0" hspace="20"></td>
    <td valign="middle" class="header">OpenAMQ/1.2b1 - The ASL PAL System - The Protocol Automation Language</td>
  </tr>
  <tr valign="top">
    <td width="20%" class="tdbgcolor">
<p class="toc_1"><a class="toc_main" href="palguide.txt_flat.html#TOC1" target="body">Document Control</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC2" target="body">Change History</a></p>
<p class="toc_1"><a class="toc_main" href="palguide.txt_flat.html#TOC3" target="body">Overview</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC4" target="body">Introducing PAL</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC5" target="body">A Quick Start</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC6" target="body">Jargon and Conventions</a></p>
<p class="toc_1"><a class="toc_main" href="palguide.txt_flat.html#TOC7" target="body">The Problem PAL Solves</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC8" target="body">ASL Refresher</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC9" target="body">Large-scale Testing</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC10" target="body">The PAL Architecture</a></p>
<p class="toc_1"><a class="toc_main" href="palguide.txt_flat.html#TOC11" target="body">The PAL Language</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC12" target="body">Some Sample PAL Scripts</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC13" target="body">The Standard PAL Commands</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC14" target="body">Basic Script Structure</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC15" target="body">The Include Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC16" target="body">The Macro Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC17" target="body">The Session Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC18" target="body">The Invoke Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC19" target="body">The Server Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC20" target="body">The Timer Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC21" target="body">The Set Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC22" target="body">The Inc Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC23" target="body">The Dec Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC24" target="body">The Random Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC25" target="body">The Read Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC26" target="body">The Echo Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC27" target="body">The Assert Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC28" target="body">The Repeat Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC29" target="body">The While Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC30" target="body">The Break Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC31" target="body">The Else Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC32" target="body">The Elsif Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC33" target="body">The Wait Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC34" target="body">The Sleep Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC35" target="body">The Abort Command</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC36" target="body">The Exit Command</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC37" target="body">Protocol-Specific PAL Commands</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC38" target="body">An Example</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC39" target="body">General Principles</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC40" target="body">Content Commands</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC41" target="body">Protocol Method Commands</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC42" target="body">Processing Arrived Content</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC43" target="body">Processing Returned Content</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC44" target="body">Synchronous Content Processing</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC45" target="body">PAL Variables</a></p>
<p class="toc_1"><a class="toc_main" href="palguide.txt_flat.html#TOC46" target="body">PAL Implementations</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC47" target="body">The StdC PAL Implementation</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC48" target="body">Command-Line Arguments</a></p>
<p class="toc_3"><a class="toc" href="palguide.txt_flat.html#TOC49" target="body">Performance Measurements</a></p>
<p class="toc_2"><a class="toc" href="palguide.txt_flat.html#TOC50" target="body">Other Implementations</a></p></td>
    <td>
      <table>
      <tr>
        <td><h1><a name="TOC1">Document Control</a></h1>
<h2><a name="TOC2">Change History</a></h2>
<dl>
<dt><b>1.2b0</b></dt>
<dd><timer> lets you reset the script clock. </dd>
<dt><b>1.2a1</b></dt>
<dd><session> can now specify server to connect to. </dd>
<dt><b>1.2a0</b></dt>
<dd>'Bounced' content renamed to 'Returned' content. </dd>
<dt><b>1.1d2</b></dt>
<dd>Added -c option for performance statistics (message latencies, and throughputs). </dd>
<dt><b>1.1d2</b></dt>
<dd>Content size argument was being ignored - fixed. </dd>
<dt><b>1.1d2</b></dt>
<dd>Default target set to 'stdc'. </dd>
<dt><b>1.1d2</b></dt>
<dd><while> was not correctly produced, fixed. </dd>
<dt><b>1.1d2</b></dt>
<dd>Added progress indicator to repeat command. </dd>
<dt><b>1.1d1</b></dt>
<dd>Added ability to add message headers to content produced by external application (similar to web CGI applications). </dd>
<dt><b>1.1d1</b></dt>
<dd>Added <exit status = "..."/> command. </dd>
<dt><b>1.1d0</b></dt>
<dd>Added -a option which allows full animation of the script. </dd>
<dt><b>1.1d0</b></dt>
<dd>Added <set ... cmdline = ""> to allow variables to be set by command-line switches. </dd>
<dt><b>1.1d0</b></dt>
<dd>Added -r option to repeat script specified number of times, which can be infinite. </dd>
<dt><b>1.1d0</b></dt>
<dd>Added body_size variable, which can be used after a <content exec> to check size of generated content. </dd>
<dt><b>1.1d0</b></dt>
<dd>Added ability to run arbitrary programs (tested with Perl scripts).  </dd>
</dl>
<h1><a name="TOC3">Overview</a></h1>
<h2><a name="TOC4">Introducing PAL</a></h2>
<p>And Base/2 begat ASL which begat PAL. PAL is a scripting system for ASL-based protocol clients.  Mainly, we built PAL to make it simple to write test cases for OpenAMQ.  There are several neat things about PAL.  One: the scripting language is easy to use. Two: it can be turned into code in any programming language.  Three: as AMQ evolves, the PAL scripting language automatically keeps up, since the PAL grammar (the stuff that defines what the scripting commands are) is produced automatically from the ASL specifications for AMQ. </p>
<h2><a name="TOC5">A Quick Start</a></h2>
<p>Build Base/2 and OpenAMQ. In the asl/pal directory, you'll find a collection of PAL examples.  Read these, and try them.  To build and run a PAL script, use the 'pal' command. </p>
<h2><a name="TOC6">Jargon and Conventions</a></h2>
<dl>
<dt><b>ASL</b></dt>
<dd>Abstract Server Language - an iMatix technology for defining protocols and building clients and servers that implement such protocols.  ASL is a language, a set of protocol standards, and a set of tools. ASL is itself constructed using XNF. </dd>
<dt><b>XNF</b></dt>
<dd>XML Normal Form - an iMatix technology for defining XML grammars and building code generators that implement such grammars. XNF is a language, and a set of tools.  XNF is constructed using XNF. The key point of XNF is to generate a full validating and denormalising parser and to couple this with hand-written back-end code generators (aka "targets"). </dd>
<dt><b>GSL</b></dt>
<dd>Generator Scripting Lanuage - an iMatix technology used to build code generators.  GSL is a scripting language designed to work with tree-structured data (usually XML) and inject this data into a template-driven code generation process.  All iMatix code generators are written in GSL, and most are complex enough to benefit from being constructed using XNF. </dd>
<dt><b>PAL</b></dt>
<dd>Protocol Automation Language - an iMatix technology for writing scripts to automate the client half of a discussion carried out in a protocol built with ASL.  PAL is a add-on to ASL. </dd>
<dt><b>PAL/P</b></dt>
<dd>PAL implementation for a protocol called "P".  Since PAL is not a single language but a class of languages, all built from the same basis, we call the actually languages "PAL/" plus the name of the prototol.  Thus, "PAL/AMQ", "PAL/demo". </dd>
<dt><b>Session</b></dt>
<dd>Another name for "channel".  We use "channel" at the protocol level and "session" at the API level, mainly because "session" maps to existing APIs like JMS, while "channel" is common usage for multiplexing networking protocols such as ours. </dd>
</dl>
<h1><a name="TOC7">The Problem PAL Solves</a></h1>
<h2><a name="TOC8">ASL Refresher</a></h2>
<p>iMatix ASL - the Abstract Server Language - is a protocol and software-construction toolkit we built in order to help develop OpenAMQ. The concept of ASL is loosely based on the concept of formal grammars such as ASN.1, but in typical iMatix fashion is rather more aggressive in aiming to generate high-quality code and documentation. </p>
<p>ASL is a formal language, a grammar.  It does not define the low-level wire-protocol but rather the higher-level language that a protocol carries.  We describe this language in terms of "methods", grouped into "classes".  The specific technology used to carry these methods depends on the specific implementation.  Thus, ASL is abstract. </p>
<p>ASL is an extensible framework - a single ASL grammar can be fed to any number of different back-end "targets", each generating some different output.  Today we have targets for: </p>
<ul>
<li>A Standard C implementation of client and server layers.</li>
<li>A Java implementation of client layers.</li>
<li>Documentation in iMatix gurudoc format.</li>
</ul>
<p>This diagram shows the overall ASL code generation process: </p>
<pre>
 .----------------.
 |  ASL grammar   |         ASL grammar written as XML files, using
 | for protocol P |         inheritence and other XNF techniques.
 `----------------'
         :
+------------------+
|  ASL front-end   |        GSL parser, generated from asl.xnf.
|      parser      |        using the iMatix XNF toolkit.
+------------------+
         :
 .----------------.
 |  Denormalised, |         Data structure held in memory.
 | validated tree |
 `----------------'
         :
+------------------+
|     Specific     |        GSL code generator, written by hand.
|  back-end target |
+------------------+
         :
 .----------------.
 | Generated text |         Documentation or code as desired.
 |    outputs     |
 `----------------'
</pre>
<p>We can summarise the approach that drives ASL: </p>
<ol>
<li>Define an abstract and high-level syntax capable of supporting the full functionality required by all possible protocols in our domain.</li>
<li>Implement the code generators for this abstract syntax.</li>
<li>Use the syntax to define our full protocol.</li>
</ol>
<p>Note the major benefit of using ASL: writing a large and rich protocol is very cheap, as 100% of the protocol support both at the client and server side is generated, leaving only the functional implementation of the protocol methods as work for the programmer. </p>
<h2><a name="TOC9">Large-scale Testing</a></h2>
<p>By making it cheap to design and implement functionality on top of a standard technical base, ASL also encourages very large and explicit protocols. While a hand-built protocol might use a single method for several purposes, ASL would encourage the definition of several individual methods. This clarity is very pleasant for the application developer, but it means that testing must also happen on a large scale. </p>
<p>This - cheap large-scale testing - is the problem that PAL solves. </p>
<h2><a name="TOC10">The PAL Architecture</a></h2>
<p>These diagrams show how PAL fits into the toolchain. First, the process of constructing a PAL generator for a particular protocol, 'P': </p>
<pre>
      .----------------.
      |  ASL grammar   |         ASL grammar written as XML files, using
      |    "p.asl"     |         inheritence and other XNF techniques.
      `----------------'
              :
     +------------------+
     |  ASL front-end   |        GSL parser, generated from asl.xnf.
     |      parser      |        using the iMatix XNF toolkit.
     |  "asl_gen.gsl"   |
     +------------------+
              :
      .----------------.
      |  Denormalised, |         Data structure held in memory.
      | validated tree |
      `----------------'
              :
     +------------------+
     |       PAL        |        GSL code generator, hand-made.
     |  back-end target |
     |   "asl_pal.gsl"  |
     +------------------+
        :           :
+-----------+   +-----------+
|  PAL XNF  |   |  PAL stdc |    GSL code generators, hand-made
|  driver   |   |   driver  |
+-----------+   +-----------+
      :               :
.-----------.         :
|   PAL/P   |         :          XNF grammar of PAL language
|  grammar  |         :          specifically for protocol 'P'
`-----------'         :
      :               :
.-----------.   .-----------.
| front-end |   |   stdc    |    Components of a PAL generator
| for PAL/P |   |  target   |    specifically for protocol 'P'
`-----------'   `-----------'

gsl -target:pal p.asl
gsl p_pal.xnf
</pre>
<p>Second, the process of turning a PAL script into executable code: </p>
<pre>
 .----------------.
 |  PAL/P script  |         PAL script written as XML files, using
 |  "example.pal" |         include and other XNF techniques.
 `----------------'
         :
+------------------+
|  PAL/P front-end |        GSL parser, generated from p.asl
|      parser      |        (see previous diagram).
| "p_pal_gen.gsl"  |
+------------------+
         :
 .----------------.
 |  Denormalised, |         Data structure held in memory.
 | validated tree |
 `----------------'
         :
+------------------+
|       stdc       |        GSL code generator, generated from
|  back-end target |        p.asl (see previous diagram).
| "p_pal_stdc.gsl" |
+------------------+
         :
 .----------------.
 |  Source code   |         Generated C test program.
 |  "example.c"   |
 `----------------'
</pre>
<p>To illustrate, these are the commands that would be used to perform the above chain, for a script called "example": </p>
<pre>
gsl example.pal
</pre>
<p>The resulting test program is compiled and linked as usual. </p>
<h1><a name="TOC11">The PAL Language</a></h1>
<p>PAL is not a single language but rather a combination of two things: </p>
<ol>
<li>A standard set of control commands.</li>
<li>The classes and methods defined for the specific protocol in question.</li>
</ol>
<p>The standard commands provide loops, if blocks, variables etc.  The protocol method commands talk to the server. </p>
<h2><a name="TOC12">Some Sample PAL Scripts</a></h2>
<p>As a basis for this tutorial we take the 'demo' protocol provided with ASL. Here is a sample PAL/demo script: </p>
<pre>
<?xml?>
<pal
    name = "hello"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <echo>
    Hello world!
    </echo>
</pal>
</pre>
<p>Here is a script that demonstrates some of the standard PAL control commands: </p>
<pre>
<?xml?>
<pal
    name = "loop1"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <set name = "index" value = "0" />
    <repeat>
        <inc name = "index" />
        <if name = "index" value = "10">
            <break/>
        </if>
        <else>
            <echo>I can count up to $index</echo>
        </else>
    </repeat>
</pal>
</pre>
<p>And an equivalent, shorter version: </p>
<pre>
<?xml?>
<pal
    name = "loop2"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <repeat times = "10" counter = "index">
        <echo>I can count up to $index</echo>
    </repeat>
</pal>
</pre>
<p>To connect to a server and open a session we use the <session> control command. Here is a script that connects to a server and then displays the connection properties: </p>
<pre>
<?xml?>
<pal
    name = "session"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <session>
        <echo>version_major=$version_major</echo>
        <echo>version_minor=$version_minor</echo>
        <echo>channel_max=$channel_max</echo>
        <echo>frame_max=$frame_max</echo>
        <echo>heartbeat=$heartbeat</echo>
        <echo>context_key=$context_key</echo>
        <echo>server_product=$server_product</echo>
        <echo>server_version=$server_version</echo>
        <echo>server_platform=$server_platform</echo>
        <echo>server_copyright=$server_copyright</echo>
        <echo>server_information=$server_information</echo>
    </session>
</pal>
</pre>
<p>These are the connection properties for the demo protocol. Other protocols such as AMQ may have other or different properties. You will want to read the API documentation for the protocol to know what these are. </p>
<p>Note that the script does not specify what server to talk to, nor the IP port. These and other options are passed on the command-line. For the standard C PAL implementation run the script executable with "-h" to get a list of all options. </p>
<p>Having established a session we can send methods to the server: </p>
<pre>
<?xml?>
<pal
    name = "single"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <session>
        <exchange_declare exchange = "myexchange" class = "fanout" />
        <queue_declare queue = "myqueue" scope = "default" />
        <queue_bind queue = "myqueue" scope = "default" exchange = "myexchange" />
        <basic_content size = "64000" message_id = "id-0001" />
        <basic_publish exchange = "myexchange" routing_key = "myqueue" />
        <basic_browse queue = "myqueue" scope = "default" />
        <basic_arrived>
            <echo>Message '$message_id' came back to us</echo>
        </basic_arrived>
        <empty>
            <echo>Message did not come back, this is bad!</echo>
        </empty>
    </session>
</pal>
</pre>
<p>PAL lets us define often-used method arguments at the 'session' level. These are then inherited to methods that don't explicity specify them. So we can rewrite the above script to make it shorter: </p>
<pre>
<?xml?>
<pal
    name = "single2"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <session
        exchange = "myexchange"
        queue = "myqueue"
        scope = "default"
        >
        <exchange_declare class = "fanout" />
        <queue_declare />
        <queue_bind />
        <basic_content size = "64000" message_id = "id-0001" />
        <basic_publish routing_key = "myqueue" />
        <basic_browse />
        <basic_arrived>
            <echo>Message '$message_id' came back to us</echo>
        </basic_arrived>
        <empty>
            <echo>Message did not come back, this is bad!</echo>
        </empty>
    </session>
</pal>
</pre>
<p>We can also create content bodies by reading data from test data files, or by running helper commands.  See the 'read' and 'exec' options for the content commands.  It's as simple as (for instance): </p>
<pre>
<basic_content exec = "perl -S myprog.pl" />
</pre>
<p>Scripts can be made flexible by passing arguments on the command line.  Here is a simple example: </p>
<pre>
<?xml?>
<pal
    name = "cmdline"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <set name = "number" value = "1234" cmdline = "N" />
    <set name = "string" value = "abcd" cmdline = "S" />
    <echo>Number=$number, string=$string</echo>
</pal>
</pre>
<p>Which we can run with the options -N and -S: </p>
<pre>
cmdline -N 9999 -S XXXX
</pre>
<p>Lastly let's look at macros, which are ways of collecting repetitive commands into groups to save time: </p>
<pre>
<?xml?>
<pal
    name = "macros"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <macro name = "queue new">
        <exchange_declare exchange = "stdqueue" class = "fanout" />
        <queue_declare queue = "$queue" scope = "default" />
        <queue_bind queue = "$queue" exchange = "stdqueue" />
    </macro>
    <macro name = "send message">
        <basic_content size = "$size" message_id = "id-$random" />
        <basic_publish exchange = "stdqueue" routing_key = "$queue" />
    </macro>
    <session>
        <set name = "queue" value = "myqueue" />
        <invoke macro = "queue new" />
        <invoke macro = "send message">
            <set name = "size" value = "64000" />
        </invoke>
        <basic_browse queue = "myqueue" scope = "default" />
        <basic_arrived>
            <echo>Message '$message_id' came back to us</echo>
        </basic_arrived>
        <empty>
            <echo>Message did not come back, this is bad!</echo>
        </empty>
    </session>
</pal>
</pre>
<p>If you use macros to any extent you'll want to look at the <include> command, described in the next section. </p>
<h2><a name="TOC13">The Standard PAL Commands</a></h2>
<p>These are the basic scripting commands, which can be nested to form scripts of any complexity: </p>
<pre>
invoke  - invoke a macro
server  - start a protocol server
set     - define or modify a variable
inc     - increment a counter variable
dec     - decrement a counter variable
echo    - echo text to the console
abort   - echo text to the console and abort the script
assert  - assert some condition is true
repeat  - repeat a loop some number of times
while   - repeat a loop while some condition is true
break   - exit a loop
if      - execute commands if a condition is true
else    - execute commands if the previous if condition was false
elsif   - combined if and else
wait    - wait for the server to return data
sleep   - pause the script
</pre>
<h3><a name="TOC14">Basic Script Structure</a></h3>
<p>The basic structure of the script is: </p>
<pre>
<pal
    name = "scriptname"
    script = "palscript"
    target = "stdc"
    [ <include filename = "filename" /> ]...
    [ <macro name = "macroname">
        [ script command ]...
      </macro> ]...
    [ <session>
        [ script command ]...
      </session> ]...
</pal>
</pre>
<ul>
<li>To write PAL scripts for the ASL demo protocol, use 'script = "demo_pal_gen"'.</li>
<li>To write PAL scripts for the AMQ protocol, use 'script = "amq_pal_gen"'.</li>
</ul>
<h3><a name="TOC15">The Include Command</a></h3>
<p>The <include> command copies the contents of another PAL file into the current script.  It has this syntax: </p>
<pre>
<include
    filename = "scriptfile"
    />
</pre>
<ul>
<li>The filename must include the file extension.  The included file should not have a <pal> level but may contain macros or script commands.</li>
</ul>
<h3><a name="TOC16">The Macro Command</a></h3>
<p>The <macro> command defines a block of commands that can be reused in as a single command in the script.  It has this syntax: </p>
<pre>

<macro
    name = "macroname">
    [ script command ]...
</macro>
</pre>
<ul>
<li>Macros have no effect until they are used through the 'invoke' command.</li>
</ul>
<h3><a name="TOC17">The Session Command</a></h3>
<p>The <session> command defines a session: </p>
<pre>
<session
  [ server = "servername" ]
  [ failover = "msecs" ]
    >
    [ script command ]...
</session>
</pre>
<ul>
<li>PAL may in future allow multiple sessions to be started in parallel, but for now sessions are executed serially.  Each session will restart in a new connection, whatever the state of previous sessions.</li>
<li>The servername can be used to test multiple servers in a single script. This option is not used for general-purpose scripts.</li>
<li>If the failover is set to an integer greater than zero, on a broken connection the script will pause for the specified number of milliseconds, and then try to reconnect to the same or alternate server.  To use alternate servers, specify multiple server names in the 'server' attribute, seperated by spaces.</li>
</ul>
<h3><a name="TOC18">The Invoke Command</a></h3>
<p>The <invoke> command expands a macro: </p>
<pre>
<invoke
    macro = "macroname"
    />
</pre>
<ul>
<li>If the macro uses variables in commands, you can set these variables either before the <invoke> command, or inside it, using <set> commands.</li>
</ul>
<h3><a name="TOC19">The Server Command</a></h3>
<p>The <server> commands starts or restarts a protocol server: </p>
<pre>
<server
    name = "servername"
  [ stdout = "filename" ]
  [ stderr = "filename" ]
  [ where = "directory" ]
    />
</pre>
<ul>
<li>Do not specify a file extension (.exe) or your scripts will not be portable.</li>
<li>If a protocol server was already started, this command stops the server and then restarts it.</li>
<li>Only one protocol server can be started at a time.</li>
<li>The name value can include arbitrary server arguments but not shell redirection commands.</li>
<li>To redirect the server's output, use the stdout and stderr options.</li>
</ul>
<h3><a name="TOC20">The Timer Command</a></h3>
<p>The <timer> commands shows or resets the script timer. </p>
<pre>
<timer
  [ action = "show | reset" ]
    />
</pre>
<ul>
<li>The action is optional and defaults to "reset".</li>
</ul>
<h3><a name="TOC21">The Set Command</a></h3>
<p>The <set> command defines a variable. Variables can be strings or integers. You can use variables in repeat, while, and if blocks, and as symbols for templating arguments and strings. Untyped variables are typed according to their value. </p>
<pre>
<set
    name = "variablename"
  [ value = "newvalue" ]
  [ type = "string | integer" ]
    cmdline = "char"
    />
</pre>
<ul>
<li>The value is optional, and defaults to "".</li>
<li>If the value is purely numeric, the type will default to "integer", and if not the type will default to "string".</li>
<li>The cmdline option specifies a single character. Do not use one of the command-line options already used by the PAL implementation (see section at the end of this document).</li>
</ul>
<h3><a name="TOC22">The Inc Command</a></h3>
<p>The <inc> command increments an integer variable: </p>
<pre>
<inc
    name = "variablename"
    />
</pre>
<h3><a name="TOC23">The Dec Command</a></h3>
<p>The <dec> command decrements an integer variable: </p>
<pre>
<dec
    name = "variablename"
    />
</pre>
<ul>
<li>Decrementing a variable below zero is illegal and raises a fatal error. This is done to catch script errors - negative values are normally not meaningful in test scripts.</li>
</ul>
<h3><a name="TOC24">The Random Command</a></h3>
<p>The <random> command sets a variable to a random value within a specified range: </p>
<pre>
<random
    name = "variablename"
  [ min = "minvalue" ]
    max = "maxvalue"
    />
</pre>
<ul>
<li>The minimum is optional, and defaults to zero.</li>
</ul>
<h3><a name="TOC25">The Read Command</a></h3>
<p>The <read> command accepts a line of input from the console and assigns this to a variable: </p>
<pre>
<read
    name = "variablename"
  [ prompt = "promptstring" ]
    />
</pre>
<ul>
<li>The prompt is optional; if defined, this will be shown to the user (with no newline) before the console waits for input.</li>
</ul>
<h3><a name="TOC26">The Echo Command</a></h3>
<p>The <echo> command echoes a line of text: </p>
<pre>
<echo [trace = "1|2|3"]>line of text</echo>
</pre>
<ul>
<li>The text can use variables with the syntax: $variablename.</li>
<li>The trace level set using a command-line switch.  Use the help option (-h) on the test program for details.</li>
</ul>
<h3><a name="TOC27">The Assert Command</a></h3>
<p>The <assert> command tests a condition and aborts the script if the condition is false. </p>
<pre>
<assert
    name = "variablename"
  [ test = "eq | ne | gt | lt | ge | le" ]
  [ value = "testvalue" ]
    >[line of text]</assert>
</pre>
<ul>
<li>The variablename is a script variable, or a connection or session property, or a standard PAL variable.</li>
<li>If the test and value are not specified, they default to "ne" and "0" or "" depending on the type of variable.</li>
<li>If just the test is not specified, it defaults to "eq".</li>
<li>If the assert statement includes a message, this is printed before an assertion failure.</li>
</ul>
<h3><a name="TOC28">The Repeat Command</a></h3>
<p>The <repeat> command defines an iterative loop, which can run forever or for a specified number of times. The counter is global (do not use the same counter for two nested loops). To access the counter within the repeat loop, use $variablename. </p>
<pre>
<repeat
  [ counter = "variablename" ]
  [ times = "integer" ]
  [ progress = "integer" ]
    >
    [ script command ]...
</repeat>
</pre>
<ul>
<li>If the times attribute is not specified, the loop will run forever or until the script does a <break/>.</li>
<li>The counter does not need to be previously defined. If no counter is specified, the repeat loop will create its own internal counter which cannot then be used as a symbolic value.</li>
<li>If the progress option is set to an integer N, then after every N passes through the loop, the test script will print a dot to the standard error output.</li>
</ul>
<h3><a name="TOC29">The While Command</a></h3>
<p>The <while> command defines a conditional loop, which runs so long as a specified condition is true: </p>
<pre>
<while
    name = "variablename"
  [ test = "eq | ne | gt | lt | ge | le" ]
  [ value = "testvalue" ]
  [ counter = "variablename" ]
  [ progress = "integer" ]
    >
    [ script command ]...
</while>
</pre>
<ul>
<li>See the <assert> command for an explanation of the test and value properties.</li>
<li>If a counter is specified, this variable is automatically set to zero when the while loop starts and incremented each time the loop runs.  You can access the counter variable after the while loop.</li>
<li>If the progress option is set to an integer N, then after every N passes through the loop, the test script will print a dot to the standard error output.</li>
</ul>
<h3><a name="TOC30">The Break Command</a></h3>
<p>The <break> command exits the enveloping repeat or while loop and has this syntax: </p>
<pre>
<break/>

</pre>
<p>The <if> command defines a block that is executed if a specific condition is true: </p>
<pre>
<if
    name = "variablename"
  [ test = "eq | ne | gt | lt | ge | le" ]
  [ value = "testvalue" ]
    >
    [ script command ]...
</if>
</pre>
<ul>
<li>See the <assert> command for an explanation of the test and value properties.</li>
</ul>
<h3><a name="TOC31">The Else Command</a></h3>
<p>The <else> command defines a block that is executed if the previous <if> condition was false: </p>
<pre>
<else>
    [ script command ]...
</else>
</pre>
<h3><a name="TOC32">The Elsif Command</a></h3>
<p>The <elsif> command defines a block that is executed if the previous <if> condition was false and some further condition is true: </p>
<pre>
<elsif
    name = "variablename"
  [ test = "eq | ne | gt | lt | ge | le" ]
  [ value = "testvalue" ]
    >
    [ script command ]...
</elsif>
</pre>
<ul>
<li>See the <assert> command for an explanation of the test and value properties.</li>
</ul>
<h3><a name="TOC33">The Wait Command</a></h3>
<p>The <wait> command pauses the script for a number of milliseconds, or until content is received from the server, whichever is sooner: </p>
<pre>
<wait
  [ timeout = "milliseconds" ]
    />
</pre>
<ul>
<li>Inside a session the default timeout is 'forever'.  Outside a session, the default timeout is 'zero'.</li>
</ul>
<p>Here is an example of using the <wait> command: </p>
<pre>
<?xml?>
<pal
    name = "waiting"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <set name = "index" value = "0" />
    <echo>Waiting without an active connection...</echo>
    <wait timeout = "1000" />
    <session>
        <echo>Waiting inside an active connection...</echo>
        <wait timeout = "1000" />
    </session>
    <echo>OK</echo>
</pal>
</pre>
<h3><a name="TOC34">The Sleep Command</a></h3>
<p>The <sleep> command pauses the script for an exact number of milliseconds. Unlike it's cousin <wait>, the sleep time is not affected by any traffic on the session. </p>
<pre>
<sleep
    timeout = "milliseconds"
    />
</pre>
<ul>
<li>Timeout is required for <sleep>.</li>
</ul>
<h3><a name="TOC35">The Abort Command</a></h3>
<p>The <abort> command echoes a line of text and halts the script. </p>
<pre>
<abort>line of text</abort>
</pre>
<ul>
<li>The text can use variables with the syntax: $variablename.</li>
</ul>
<h3><a name="TOC36">The Exit Command</a></h3>
<p>The <exit> command halts the script. </p>
<pre>
<exit [status = "value"] >
</pre>
<ul>
<li>The default status value is 0.</li>
</ul>
<h2><a name="TOC37">Protocol-Specific PAL Commands</a></h2>
<h3><a name="TOC38">An Example</a></h3>
<p>This script sends 10 messages to the server and then reads them back. It uses the simple browse commands - not asynchronous consumers - and is specific to the demo protocol (using AMQ one would probably use consumers and <wait/> commands to get messages): </p>
<pre>
<?xml?>
<pal
    name = "content"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <session
        queue    = "test-queue"
        exchange = "test-exchange"
        scope    = "test">
        <exchange_declare class = "fanout" />
        <queue_declare />
        <queue_bind>
            <arguments>
                <field name = "currency" value = "USD" />
                <field name = "symbol"   value = "MSFT" />
            </arguments>
        </queue_bind>
        <repeat times = "10" counter = "id">
          <basic_content size = "64000" content_type = "text/html" message_id = "id-$random">
            <headers>
              <field name = "Numbering" value = "$id" />
              <field name = "Max-items" value = "100" />
              <field name = "Server-name" value = "http://www.openamq.org" />
            </headers>
          </basic_content>
          <basic_publish routing_key = "test-queue" />
        </repeat>
        <repeat>
            <basic_browse />
            <basic_returned>
                <echo>Returned: $message_id</echo>
            </basic_returned>
            <basic_arrived>
                <inc name = "count" />
                <echo>Arrived: $message_id, numbering=$headers-Numbering</echo>
            </basic_arrived>
            <empty>
                <break/>
            </empty>
        </repeat>
        <echo>Total number of messages exchanged: $count</echo>
    </session>
</pal>
</pre>
<h3><a name="TOC39">General Principles</a></h3>
<p>ASL protocols have the useful property of being very high-level. That is, the protocol methods generally need little or no abstraction to be immediately obvious and useful to application developers. This makes it reasonable in PAL to simply expose the protocol methods directly to the scripting language. This strategy is helped by: </p>
<ul>
<li>The use of clear and consistent names for methods and method properties.</li>
<li>The use of intelligent defaults for optional properties.</li>
</ul>
<p>ASL protocols share the same connection and channel initiation and tear-down architecture. The methods used to do this - such as Connection.Tune - are hidden from the PAL developer and are not exposed in the PAL script language. Specifically, we hide: </p>
<ul>
<li>All Connection class methods.</li>
<li>The Channel.Open and Close methods.</li>
<li>All methods sent by the server and received by the client. Since PAL is for client-side automation, these cannot be scripted.</li>
</ul>
<h3><a name="TOC40">Content Commands</a></h3>
<p>For the purposes of explanation we will use the 'demo' protocol that is part of the ASL package.  The demo protocol defines one content class, "basic". </p>
<p>For each content class, PAL provides a command to create the content and set its properties. E.g. </p>
<pre>
<basic_content
  [ size = "bodysize"  ("1024") ]
  [ fill = "random | null | repeat" ("random") ]
  [ read = "..." ]
  [ exec = "..." ]
  [ headers = "0|(1)" ]
  [ content_type = "propertyvalue" ]
  [ content_encoding = "propertyvalue" ]
  [ message_id = "propertyvalue" ]
    >
    [ <headers>
      [ <field
            name = "fieldname"
          [ value = "fieldvalue" ]
          [ type = "string | integer"  ("string") ]
            /> ]...
    </headers> ]
  [ content text ]
</basic_content>
</pre>
<ul>
<li>The size attribute specifies the size in octets of the content buffer. Its default value is "1024".</li>
<li>The fill attribute specifies the fill mode. It can be "random", which sets the body to random data, or "null", which sets it to binary zeroes, or "repeat", which repeats the content text up to the specified size.</li>
<li>The body of the content item optionally provides a content text.  If this is set, it's reformatted as a single line of text, and used as message body.  This overrides the default fill ('random').</li>
<li>The read attribute specifies a file from which to read the content body. This is useful when you want to send test messages with a specific format.</li>
<li>The exec attribute specifies a command to run, so that the stdout of the command can be used as the content body.  The command must be the name of an executable program, on the path, with arguments as desired. The program receives the current content body as stdin, much like a web server CGI program.</li>
<li>If the headers field is set to zero, the output of the executed program is not reparsed. If one, the output is reparsed to collect message properties and headers as follows: each line specifies a header field name, followed by ":", followed by a space and a value. Field names starting with "x-table-" are stored as-is (minus the x-table- prefix) in a field table with that name. Other fields must match known content properties. Hyphens are allowed in field names, and field names are case-insensitive.  The headers are ended with a blank line. Parsed headers create a CGI-like interface for calling programs.</li>
<li>For each content property defined in the protocol (except field tables) PAL defines an attribute for the content command.</li>
<li>For field tables, PAL defines a child entity with the same name, e.g. 'headers'.  Field tables are then constructed from one or more <field> definitions.</li>
<li>After a content command, the script can access the content body size as a variables ($body_size in expressions, or body_size in assertions and conditions).</li>
</ul>
<h3><a name="TOC41">Protocol Method Commands</a></h3>
<p>A protocol method command sends a protocol method to the server.  If the method is a synchronous method, the script waits for a response from the server.  If the method is asynchronous, the script continues without waiting.  The basic syntax for protocol method commands is: </p>
<pre>
<class_method [properties...]>
    <field_table_name>
      [ <field
            name = "fieldname"
          [ value = "fieldvalue" ]
          [ type = "string | integer"  ("string") ]
            /> ]...
    </field_table_name>
</class_method>
</pre>
<p>Properties that are not specified take a default value, which is zero for numeric properties, FALSE for Boolean properties, and NULL for strings and field tables. </p>
<h3><a name="TOC42">Processing Arrived Content</a></h3>
<p>For each content class, PAL provides a command that lets you process arrived messages. Contents do not necessarily arrive in a strict synchronous order - it depends on the protocol - so this command acts as a loop, and repeats for each arrived content at the moment it is invoked. </p>
<pre>
<basic_arrived
  [ counter = "variablename" ]
    >
    [ script command ]...
</basic_arrived>
<empty>
    [ script command ]...
</empty>
</pre>
<ul>
<li>If a counter is specified, this variable is automatically set to zero when the loop starts and incremented each time the loop runs.  You can access the counter variable after the loop.</li>
<li>If there was no arrived content, the script executes the following <empty> command, if any.</li>
</ul>
<p>You can use these variables within an arrived loop: </p>
<ul>
<li>$body_size - size of content body.</li>
<li>$body_text - content body as printable text.</li>
<li>$exchange - original exchange to which content was sent.</li>
<li>$routing_key - routing key specified in content.</li>
<li>$producer_id - original producer id.</li>
</ul>
<h3><a name="TOC43">Processing Returned Content</a></h3>
<p>We process returned content in a similar way to arrived content: </p>
<pre>
<basic_returned
  [ counter = "variablename" ]
    >
    [ script command ]...
</basic_returned>
<empty>
    [ script command ]...
</empty>
</pre>
<ul>
<li>If a counter is specified, this variable is automatically set to zero when the loop starts and incremented each time the loop runs.  You can access the counter variable after the loop.</li>
<li>If there was no arrived content, the script executes the following <empty> command, if any.</li>
</ul>
<h3><a name="TOC44">Synchronous Content Processing</a></h3>
<p>PAL does not provide any asynchronous content processing. The script runs as a single-threaded procedure from start to end. Content will arrive when the script is busy, i.e. during any command that talks to the server. To process content after such commands, use the 'arrived' commands. To process content while not doing such commands, use <wait/> and then use the arrived command. </p>
<h2><a name="TOC45">PAL Variables</a></h2>
<p>PAL uses the convention '$name' to allow variable substitution.  This is allowed in: </p>
<ul>
<li>The body of <echo> and <abort> commands.</li>
<li>All attributes except variablenames.</li>
</ul>
<p>PAL defines all connection and session properties as variables.  The API documentation for the protocol you are using will list these.  For the demo protocol they are: </p>
<ul>
<li>Connection properties:</li>
</ul>
<pre>
$channel_max
$class_id
$context_key
$frame_max
$heartbeat
$method_id
$reply_code
$reply_text
$server_copyright
$server_information
$server_platform
$server_product
$server_version
$version_major
$version_minor
</pre>
<ul>
<li>Session properties:</li>
</ul>
<pre>
$active
$class_id
$consumer_count
$routing_key
$exchange
$message_count
$method_id
$queue
$reply_code
$reply_text
$ticket
</pre>
<p>Note that the standard ASL technique for returning values from protocol methods is via the session properties. Thus the variable 'message_count' holds the number of messages after a queue.browse request and a queue.browse-ok response. </p>
<p>You should avoid using your own variables that conflict with the standard connection and session variables. </p>
<p>PAL defines these built-in variables: </p>
<ul>
<li>$script - name of current PAL script.</li>
<li>$connection - 1 if the connection is alive, else 0.</li>
<li>$session - 1 if the session is alive, else 0.</li>
<li>$random - a random integer in the range 0..32767, when used as an insertion value, produces a 4-digit hex string.</li>
<li>$body_size - the body size of the last content to be created, arrived, or returned.</li>
</ul>
<p>PAL resolves a variable reference in this order: </p>
<ol>
<li>First, in-built variables.</li>
<li>Content properties, inside an arrived/returned loop.</li>
<li>Session properties.</li>
<li>Connection properties.</li>
<li>Script variables and counters.</li>
</ol>
<p>Here is a sample script that demonstrates various ways of using variables: </p>
<pre>
<?xml?>
<pal
    name = "symbols"
    script = "demo_pal_gen"
    target = "stdc"
    >
    <set name = "expect_major"   value = "9" />
    <set name = "exchange_class" value = "fanout" />
    <set name = "scope"          value = "test" />
    <set name = "queue"          value = "$scope\\-queue" />
    <set name = "exchange"       value = "$scope\\-exchange" />
    <set name = "times"          value = "100" />
    <set name = "size"           value = "64000" />
    <session
        queue    = "$queue"
        exchange = "$exchange"
        scope    = "$scope">
        <echo>Connected to $server_product/$server_version - $server_platform</echo>
        <assert name = "version_major" value = "$expect_major" />
        <exchange_declare class = "$exchange_class" />
        <queue_declare />
        <queue_bind />
        <repeat times = "$times" counter = "id">
          <basic_content size = "$size" content_type = "text/html" message_id = "id-$id" />
          <basic_publish routing_key = "$queue" />
        </repeat>
        <repeat>
            <basic_browse />
            <basic_returned>
                <echo>Returned: $message_id</echo>
            </basic_returned>
            <basic_arrived>
                <inc name = "count" />
                <echo>Arrived: $message_id</echo>
            </basic_arrived>
            <empty>
                <break/>
            </empty>
        </repeat>
        <echo>Total number of messages exchanged: $count</echo>
    </session>
</pal>
</pre>
<h1><a name="TOC46">PAL Implementations</a></h1>
<h2><a name="TOC47">The StdC PAL Implementation</a></h2>
<h3><a name="TOC48">Command-Line Arguments</a></h3>
<p>The standard C implementation creates a command-line program that accepts these arguments: </p>
<pre>
Syntax: program [options...]
Options:
  -s server        Server:port to connect to (localhost)
  -t level         Set trace level (default = 0)
                   0=none, 1=low, 2=medium, 3=high
  -r count         Repeat script count times, 0=forever (1)
  -c               Clock the script (0)
  -a               Animate: show script commands
  -e               Execute in single-step mode (0)
  -q               Quiet mode: no messages
  -v               Show version information
  -h               Show summary of command-line options
The order of arguments is not important. Switches and filenames
are case sensitive. See documentation for detailed information.
</pre>
<h3><a name="TOC49">Performance Measurements</a></h3>
<p>The -c option clocks the script and produces performance measurement output.  Here is an example of a simple stress test script: </p>
<pre>
<?xml?>
<pal
    name = "stress"
    script = "demo_pal_gen"
    >
    This script sends a large number of messages to a queue and then
    reads them back.  The number of messages can be specified on the
    command-line.
    <!-- fails on win32, see FOR-6
    <server name = "demo_srv" where = ".." />
    -->
    <session scope = "default" exchange = "myexchange" queue = "myqueue" >
        <set name = "number-of-messages" cmdline = "N" value = "1000" />
        <set name = "message-size" cmdline = "S" value = "1000" />
        <exchange_declare type = "fanout" />
        <queue_declare />
        <queue_bind />
        <repeat times = "$number-of-messages" counter = "index" progress = "100">
            <basic_content size = "$message-size" message_id = "id-$index" />
            <basic_publish routing_key = "myqueue" />
        </repeat>
        <while name = "arrived" test = "lt" value = "$number-of-messages" progress = "100">
            <basic_get />
            <basic_arrived>
                <inc name = "arrived" />
            </basic_arrived>
        </while>
    </session>
</pal>
</pre>
<p>Which produces this output (the figures are obviously just an example): </p>
<pre>
...........
...........
16:41:26: I: elapsed time:781 msecs
16:41:26: I: outgoing messages:1000 (976 Kbytes)
16:41:26: I: incoming messages:1000 (976 Kbytes)
16:41:26: I: total messages:2000 (1952 Kbytes) average:2560/sec (2499 Kbytes/sec)
16:41:26: I: message latency min=280 max=410 mean=331 dev=37 msecs
</pre>
<h2><a name="TOC50">Other Implementations</a></h2>
<p>There are no other implementations of PAL at present. </p>
</td>
      </tr>
      <tr>
        <td valign="bottom" class="footer">iMatix Corporation <amq@imatix.com> - Copyright (c) 2004-2009 iMatix Corporation</td>
      </tr>
      </table>
    </td>
  </tr>
</table>

</body>
</html>






