#
#   xnf_produce.gsl - Generate a language preprocessor and/or parser
#                     from a parsed language described in XNF.
#
#   Copyright (c) 1996-2009 iMatix Corporation
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
# 
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
# 
#   For information on alternative licensing for OEMs, please contact
#   iMatix Corporation.
#
#   produce_preproc (xnf, filename)
#   produce_inherit (xnf, filename)
#   produce_parse   (xnf, filename)
#   produce_codegen (xnf, filename)
#   produce_gurudoc (xnf, filename)
#   produce_wrap    (xnf, filename)
#
.include "license.gsl"

#########################   XNF PRODUCE PREPROC   ###########################

function produce_preproc (xnf, filename)
    output my.filename
    produce (my.xnf, "preproc")
    close
endfunction


###########################   XNF PRODUCE PARSE   ############################

function produce_parse (xnf, filename)
    output my.filename
    produce (my.xnf, "parse")
    close
endfunction


#########################   XNF PRODUCE INHERIT   ###########################

function produce_inherit (xnf, filename)
    output my.filename
    produce (my.xnf, "inherit")
    produce_perform_inherit (my.xnf)
    close
endfunction


#########################   XNF PRODUCE PRODUCE   ###########################

function produce_codegen (xnf, filename)
    output my.filename
    produce (my.xnf, "codegen")
    close
endfunction


###############################   XNF PRODUCE   ##############################

function produce (xnf, phase)
    scope my.xnf
        >#   '$(my.phase:neat)' engine for $(xnf.name:)
        >#
        >#   Generated by iMatix GSL/4
        if defined (copyright)
            >#   $(copyright:)
        endif
        $(license:lower)_license ("#")
        >#
        #   Output "before" xnf rule code
        for rule where 0.phase = my.phase & 0.when ?= "before"
            >$(string.trim (rule.?''))
        endfor

        for xnf.entity
            produce_entity (entity, my.phase)
        endfor
        >
        
        #   Output "after" xnf rule code
        for rule where 0.phase = my.phase & 0.when ?= "after"
            >$(string.trim (rule.?''))
        endfor

        #   If the XNF file defines or needs an error handler, output it
        if count (xnf.errorhandler, count.when = my.phase)
            for xnf.errorhandler where when = my.phase
                >$(errorhandler.)
            endfor
        else
            >
            >function $(my.phase)_error (message)
            >    echo (my.message)
            >    global.errno = 1
            >endfunction
        endif
    endscope
endfunction

function produce_entity (entity, phase)
    my.top = xnf->entity
    >
    >function $(my.phase)_$(entity.name:c) ([$(entity.name)])
    >    my.entity = my.[$(entity.name)]
    
    #   Set some defaults
    if my.phase = "preproc"
        >    my.[$(entity.name)]._entity = "$(entity.name)"
        if entity.key ?<> ""
        >    my.[$(entity.name)]._key = my.[$(entity.name)].[$(entity.key)] ?
        endif
        >    my.entity._$(xnf->entity.name) ?= [$(xnf->entity.name)]._key ?
    endif

    >    my.location = location ("$(xnf->entity.tag)")
    >

    >    if switches.trace ? 0 | switches.trace_$(entity.name:c) ? 0
    >       echo "<$(my.phase)_$(entity.name:c) location = \\"\$(my.location)\\""
    >    endif
    >
    
    #   Only basic stuff for 'inherit'
    if my.phase <> "inherit"

        #   Output "before" rule code
        for rule where 0.phase = my.phase & 0.when ?= "before"
            >$(string.trim (rule.?''))
        endfor
    
        #   Validate attributes
        for attr
            if my.phase = attr.phase
                if defined (attr.default)
                    >    if !defined (my.[$(entity.name)].[$(attr.name)])
                    >        my.[$(entity.name)].[$(attr.name)] = "$(attr.default:)"
                    >    endif
                endif
                if attr.required ?= 1
                    >    if !defined (my.[$(entity.name)].[$(attr.name)])
                    >        $(my.phase)_error ("Required attribute '$(attr.name)' not defined\$(my.location)")
                    >    endif
                endif
                if count (attr.restrict)
                    >    if defined (my.[$(entity.name)].[$(attr.name)])
                    verb = "if   "
                    for attr.restrict
                        >        $(verb) my.[$(entity.name)].[$(attr.name)] ?= "$(restrict.value:)"
                        verb = "elsif"
                    endfor
                    >        else
                    >            $(my.phase)_error ("Attribute '$(attr.name)' has illegal value '\$(0.[$(attr.name)]?)'\$(my.location)")
                    >        endif
                    >    endif
                endif
            endif
    
        endfor
        
    endif
    
    if my.phase = "inherit" & defined (entity->allow (name = "inherit"))
        if my.entity <> my.top          #  Not a top-level inherit
            >    #   Keep on looking for more 'inherit' children as one can bring more with it
            >    my.more = 1
            >    while my.more
            >        for my.[$(entity.name)].inherit where 0._done ? 0 = 0
            >            if !defined (inherit.condition) | gsl.exec ("\\\$(("+inherit.condition+")?0)",1)
            >                #my.source = link_target ("$(name ($(-1)))", "$(-1._entity)", "_key", name) ?
            >                my.source = link_target ("$(entity.tag)", "$(entity.name)", "_key", inherit.name) ?
            >                if !defined (my.source)
            >                    preproc_error ("$(entity.name:Neat) '\$(inherit.name)' missing\$(my.location)")
            >                else
            >                    perform_inherit_$(entity.name:c)_item (my.[$(entity.name)], my.source)
            >                endif
            >                inherit._done = 1
            >            endif
            >        else
            >            my.more = 0
            >        endfor
            >    endwhile
            >
        endif
    endif

    #   Only basic stuff for 'inherit'
    if my.phase <> "inherit"
    
        #   Output "attrs" rule code
        for rule where 0.phase = my.phase & 0.when = "attrs"
            >    $(string.trim (rule.?''))
        endfor
        
    endif
    
    #   Validate children
    #   If we have 'disconnect' set on any of the rules, we don't generate
    #   the code to process the entity body directly.  Disconnecting the body
    #   allows us to generate code for the children at a different time.
    if entity.disconnect = 0
    
        if my.phase = "parse"
            if count (allow)
                >    #    Recurse into child entities
                for allow
                    child = xnf->entity (0.name = allow.entity)
                    if (allow.occurs ?= "1" | allow.occurs ?= "1+")
                        >    if count (my.[$(entity.name)].[$(child.tag)]) < 1
                        >        $(my.phase)_error ("<$(child.tag)> required\$(my.location)")
                        >    endif
                    endif
                    if (allow.occurs ?= "1" | allow.occurs ?= "0/1")
                        >    if count (my.[$(entity.name)].[$(child.tag)]) > 1
                        >        $(my.phase)_error ("more than one <$(child.tag)> defined\$(my.location)")
                        >    endif
                    endif
                endfor
    
                verb = "if   "
                >    #    Check that all entities are valid here
                >    for my.[$(entity.name)]. where defined (name ()) as entity
                for allow
                    child = xnf->entity (0.name = allow.entity)
                    if !defined (child.tag)
                        abort "Entity $(name) must have a tag"
                    endif
                    >        $(verb) name () = "$(child.tag)"
                    verb = "elsif"
                endfor
                >        else
                >            $(my.phase)_error ("<\$(name ())> not allowed\$(my.location)")
                >        endif
                >    endfor
                >
            else
                #   No body and no allow - check entity does not have any children
                >    for my.[$(entity.name)]. where defined (name ())
                >        $(my.phase)_error ("<\$(name ())> not allowed\$(my.location)")
                >    endfor
            endif
        endif
    
        if my.phase = "codegen"
            >    for my.[$(entity.name)]. as child where defined (name ())
            for allow
                child = xnf->entity (0.name ?= allow.entity)
            >        if name (child) = "$(child.tag)"
            >           $(my.phase)_$(child.name:c) (child)
            >        endif
            endfor
            >    endfor
            >
        else
            for allow
                child = xnf->entity (0.name ?= allow.entity)
                >    for my.[$(entity.name)].[$(child.tag)] as [$(child.name)]
                >        $(my.phase)_$(child.name:c) ([$(child.name)])
                >    endfor
                >
            endfor
        endif
        
        #   Check for unique entities
        if my.phase = "parse"
            for allow
                child = xnf->entity (0.name ?= allow.entity)
                if (child.unique ? 1) & (child.key ?<> "")
                    >    my.last_key =
                    >    for my.[$(entity.name)].[$(child.tag)] as [$(child.name)] by 0.[$(child.key)] ? ""
                    >        if (0.[$(child.key)] ?<> "") & (0.[$(child.key)] ?= my.last_key)
                    >            $(my.phase)_error ("Duplicate <$(child.tag) $(child.key) = \\"\$(0.[$(child.key)])\\"/>\$(my.location)")
                    >        endif
                    >        my.last_key = 0.[$(child.key)] ? ""
                    >    endfor
                endif
            endfor
        endif

    endif #   disconnect = 0
    
    #   Validate and denormalise links
    if my.phase = "parse"
        for link
            link.entity ?= link.[from]
            link.tag    ?= xnf->entity (name = link.entity). tag
            link.field  ?= "name"
            for rule where 0.phase = my.phase & 0.when ?= "before"
                >    $(string.trim (rule.?''))
            endfor
            >    if defined (0.[$(link.[from])])
            >        my.source = link_target ("$(link.tag)", "$(link.entity)", "$(link.field)", 0.[$(link.[from])]) ?
            >        if defined (my.source)
            if link.disconnect = 0
                >            my.target = my.[$(entity.name)]
                for rule where 0.phase = my.phase & 0.when ?= "inherit"
                    >            $(string.trim (rule.?''))
                endfor
                >            perform_inherit_$(link.entity:c)_item (my.target, my.source)
            endif
            for rule where 0.phase = my.phase & 0.when ?= "after"
                >    $(string.trim (rule.?''))
            endfor
            if link.required
                >        else
                >            $(my.phase)_error ("$(link.tag:Neat) '\$(0.[$(link.[from])])' missing\$(my.location)")
            endif
            >        endif
            >    endif
        endfor link
    endif

    #   Only basic stuff for 'inherit'
    if my.phase <> "inherit"
        #   Output "links" rule code
        for rule where 0.phase = my.phase & 0.when = "links"
            >$(string.trim (rule.?''))
        endfor
        #   Output "after" rule code
        for rule where 0.phase = my.phase & 0.when ?= "after"
            >$(string.trim (rule.?''))
        endfor    
    endif

    #   Set some defaults in case they have changed
    if my.phase = "preproc"
        >    if !my.[$(entity.name)].deleted ()
        if entity.key ?<> ""
        >        my.[$(entity.name)]._key = my.[$(entity.name)].[$(entity.key)] ?
        endif
        >        my.entity._$(xnf->entity.name) ?= [$(xnf->entity.name)]._key ?
        >    endif
    endif

    >endfunction
endfunction

#########################   XNF PRODUCE INHERIT   ###########################

function produce_perform_inherit (xnf)
    scope my.xnf
        produce_inherit_top       (xnf->entity)
        produce_sort_top_inherits (xnf->entity)
        
        for xnf.entity
            produce_perform_inherit_entity (entity)
        endfor
        
        for xnf.entity where entity.inherit = "overlay"
            produce_perform_inherit_entity_item (entity)
        endfor
        >
        #   If the XNF file defines or needs an error handler, output it
        if count (xnf.errorhandler, count.when = "inherit")
            for xnf.errorhandler where when = "inherit"
                >$(errorhandler.)
            endfor
        else
            >
            >function inherit_error (message)
            >    echo (my.message)
            >    global.errno = 1
            >endfunction
        endif
    endscope
endfunction

function produce_inherit_top (top)
    >
    >function inherit_top ([$(my.top.name)])
    >    my.entity = my.[$(my.top.name)]
    >    my.location = location ("$(xnf->entity.tag)")
    >
    
    >    if switches.trace ? 0 | switches.trace_$(my.top.name:c) ? 0
    >       echo "<inherit_top location = \\"\$(my.location)\\""
    >    endif
    >
    
    >    for my.[$(my.top.name)].inherit
    >        if !defined (inherit.condition) | gsl.exec ("\\\$(("+inherit.condition+")?0)",1)
    >            if switches.trace ? 0 | switches.trace_$(my.top.name:c) ? 0
    >                echo "Loading \$(name)"
    >            endif
    >            my.inherit_file = xml.load_file (name + ".$(my.top.name)") ? abort_xml_error ()
    >            my.inherit_file._filename ?= name
    >            if my.inherit_file.multiple ? 0 > 0 | !defined (global.top.have_inherit_\$(inherit.name))
    >                for inherit.option
    >                    copy option to my.inherit_file
    >                endfor
    >                scope my.inherit_file as $(my.top.name)
    >                    preproc_$(my.top.name:c) (my.inherit_file)
    >                    inherit_top (my.inherit_file)
    >                endscope
    >                global.top.have_inherit_\$(inherit.name) = 1
    >            
    >                move my.inherit_file to global.inherit
    >            endif
    >        endif
    >    endfor
    >endfunction
    >
endfunction


function produce_sort_top_inherits (top)
    >function sort_top_inherits ()
    >    my.location = location ("$(xnf->entity.tag)")
    >
    >    my.sorted = xml.new ("sorted")
    >    for global.inherit.$(my.top.tag)
    >        my.[before] =
    >        my.[after]  =
    >        if switches.trace ? 0 | switches.trace_$(my.top.name:c) ? 0
    >            echo "Inserting \$($(my.top.tag)._key)"
    >        endif
    >        for my.sorted.$(my.top.tag) as sorted
    >
    >            if ((sorted.role    = class.[before]) ? 0) \
    >             | ((sorted.[after] = class.role)     ? 0)
    >                if switches.trace ? 0 | switches.trace_$(my.top.name:c) ? 0
    >                    echo "    before: \$(sorted.name)"
    >                endif
    >                my.[before] ?= sorted
    >            endif
    >            if ((sorted.role    = class.[after]) ? 0) \
    >             | ((sorted.[before] = class.role)     ? 0)
    >                if switches.trace ? 0 | switches.trace_$(my.top.name:c) ? 0
    >                    echo "    after: \$(sorted.name)"
    >                endif
    >                if defined (my.[before])
    >                    preproc_error ("Incoherent inherit order\$(my.location)")
    >                    last
    >                endif
    >                my.[after] = sorted
    >            endif
    >        endfor
    >            
    >        if defined (my.[before])
    >            move $(my.top.tag) before my.[before]
    >        elsif defined (my.[after])
    >            move $(my.top.tag) after my.[after]
    >        else
    >            my.any = my.sorted->?
    >            if defined (my.any)
    >                move $(my.top.tag) before my.any
    >            else
    >                move $(my.top.tag) to my.sorted
    >            endif
    >        endif
    >    endfor
    >    
    >    for my.sorted.$(my.top.tag)
    >        if switches.trace ? 0 | switches.trace_$(my.top.name:c) ? 0
    >            echo "Inheriting \$($(my.top.tag).name)"
    >        endif
    >        perform_inherit_$(my.top.name)_item (global.top, $(my.top.tag))
    >    endfor
    >
    >endfunction
    >
endfunction

function produce_perform_inherit_entity (entity)
    scope my.entity
        >function perform_inherit_$(entity.name:c) (target, source, inherit, sequence)
        
        >    if switches.trace ? 0 | switches.trace_$(entity.name:c) ? 0
        >       my.location = location ("$(xnf->entity.tag)")
        >       echo "<inherit_$(entity.name:c) location = \\"\$(my.location)\\""
        >    endif
        >
        
        >    my.inherit ?= "$(entity.inherit)"
        
        >    my.insert = my.target->[$(entity.tag)] ?
        >    for my.source.[$(entity.tag)] as [$(entity.name)]
        if defined (entity->attr (name = "export"))
            >        if [$(name)].export ? "default" <> "none"
        endif
        if key ?<> ""
            >        my.existing = my.target->[$(entity.tag)] (0.[$(key)] ?= -1.[$(key)]) ?
        else
            >        if my.inherit = "overlay"
            >            my.existing = my.target->[$(entity.tag)] ?
            >        endif
        endif
        
        #   Output "before" rule code
        for rule where 0.phase = "inherit" & 0.when = "before"
            >        $(string.trim (rule.?''))
        endfor

        >        if my.inherit = "overlay" & defined (my.existing)
        >            perform_inherit_$(name:c)_item (my.existing, [$(entity.name)])
        >        elsif my.inherit <> "none" & !defined (my.existing)
        >            if (my.sequence ? "$(entity.sequence)") = "before"
        if defined (entity->attr (name = "export"))
            >                if defined (my.insert) & [$(name)].export ? "default" <> "after"
        else
            >                if defined (my.insert)
        endif
        >                    copy [$(name)] before my.insert
        >                else
        >                    copy [$(name)] to my.target
        >                endif
        >            else
        if defined (entity->attr (name = "export"))
            >                if defined (my.insert) & [$(name)].export ? "default" = "before"
            >                    copy [$(name)] before my.insert
            >                else
            >                    copy [$(name)] to my.target
            >                endif
        else
            >                copy [$(name)] to my.target
        endif
        >            endif
        >        endif
        if defined (entity->attr (name = "export"))
            >        endif
        endif
        
        #   Output "after" rule code
        for rule where 0.phase = "inherit" & 0.when = "after"
            >        $(string.trim (rule.?''))
        endfor
        
        >    endfor
        
        >endfunction perform_inherit_$(entity.name:c)
        >
    endscope
endfunction

function produce_perform_inherit_entity_item (entity)
    scope my.entity
        >function perform_inherit_$(name:c)_item (target, source)
        
        >    if switches.trace ? 0 | switches.trace_$(entity.name:c) ? 0
        >       my.location = location ("$(xnf->entity.tag)")
        >       echo "<inherit_$(entity.name:c)_item location = \\"\$(my.location)\\""
        >    endif
        >
        
        >    if my.target.inherit ? "default" <> "none"

        >        my.target._entity ?= my.source._entity ?
        >        my.target._key    ?= my.source._key    ?
        for entity.attr where inherit = 1
            >        my.target.[$(name)] ?= my.source.[$(name)] ?
        endfor

        for entity.allow
            >        perform_inherit_$(.entity:c) (my.target, my.source, \
            >$(defined(allow.inherit)??'"$(allow.inherit)"'?), \
            >$(defined(allow.sequence)??'"$(allow.sequence)"'?))
        endfor
        >        if defined (my.source.)
        >            my.target. = my.source. + (my.target. ? "")
        >        endif

        >    endif

        >endfunction
        >
    endscope
endfunction

##########################   XNF PRODUCE GURUDOC   ###########################

function produce_gurudoc (xnf, filename)
    scope my.xnf
        output my.filename
        >$(xnf.:justify,block,no                                                 )
        >
        >Summary of language
        >===================
        >
        >This summary shows the hierarchy of elements you can use, with the
        >required and optional attributes for each element.  The XML entity and
        >attribute names are case-sensitive and we use only lower-case names.
        >
        #   We document the root entity using a recursive function
        for xnf.entity
            entity.processed = 0
        endfor
        scope xnf->entity
            xnf_doc_entity ("summary")
        endscope
        >
        >Detailed specifications
        >=======================
        >
        >All child entities are optional and can occur zero or more times without
        >any specific limits unless otherwise specified.  The same tag may occur
        >at different levels with different meanings, and in such cases will be
        >detailed more than once here.
        for xnf.entity
            entity.processed = 0
        endfor
        scope xnf->entity
            xnf_doc_entity ("detail")
        endscope
        close
    endscope
endfunction


function xnf_doc_entity (type)
    root.indent = (root.indent?0) + 1
    if my.type = "summary"
        xnf_doc_summary ("open")
    elsif my.type = "detail" & processed = 0
        xnf_doc_detail ()
    endif

    #   Process flag: 0 = virgin, 1 = in progress, 2 = completed
    if processed = 0
        entity.processed = 1
        for allow
            for xnf.entity where entity.name = allow.entity 
                xnf_doc_entity (my.type)
            endfor
        endfor
    endif
    if my.type = "summary"
        xnf_doc_summary ("close")
    endif
    entity.processed = 2
    root.indent = (root.indent?0) - 1
endfunction


function xnf_doc_summary (what)
    if my.what = "open"
        > $(" " * 3 * root.indent)<$(entity.tag)\
        if processed = 2
            > .../>
        else
            my.text = ""
            for attr by 1 - (required?0)
                if string.length (my.text) > 75
                    >$(my.text:)
                    my.text = (" " * 3 * root.indent) + "     "
                endif
                if required ?= 1
                    my.text += " $(attr.name)"
                else
                    my.text += " [$(attr.name)]"
                endif
            endfor
            if count (allow)
                >$(my.text:)>
            else
                >$(my.text:)/>
            endif
        endif
    else
        if processed < 2 & count (allow)
            > $(" " * 3 * root.indent)</$(entity.tag)>
        endif
    endif
endfunction

function xnf_doc_detail ()
    >
    >The '$(entity.name)' item
    >$('-' * (string.length (entity.name) + 11))
    >
    >$(entity.?:justify,block,no                                               )
    >
    if count (attr) = 0
        >    <$(tag:)>
    else
        >    <$(tag:)
        for attr by 1 - (required?0)
            if required ?= 1
            >        $(attr.name) = "\
            else
            >      [ $(attr.name) = "\
            endif
            if count (restrict)
                my.text = ""
                for restrict
                    if string.length (my.text) > 75
                        >$(my.text)
                        my.text = "            " + string.length (attr.name)
                    endif
                    if item () > 1
                        my.text += " | "
                    endif
                    my.text += "$(value:)"
                endfor
                >$(my.text:)"\
            else
                >..."\
            endif
            if default ?<> ""
                >  ("$(default:)")\
            endif
            if required ?= 1
                >
            else
                > ]
            endif
        endfor
        if count (allow) = 0
            >        />
        else
            >        >
        endif
    endif

    for allow
        allow.occurs ?= "0+"
        for xnf.entity where entity.name = allow.entity
            if    occurs = "1"
                >        <$(entity.tag:)>, required
            elsif occurs = "1+"
                >        <$(entity.tag:)>, 1 or more
            elsif occurs = "0+"
                >        <$(entity.tag:)>
            elsif occurs = "0/1"
                >        <$(entity.tag:)>, optional
            endif
        endfor
    endfor
    if count (allow) > 0
        >    </$(tag)>
    endif
    >
    totattr = count (entity.attr)
    if totattr = 1
        >The $(entity.name) item has this single attribute:
    elsif totattr > 1
        >The $(entity.name) item can have these attributes:
    endif
    >
    for attr
        >$(attr.name):
        text = string.trim (attr.?"")
        for entity.link where [from] = attr.name
            text += " Defines a link to the '$(link.[to]?link.[from]:)' item
                     with the corresponding '$(link.field?'name':)' attribute."
        endfor
        if required ?= 1
            text += " The $(attr.name:) attribute is required."
        else
            text += " The $(attr.name:) attribute is optional."
        endif
        if defined (default)
            text += " Its default value is \"$(default:)\"."
        endif
        if count (restrict)
            text += " It can take one of the following values:"
            >    $(text:justify,block,no                                                 )
            >
            >Value: Meaning:
            for restrict
                >$(string.convch (value, " ", "_")): $(string.justify (restrict.?"", 0, ""):)
            endfor
            >
        else
            >    $(text:justify,block,no                                                 )
            >
        endif
    endfor
endfunction


############################   XNF PRODUCE WRAP    ############################

function produce_wrap (xnf, filename)
  scope my.xnf
    my.top = xnf->entity
    output my.filename
    if !defined (switches.quiet)
        echo "Generating $(filename) generator..."
    endif
    >.template 0
    >#   Command-line code generator for $(xnf.name:).
    >#   Generated by iMatix GSL/4
    if defined (copyright)
        >#   $(copyright:)
    endif
    $(license:lower)_license ("#")
    >#
    >
    >function link_target (tag, entity, field, value)
    >    my.scopenum = 1
    >    while \$(my.scopenum) <> global.top
    >        my.scopenum -= 1
    >        my.target = \$(my.scopenum)->\$(my.tag) ((0._entity ?= my.entity | (!defined (my.entity))) & 0.\$(my.field) ?= my.value) ?
    >        if defined (my.target)
    >            return my.target
    >        endif
    >    endwhile
    >endfunction
    >
    >function location (top)
    >    my.scopenum = 0
    >    my.location = ""
    >    while name (\$(my.scopenum)) <> my.top
    >        my.location += " in \$(name(\$(my.scopenum))) '\$(\$(my.scopenum)._key?item(\$(my.scopenum))?)'"
    >        my.scopenum -= 1
    >    endwhile
    >    my.location += " in \$(name(\$(my.scopenum))) '\$(\$(my.scopenum)._key?item(\$(my.scopenum))?)'"
    >    return my.location
    >endfunction
    >
    >function expand (gsl_script)
    >    if defined (my.gsl_script)
    >        my.result = gsl.exec (my.gsl_script, 1) ?
    >        if ! defined (my.result)
    >            abort "Error in GSL script:\n\$(my.gsl_script)"
    >        endif
    >    endif
    >    return my.result
    >endfunction
    >
    >function abort_xml_error ()
    >   abort xml.error
    >endfunction
    >
    >function delete_abstract (entity)
    >    if my.entity.abstract ?= 1
    >        my.entity.delete ()
    >    else
    >        for my.entity. as child where defined (name (child))
    >            delete_abstract (child)
    >        endfor
    >    endif
    >endfunction
    >
    >function define_throughout (parent, option)
    >    my.parent.\$(my.option.name) ?= gsl.exec (my.option.value, 1)
    >    for my.parent. as child where defined (name (child))
    >        define_throughout (child, my.option)
    >    endfor
    >endfunction
    #   Output "before" rule code
    for rule where 0.phase = "wrap" & 0.when ?= "before"
        >
        >$(string.trim (rule.?''))
    endfor
    >
    >include "license.gsl"
    for xnf.produce where type = "preproc" | type = "inherit" | type = "parse" | type = "codegen"
        >include "$(filename)"
    endfor
    >
    >ignorecase = 0
    >global.errno    = 0
    >global.top      =  $(my.top.tag)
    >global.top_tag  = "$(my.top.tag)"
    >global.top_name = "$(my.top.name)"
    >global.inherit  = xml.new ("inherit")
    >
    >scope global.top as [$(my.top.name)]
    >
    if entity.key ?<> ""
        >    [$(my.top.name)].[$(entity.key)] ?= filename
    endif
    >
    if defined (xnf-> produce (type = "preproc"))
        >    if global.errno = 0
        >        preproc_$(my.top.name:c) ([$(my.top.name)])
        >    endif
    endif
    if defined (xnf->produce (type = "inherit"))
        >    if global.errno = 0
        >        inherit_top ([$(my.top.name)])
        >        sort_top_inherits ()
        >        inherit_$(my.top.name:c) ([$(my.top.name)])
        >    endif
    endif
    if defined (xnf->produce (type = "parse"))
        >    if global.errno = 0
        >        parse_$(my.top.name:c) ([$(my.top.name)])
        >    endif
    endif

    >    #   We can force the $(my.top.name) to non-abstract via the cmdline
    >    if switches.abstract ?= 0
    >        $(my.top.name).abstract = 0
    >    endif
    >
    >    #   Walk the entity tree and delete all abstract entities
    >    delete_abstract ([$(my.top.name)])
    >    if ![$(my.top.name)].deleted ()
    >        if switches.debug ?= 1
    >            save $(my.top.tag)
    >        endif

    #   Output "after" rule code
    for rule where 0.phase = "wrap" & 0.when ?= "after"
        >
        >        $(string.trim (rule.?''))
    endfor

    >    else
    >        echo "WARNING: Abstract $(my.top.tag) - No code generated."
    >    endif
    >endscope
    >.endtemplate
  endscope xnf
endfunction
