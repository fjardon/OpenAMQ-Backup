#   'Parse' engine for smt
#
#   Generated by iMatix GSL/4
#   
#   Copyright (c) 1996-2009 iMatix Corporation
#   
#   This file is licensed under the GPL as follows:
#   
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
#   
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#   
#   For information on alternative licensing for OEMs, please contact
#   iMatix Corporation.
#

function parse_smt ([smt])
    my.entity = my.[smt]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_smt ? 0
       echo "<parse_smt location = \"$(my.location)\""
    endif

    if !defined (my.[smt].[abstract])
        my.[smt].[abstract] = "0"
    endif
    if defined (my.[smt].[abstract])
        if    my.[smt].[abstract] ?= "0"
        elsif my.[smt].[abstract] ?= "1"
        else
            parse_error ("Attribute 'abstract' has illegal value '$(0.[abstract]?)'$(my.location)")
        endif
    endif
    if !defined (my.[smt].[license])
        my.[smt].[license] = "gpl"
    endif
    if defined (my.[smt].[license])
        if    my.[smt].[license] ?= "bsd"
        elsif my.[smt].[license] ?= "gpl"
        else
            parse_error ("Attribute 'license' has illegal value '$(0.[license]?)'$(my.location)")
        endif
    endif
    if !defined (my.[smt].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[smt].[script])
        parse_error ("Required attribute 'script' not defined$(my.location)")
    endif
    if defined (my.[smt].[script])
        if    my.[smt].[script] ?= "smt_gen.gsl"
        else
            parse_error ("Attribute 'script' has illegal value '$(0.[script]?)'$(my.location)")
        endif
    endif
    if !defined (my.[smt].[target])
        my.[smt].[target] = "$(switches.target?'stdc':)"
    endif
    if defined (my.[smt].[target])
        if    my.[smt].[target] ?= "stdc"
        elsif my.[smt].[target] ?= "doc"
        else
            parse_error ("Attribute 'target' has illegal value '$(0.[target]?)'$(my.location)")
        endif
    endif
    if !defined (my.[smt].[animate])
        my.[smt].[animate] = "0"
    endif
    if defined (my.[smt].[animate])
        if    my.[smt].[animate] ?= "0"
        elsif my.[smt].[animate] ?= "1"
        else
            parse_error ("Attribute 'animate' has illegal value '$(0.[animate]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[smt]. where defined (name ()) as entity
        if    name () = "option"
        elsif name () = "inherit"
        elsif name () = "include"
        elsif name () = "import"
        elsif name () = "private"
        elsif name () = "public"
        elsif name () = "context"
        elsif name () = "handler"
        elsif name () = "state"
        elsif name () = "thread"
        elsif name () = "event"
        elsif name () = "action"
        elsif name () = "catch"
        elsif name () = "method"
        elsif name () = "message"
        elsif name () = "actionlist"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[smt].[option] as [option]
        parse_option ([option])
    endfor

    for my.[smt].[inherit] as [inherit]
        parse_inherit ([inherit])
    endfor

    for my.[smt].[include] as [include]
        parse_include ([include])
    endfor

    for my.[smt].[import] as [import]
        parse_import ([import])
    endfor

    for my.[smt].[private] as [private]
        parse_private ([private])
    endfor

    for my.[smt].[public] as [public]
        parse_public ([public])
    endfor

    for my.[smt].[context] as [agent context]
        parse_agent_context ([agent context])
    endfor

    for my.[smt].[handler] as [agent handler]
        parse_agent_handler ([agent handler])
    endfor

    for my.[smt].[state] as [agent state]
        parse_agent_state ([agent state])
    endfor

    for my.[smt].[thread] as [thread]
        parse_thread ([thread])
    endfor

    for my.[smt].[event] as [agent event]
        parse_agent_event ([agent event])
    endfor

    for my.[smt].[action] as [agent action]
        parse_agent_action ([agent action])
    endfor

    for my.[smt].[catch] as [catch]
        parse_catch ([catch])
    endfor

    for my.[smt].[method] as [method]
        parse_method ([method])
    endfor

    for my.[smt].[message] as [message]
        parse_message ([message])
    endfor

    for my.[smt].[actionlist] as [actionlist]
        parse_actionlist ([actionlist])
    endfor

    my.last_key =
    for my.[smt].[option] as [option] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <option name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[smt].[import] as [import] by 0.[class] ? ""
        if (0.[class] ?<> "") & (0.[class] ?= my.last_key)
            parse_error ("Duplicate <import class = \"$(0.[class])\"/>$(my.location)")
        endif
        my.last_key = 0.[class] ? ""
    endfor
    my.last_key =
    for my.[smt].[context] as [agent context] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <context name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[smt].[handler] as [agent handler] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <handler name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[smt].[state] as [agent state] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <state name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[smt].[thread] as [thread] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <thread name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[smt].[event] as [agent event] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <event name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[smt].[action] as [agent action] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <action name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[smt].[catch] as [catch] by 0.[error] ? ""
        if (0.[error] ?<> "") & (0.[error] ?= my.last_key)
            parse_error ("Duplicate <catch error = \"$(0.[error])\"/>$(my.location)")
        endif
        my.last_key = 0.[error] ? ""
    endfor
    my.last_key =
    for my.[smt].[method] as [method] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <method name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[smt].[message] as [message] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <message name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
        for thread
            #   Check for unused states and delete unreached states        
            for state where state.reached ? 0 = 0
                if state.inherited ? 0 = 0
                    echo "WARNING: Thread: $(thread.name:) State: $(state.name:) unused"
                endif
                state.delete ()
            endfor
            
            /*   Sort states so code is generated in the correct order.          */
            sort state by 0.place
        endfor
        
        #   Parse places
        for thread
            for agent.place where place.thread = thread.name
                if place.nextstate <> ""
                    my.nextstate = thread-> state (name = place.nextstate) ?
                    if ! defined (my.nextstate)
                        parse_error ("Unknown state: '$(place.nextstate)'$(my.location)")
                    else
                        place.nextplace = my.nextstate.place
                    endif
                endif
            endfor
        endfor
    
            #   Check for undefined actions
        for action where ! defined (action->)
            echo "WARNING: Undefined action: $(action.name:)$(my.location)"
        endfor
        
        #   Last parse through actions - check for unused actions and renumber
        #   only real (not pseudo-) actions.
        my.last_final_id = 0
        for action
            if action.used ? 0 = 0
                echo "WARNING: Unused action: $(action.name:)$(my.location)"
            endif
            if ! defined (action-> action)    # Not a pseudo-action
                my.last_final_id += 1
                action.final_id = my.last_final_id
            endif
        endfor
endfunction

function parse_include ([include])
    my.entity = my.[include]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_include ? 0
       echo "<parse_include location = \"$(my.location)\""
    endif

    if !defined (my.[include].[filename])
        parse_error ("Required attribute 'filename' not defined$(my.location)")
    endif
    if !defined (my.[include].[required])
        my.[include].[required] = "1"
    endif
    if defined (my.[include].[required])
        if    my.[include].[required] ?= "0"
        elsif my.[include].[required] ?= "1"
        else
            parse_error ("Attribute 'required' has illegal value '$(0.[required]?)'$(my.location)")
        endif
    endif
    for my.[include]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_catch ([catch])
    my.entity = my.[catch]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_catch ? 0
       echo "<parse_catch location = \"$(my.location)\""
    endif

    if !defined (my.[catch].[event])
        parse_error ("Required attribute 'event' not defined$(my.location)")
    endif
    for my.[catch]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
    if defined (0.[event])
        my.source = link_target ("event", "agent event", "name", 0.[event]) ?
        if defined (my.source)
        else
            parse_error ("Event '$(0.[event])' missing$(my.location)")
        endif
    endif
endfunction

function parse_private ([private])
    my.entity = my.[private]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_private ? 0
       echo "<parse_private location = \"$(my.location)\""
    endif

    if defined (my.[private].[name])
        if    my.[private].[name] ?= "types"
        elsif my.[private].[name] ?= "data"
        elsif my.[private].[name] ?= "functions"
        else
            parse_error ("Attribute 'name' has illegal value '$(0.[name]?)'$(my.location)")
        endif
    endif
    for my.[private]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_public ([public])
    my.entity = my.[public]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_public ? 0
       echo "<parse_public location = \"$(my.location)\""
    endif

    if defined (my.[public].[name])
        if    my.[public].[name] ?= "include"
        elsif my.[public].[name] ?= "types"
        elsif my.[public].[name] ?= "functions"
        else
            parse_error ("Attribute 'name' has illegal value '$(0.[name]?)'$(my.location)")
        endif
    endif
    for my.[public]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_import ([import])
    my.entity = my.[import]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_import ? 0
       echo "<parse_import location = \"$(my.location)\""
    endif

    if !defined (my.[import].[class])
        parse_error ("Required attribute 'class' not defined$(my.location)")
    endif
    for my.[import]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
        if defined (condition) & ! gsl.exec ("\$(("+condition+")?0)",1)
            my.entity.delete ()
        endif
endfunction

function parse_agent_context ([agent context])
    my.entity = my.[agent context]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_agent_context ? 0
       echo "<parse_agent_context location = \"$(my.location)\""
    endif

    if !defined (my.[agent context].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    for my.[agent context]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_agent_handler ([agent handler])
    my.entity = my.[agent handler]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_agent_handler ? 0
       echo "<parse_agent_handler location = \"$(my.location)\""
    endif

    if defined (my.[agent handler].[name])
        if    my.[agent handler].[name] ?= "agent init"
        elsif my.[agent handler].[name] ?= "agent term"
        else
            parse_error ("Attribute 'name' has illegal value '$(0.[name]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[agent handler]. where defined (name ()) as entity
        if    name () = "argument"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[agent handler].[argument] as [argument]
        parse_argument ([argument])
    endfor

    my.last_key =
    for my.[agent handler].[argument] as [argument] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <argument name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_argument ([argument])
    my.entity = my.[argument]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_argument ? 0
       echo "<parse_argument location = \"$(my.location)\""
    endif

    if !defined (my.[argument].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[argument].[type])
        parse_error ("Required attribute 'type' not defined$(my.location)")
    endif
    for my.[argument]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_agent_state ([agent state])
    my.entity = my.[agent state]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_agent_state ? 0
       echo "<parse_agent_state location = \"$(my.location)\""
    endif

    if !defined (my.[agent state].[abstract])
        my.[agent state].[abstract] = "0"
    endif
    if defined (my.[agent state].[abstract])
        if    my.[agent state].[abstract] ?= "0"
        elsif my.[agent state].[abstract] ?= "1"
        else
            parse_error ("Attribute 'abstract' has illegal value '$(0.[abstract]?)'$(my.location)")
        endif
    endif
    if !defined (my.[agent state].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[agent state]. where defined (name ()) as entity
        if    name () = "option"
        elsif name () = "inherit"
        elsif name () = "handler"
        elsif name () = "event"
        elsif name () = "default"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[agent state].[option] as [option]
        parse_option ([option])
    endfor

    for my.[agent state].[inherit] as [inherit]
        parse_inherit ([inherit])
    endfor

    for my.[agent state].[handler] as [state handler]
        parse_state_handler ([state handler])
    endfor

    for my.[agent state].[event] as [agent state event]
        parse_agent_state_event ([agent state event])
    endfor

    for my.[agent state].[default] as [other]
        parse_other ([other])
    endfor

    my.last_key =
    for my.[agent state].[option] as [option] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <option name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[agent state].[handler] as [state handler] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <handler name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[agent state].[event] as [agent state event] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <event name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_state_handler ([state handler])
    my.entity = my.[state handler]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_state_handler ? 0
       echo "<parse_state_handler location = \"$(my.location)\""
    endif

    if !defined (my.[state handler].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if defined (my.[state handler].[name])
        if    my.[state handler].[name] ?= "before state"
        else
            parse_error ("Attribute 'name' has illegal value '$(0.[name]?)'$(my.location)")
        endif
    endif
    for my.[state handler]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_state_action ([state action])
    my.entity = my.[state action]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_state_action ? 0
       echo "<parse_state_action location = \"$(my.location)\""
    endif

endfunction

function parse_agent_state_event ([agent state event])
    my.entity = my.[agent state event]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_agent_state_event ? 0
       echo "<parse_agent_state_event location = \"$(my.location)\""
    endif

    if !defined (my.[agent state event].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[agent state event]. where defined (name ()) as entity
        if    name () = "action"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[agent state event].[action] as [agent state action]
        parse_agent_state_action ([agent state action])
    endfor

endfunction

function parse_agent_action ([agent action])
    my.entity = my.[agent action]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_agent_action ? 0
       echo "<parse_agent_action location = \"$(my.location)\""
    endif

        for my.[agent action]. as child where defined (name ())
            if name () = "call" | name () = "return"
                parse_$(name()) (child)
            endif
        endfor
endfunction

function parse_agent_state_action ([agent state action])
    my.entity = my.[agent state action]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_agent_state_action ? 0
       echo "<parse_agent_state_action location = \"$(my.location)\""
    endif

endfunction

function parse_call ([call])
    my.entity = my.[call]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_call ? 0
       echo "<parse_call location = \"$(my.location)\""
    endif

        #   We don't know which thread this call is in, so try all threads
        my.action_id = -1.id
        for agent.thread where defined (thread-> action (0.id = my.action_id))
            my.state = thread-> state (0.name = my.call.state) ?
            if defined (my.state)
                if (my.state.reached ? 0) = 0
                    scope my.state as [thread state]
                        parse_thread_state ([thread state])
                    endscope
                endif
            endif
        endfor
    if !defined (my.[call].[state])
        parse_error ("Required attribute 'state' not defined$(my.location)")
    endif
    for my.[call]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
    if defined (0.[state])
        my.source = link_target ("state", "agent state", "name", 0.[state]) ?
        if defined (my.source)
        else
            parse_error ("State '$(0.[state])' missing$(my.location)")
        endif
    endif
    if defined (0.[event])
        my.source = link_target ("event", "agent event", "name", 0.[event]) ?
        if defined (my.source)
        else
            parse_error ("Event '$(0.[event])' missing$(my.location)")
        endif
    endif
        for agent.thread where defined (thread-> action (0.id = my.action_id))
            my.callplace = my.call-> callplace (0.thread = thread.name) ?
            if ! defined (my.callplace)
                my.callplace = my.call.new ("callplace")
                my.callplace.thread = thread.name
            endif
        endfor

        if defined (my.call.event)
            my.event = agent-> event (0.name = my.call.event)
            my.call.event_id = my.event.id
        endif
endfunction

function parse_return ([return])
    my.entity = my.[return]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_return ? 0
       echo "<parse_return location = \"$(my.location)\""
    endif

    for my.[return]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_other ([other])
    my.entity = my.[other]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_other ? 0
       echo "<parse_other location = \"$(my.location)\""
    endif

    my.[other].nextstate ?= [thread state].name
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[other]. where defined (name ()) as entity
        if    name () = "action"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[other].[action] as [thread state action]
        parse_thread_state_action ([thread state action])
    endfor

                if my.[other].nextstate <> ""
    if defined (0.[nextstate])
        my.source = link_target ("state", "thread state", "name", 0.[nextstate]) ?
        if defined (my.source)
                endif
        else
            parse_error ("State '$(0.[nextstate])' missing$(my.location)")
        endif
    endif
        my.[other].actionlist = ""
        for my.[other].action
            my.[other].actionlist += action.actionlist
        endfor
        
        build_place (my.[other])
        
        if my.[other].nextstate <> ""
            my.nextstate = thread-> state (0.name = my.[other].nextstate) ?
            if ! defined (my.nextstate)
                parse_error ("Unknown state: '$(my.[other].nextstate)'$(my.location)")
            elsif (my.nextstate.reached ? 0) = 0
                scope my.nextstate as [thread state]
                    parse_thread_state ([thread state])
                endscope
            endif
        endif
endfunction

function parse_thread ([thread])
    my.entity = my.[thread]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_thread ? 0
       echo "<parse_thread location = \"$(my.location)\""
    endif

        agent.lastthread += 1
        thread.id = agent.lastthread

        agent.lastplace += 1
        thread.place = agent.lastplace
    if !defined (my.[thread].[abstract])
        my.[thread].[abstract] = "0"
    endif
    if defined (my.[thread].[abstract])
        if    my.[thread].[abstract] ?= "0"
        elsif my.[thread].[abstract] ?= "1"
        else
            parse_error ("Attribute 'abstract' has illegal value '$(0.[abstract]?)'$(my.location)")
        endif
    endif
    if !defined (my.[thread].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if defined (my.[thread].[schedule])
        if    my.[thread].[schedule] ?= "poll"
        elsif my.[thread].[schedule] ?= "cpu"
        else
            parse_error ("Attribute 'schedule' has illegal value '$(0.[schedule]?)'$(my.location)")
        endif
    endif
    if !defined (my.[thread].[share])
        my.[thread].[share] = "0"
    endif
    if defined (0.[context])
        my.source = link_target ("context", "agent context", "name", 0.[context]) ?
        if defined (my.source)
            my.target = my.[thread]
                        my.target = my.thread.new ("context")
            perform_inherit_agent_context_item (my.target, my.source)
        else
            parse_error ("Context '$(0.[context])' missing$(my.location)")
        endif
    endif
        /*  Because thread is disconnected, manually process children        */
        for thread.inherit
            parse_inherit (inherit)
        endfor
        for thread.context as [thread context]
            parse_thread_context ([thread context])
        endfor
        for thread.handler as [thread handler]
            parse_thread_handler ([thread handler])
        endfor
        
        /*  Only parse first thread - others will be parsed when readched.   */
        my.first_state = thread-> state ?
        if defined (my.first_state)
            scope my.first_state as [thread state]
                parse_thread_state ([thread state])
            endscope
        else
            preproc_error ("No state$(my.location)")
        endif
endfunction

function parse_thread_context ([thread context])
    my.entity = my.[thread context]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_thread_context ? 0
       echo "<parse_thread_context location = \"$(my.location)\""
    endif

        #   Copy named context item
        if defined ([thread context].name)
            if defined (agent-> context (0.name = [thread context].name & . <> [thread context].))
                parse_error ("Duplicate context: $([thread context].name?'<Unnamed>')")
            endif
        else
            [thread context].name = thread.name
            thread.context = [thread context].name
        endif
        if ! defined (agent-> context (0.name = [thread context].name))
            copy [thread context] to agent
        endif
        
        if thread.context ?<> [thread context].name
            parse_error ("Ambiguous context declaration$(my.location)")
        else
            thread.context ?= [thread context].name
        endif
    for my.[thread context]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_thread_handler ([thread handler])
    my.entity = my.[thread handler]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_thread_handler ? 0
       echo "<parse_thread_handler location = \"$(my.location)\""
    endif

    if !defined (my.[thread handler].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if defined (my.[thread handler].[name])
        if    my.[thread handler].[name] ?= "thread new"
        elsif my.[thread handler].[name] ?= "thread init"
        elsif my.[thread handler].[name] ?= "thread destroy"
        else
            parse_error ("Attribute 'name' has illegal value '$(0.[name]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[thread handler]. where defined (name ()) as entity
        if    name () = "argument"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[thread handler].[argument] as [argument]
        parse_argument ([argument])
    endfor

    my.last_key =
    for my.[thread handler].[argument] as [argument] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <argument name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_thread_state ([thread state])
    my.entity = my.[thread state]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_thread_state ? 0
       echo "<parse_thread_state location = \"$(my.location)\""
    endif

        my.[thread state].reached = (my.[thread state].reached ? 0) + 1
    
        /*  Inherit from agent state.                                        */
        my.agent_state = agent-> state (0.name = my.[thread state].name) ?
        if defined (my.agent_state)
            perform_inherit_thread_state_item (my.[thread state], my.agent_state)
            my.agent_state.inherited = 1
        endif
        
        /*  Inherit from thread defaults state.                              */
        my.defaults_state = thread-> state (0.name = "defaults") ?
        if defined (my.defaults_state)
            perform_inherit_thread_state_item (my.[thread state], my.defaults_state)
            my.defaults_state.inherited = 1
        endif
        
        /*  Inherit from agent defaults state.                               */
        my.defaults_state = agent-> state (0.name = "defaults") ?
        if defined (my.defaults_state)
            perform_inherit_thread_state_item (my.[thread state], my.defaults_state)
            my.defaults_state.inherited = 1
        endif
        
        /*  Agent state is only to avoid duplicated names.  Same-named       */
        /*  states in different threads are unconnected.                     */
        my.[agent state] = agent-> state (0.name = my.[thread state].name) ?
        if ! defined (my.[agent state])
            my.[agent state] = agent.new ("state")
            my.[agent state]._entity = "agent state"
            my.[agent state].name = my.[thread state].name
            my.[agent state]._key = my.[agent state].name
            agent.laststate += 1
            my.[agent state].id   = agent.laststate
        elsif ! defined (my.[agent state].id)
            agent.laststate += 1
            my.[agent state].id = agent.laststate
        endif
        my.[thread state].id = my.[agent state].id
        
        agent.lastplace += 1
        my.[thread state].place = agent.lastplace
        
        #   Assign place to each event/other so they are consecutive
        for my.[thread state].event
            agent.lastplace += 1
            event.place = agent.lastplace
        endfor
        my.default = my.[thread state]->default ?
        if defined (my.default)
            agent.lastplace += 1
            my.default.place = agent.lastplace
        endif
    if !defined (my.[thread state].[abstract])
        my.[thread state].[abstract] = "0"
    endif
    if defined (my.[thread state].[abstract])
        if    my.[thread state].[abstract] ?= "0"
        elsif my.[thread state].[abstract] ?= "1"
        else
            parse_error ("Attribute 'abstract' has illegal value '$(0.[abstract]?)'$(my.location)")
        endif
    endif
    if !defined (my.[thread state].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[thread state]. where defined (name ()) as entity
        if    name () = "option"
        elsif name () = "inherit"
        elsif name () = "handler"
        elsif name () = "event"
        elsif name () = "default"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[thread state].[option] as [option]
        parse_option ([option])
    endfor

    for my.[thread state].[inherit] as [inherit]
        parse_inherit ([inherit])
    endfor

    for my.[thread state].[handler] as [state handler]
        parse_state_handler ([state handler])
    endfor

    for my.[thread state].[event] as [thread state event]
        parse_thread_state_event ([thread state event])
    endfor

    for my.[thread state].[default] as [other]
        parse_other ([other])
    endfor

    my.last_key =
    for my.[thread state].[option] as [option] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <option name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[thread state].[handler] as [state handler] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <handler name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[thread state].[event] as [thread state event] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <event name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_thread_state_event ([thread state event])
    my.entity = my.[thread state event]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_thread_state_event ? 0
       echo "<parse_thread_state_event location = \"$(my.location)\""
    endif

    my.[thread state event].nextstate ?= [thread state].name
        my.[agent event] = agent-> event (0.name = my.[thread state event].name) ?
        if ! defined (my.[agent event])
            my.[agent event] = agent.new ("event")
            my.[agent event]._entity = "agent event"
            my.[agent event].name = my.[thread state event].name
            my.[agent event]._key = my.[agent event].name
            agent.lastevent += 1
            my.[agent event].id   = agent.lastevent
        endif
        my.[thread state event].id = my.[agent event].id
    if !defined (my.[thread state event].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[thread state event]. where defined (name ()) as entity
        if    name () = "action"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[thread state event].[action] as [thread state action]
        parse_thread_state_action ([thread state action])
    endfor

                if my.[thread state event].nextstate <> ""
    if defined (0.[nextstate])
        my.source = link_target ("state", "thread state", "name", 0.[nextstate]) ?
        if defined (my.source)
                endif
        else
            parse_error ("State '$(0.[nextstate])' missing$(my.location)")
        endif
    endif
        my.[thread state event].actionlist = ""
        for my.[thread state event].action
            my.[thread state event].actionlist += action.actionlist
        endfor
        
        build_place (my.[thread state event])
        
        if my.[thread state event].nextstate <> ""
            my.nextstate = thread-> state (0.name = my.[thread state event].nextstate) ?
            if ! defined (my.nextstate)
                parse_error ("Unknown state: '$(my.[thread state event].nextstate)'$(my.location)")
            elsif (my.nextstate.reached ? 0) = 0
                scope my.nextstate as [thread state]
                    parse_thread_state ([thread state])
                endscope
            endif
        endif
endfunction

function parse_thread_state_action ([thread state action])
    my.entity = my.[thread state action]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_thread_state_action ? 0
       echo "<parse_thread_state_action location = \"$(my.location)\""
    endif

    /*   Look up or create agent action.                                     */
    my.[agent action] = agent-> action (0.name ?= my.[thread state action].name) ?
    if !defined (my.[agent action])
        my.[agent action] = agent.new ("action")
    endif
    if ! defined (my.[agent action].id)
        agent.lastaction += 1
        my.[agent action].id   = agent.lastaction
        my.[agent action].name = my.[thread state action].name ?
    endif
    my.[thread state action].id = my.[agent action].id
    if defined (my.[thread state action]->)
        if ! defined (my.[agent action]->)
            for my.[thread state action]. as child
                move child to my.[agent action]
            endfor
        endif
    endif
    
    #   Keep a record in the thread that this action was called in it.
    if ! defined (thread-> action (id = my.[thread state action].id))
        new thread.action
            action.id = my.[thread state action].id
        endnew
    endif
    
    #   Make sure called states get parsed at the right time
    for my.[agent action].call
        my.state = thread->state (0.name = call.state) ?
        if !defined (my.state)
            parse_error ("Unknown state $(call.state)$(my.location)")
        else
            if (my.state.reached ? 0) = 0
                scope my.state as [thread state]
                    parse_thread_state ([thread state])
                endscope
            endif
        endif
    endfor
    
    #   Build implicit actions
    if count (my.[agent action].) > 1
        my.[agent action].actionlist = ""
        for my.[agent action].action
            parse_thread_state_action (action)
            my.[agent action].actionlist += action.actionlist
        endfor
    else
        
        my.[agent action].actionlist = ":" + my.[thread state action].id
        
        #   Register which context is in place for this action
        if defined (my.[agent action].context)
            #   If action is used in multiple contexts then 'tcb' macro will be
            #   unavailable.
            if my.[agent action].context <> ""             \
             & my.[agent action].context <> thread.context
                my.[agent action].context = ""
            endif
        else
            my.[agent action].context = thread.context
        endif
    endif
    
    my.[thread state action].name ?= "unnamed $(my.[thread state action].id)"
    my.[agent action].name        ?= my.[thread state action].name
    
    my.[thread state action].actionlist = my.[agent action].actionlist
endfunction

function parse_thread_action ([thread action])
    my.entity = my.[thread action]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_thread_action ? 0
       echo "<parse_thread_action location = \"$(my.location)\""
    endif

endfunction

function parse_agent_event ([agent event])
    my.entity = my.[agent event]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_agent_event ? 0
       echo "<parse_agent_event location = \"$(my.location)\""
    endif

    if !defined (my.[agent event].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    for my.[agent event]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_method ([method])
    my.entity = my.[method]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_method ? 0
       echo "<parse_method location = \"$(my.location)\""
    endif

    if !defined (my.[method].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[method].[event])
        my.[method].[event] = "$(name?)_m"
    endif
    if !defined (my.[method].[priority])
        my.[method].[priority] = "normal"
    endif
    if defined (my.[method].[priority])
        if    my.[method].[priority] ?= "normal"
        elsif my.[method].[priority] ?= "high"
        else
            parse_error ("Attribute 'priority' has illegal value '$(0.[priority]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[method]. where defined (name ()) as entity
        if    name () = "argument"
        elsif name () = "possess"
        elsif name () = "release"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[method].[argument] as [argument]
        parse_argument ([argument])
    endfor

    for my.[method].[possess] as [possess]
        parse_possess ([possess])
    endfor

    for my.[method].[release] as [release]
        parse_release ([release])
    endfor

    my.last_key =
    for my.[method].[argument] as [argument] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <argument name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    if defined (0.[event])
        my.source = link_target ("event", "agent event", "name", 0.[event]) ?
        if defined (my.source)
        else
            parse_error ("Event '$(0.[event])' missing$(my.location)")
        endif
    endif
endfunction

function parse_possess ([possess])
    my.entity = my.[possess]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_possess ? 0
       echo "<parse_possess location = \"$(my.location)\""
    endif

    for my.[possess]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_release ([release])
    my.entity = my.[release]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_release ? 0
       echo "<parse_release location = \"$(my.location)\""
    endif

    for my.[release]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_message ([message])
    my.entity = my.[message]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_message ? 0
       echo "<parse_message location = \"$(my.location)\""
    endif

    if !defined (my.[message].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[message].[priority])
        my.[message].[priority] = "normal"
    endif
    if defined (my.[message].[priority])
        if    my.[message].[priority] ?= "normal"
        elsif my.[message].[priority] ?= "high"
        else
            parse_error ("Attribute 'priority' has illegal value '$(0.[priority]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[message]. where defined (name ()) as entity
        if    name () = "argument"
        elsif name () = "method"
        elsif name () = "possess"
        elsif name () = "release"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[message].[argument] as [argument]
        parse_argument ([argument])
    endfor

    for my.[message].[method] as [message method]
        parse_message_method ([message method])
    endfor

    for my.[message].[possess] as [possess]
        parse_possess ([possess])
    endfor

    for my.[message].[release] as [release]
        parse_release ([release])
    endfor

    my.last_key =
    for my.[message].[argument] as [argument] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <argument name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[message].[method] as [message method] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <method name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_message_method ([message method])
    my.entity = my.[message method]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_message_method ? 0
       echo "<parse_message_method location = \"$(my.location)\""
    endif

    if !defined (my.[message method].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[message method].[event])
        my.[message method].[event] = "$(name?)_m"
    endif
    if !defined (my.[message method].[priority])
        my.[message method].[priority] = "normal"
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[message method]. where defined (name ()) as entity
        if    name () = "argument"
        elsif name () = "possess"
        elsif name () = "release"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[message method].[argument] as [argument]
        parse_argument ([argument])
    endfor

    for my.[message method].[possess] as [possess]
        parse_possess ([possess])
    endfor

    for my.[message method].[release] as [release]
        parse_release ([release])
    endfor

    my.last_key =
    for my.[message method].[argument] as [argument] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <argument name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    if defined (0.[event])
        my.source = link_target ("event", "agent event", "name", 0.[event]) ?
        if defined (my.source)
        else
            parse_error ("Event '$(0.[event])' missing$(my.location)")
        endif
    endif
endfunction

function parse_actionlist ([actionlist])
    my.entity = my.[actionlist]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_actionlist ? 0
       echo "<parse_actionlist location = \"$(my.location)\""
    endif

        #   Identify call targets
        for action
            identify_call_targets (action)
        endfor
                
        for place
            my.thread = agent-> thread (name = place.thread)
            place.key = my.thread.id
            if place.nextstate <> ""
                my.state = my.thread-> state (name ?= place.nextstate) ?
                if ! defined (my.state)
                    parse_error ("Unknown state: '$(place.nextstate)'$(my.location)")
                else
                    place.key += ":" + my.state.id
                endif
            endif
            my.nextstate = actionlist-> nextstate (key = place.key) ?
            if (! defined (my.nextstate))
                my.nextstate = actionlist.new ("nextstate")
                my.nextstate.key = place.key
                my.nextstate.thread = place.thread
                if place.nextstate <> "" & defined (my.state)
                    my.nextstate.state = place.nextstate ?
                    my.nextstate.place = my.state.place
                endif
            endif
            copy place to my.nextstate
        endfor
endfunction

function parse_inherit ([inherit])
    my.entity = my.[inherit]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_inherit ? 0
       echo "<parse_inherit location = \"$(my.location)\""
    endif

    if defined (my.[inherit].[phase])
        if    my.[inherit].[phase] ?= "preproc"
        elsif my.[inherit].[phase] ?= "parse"
        else
            parse_error ("Attribute 'phase' has illegal value '$(0.[phase]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[inherit]. where defined (name ()) as entity
        if    name () = "option"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[inherit].[option] as [option]
        parse_option ([option])
    endfor

    my.last_key =
    for my.[inherit].[option] as [option] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <option name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_option ([option])
    my.entity = my.[option]
    my.location = location ("agent")

    if switches.trace ? 0 | switches.trace_option ? 0
       echo "<parse_option location = \"$(my.location)\""
    endif

    for my.[option]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function build_actionlist (actionlist, action)
    my.agentaction = agent-> action (0.id ?= my.action.id)
    my.agentaction.used = (my.agentaction.used ? 0) + 1
    for my.agentaction.action
        build_actionlist (my.actionlist, action)
    else
        my.actionlist.lastaction += 1
        new my.actionlist.action
            action.num  = my.actionlist.lastaction
            action.name = my.action.name
            action.id   = my.action.id
        endnew
    endfor
endfunction

function build_place (parent)
    /*  This is where we can optimise...  */
    my.actionlist = agent-> actionlist (name=my.parent.actionlist) ?
    if ! defined (my.actionlist)
        my.actionlist = agent.new ("actionlist")
        my.actionlist.name       = my.parent.actionlist
        my.actionlist.lastaction = 0
        agent.lastactionlist += 1
        my.actionlist.id = agent.lastactionlist
        for my.parent.action
            build_actionlist (my.actionlist, action)
        endfor
    endif
    my.parent.actionlist = my.actionlist.id
    my.place = agent.new ("place")
    my.place.thread    = thread.name
    my.place.state     = [thread state].name
    my.place.event     = my.parent.name      ?   #  May be undefined if 'other'
    my.place.nextstate = my.parent.nextstate ?
    my.place.id        = my.parent.place
    copy my.place to my.actionlist
    my.place.actionlist = my.actionlist.id
endfunction

function identify_call_targets (action)
    my.agentaction = agent-> action (0.id ?= my.action.id)
    for my.agentaction.call
        for callplace
            my.state = agent-> thread (0.name = callplace.thread) \
                            -> state  (0.name = call.state)       ?
            if defined (my.state)
                callplace.place = my.state.place
            else
                callplace.delete ()
            endif
        endfor
    endfor
    for my.agentaction.action
        identify_call_targets (action)
    endfor
endfunction

function parse_error (message)
    echo (my.message)
    global.errno = 1
endfunction
