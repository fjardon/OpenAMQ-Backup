#  ----------------------------------------------------------------------------
#   PAL back-end code generator for demo over STDC runtime
#
#   Converts a PAL script into ANSI C running over the standard C client API.
#
#   *** GENERATED FROM demo.asl BY asl_gen USING GSL/4 ***
#   *** DO NOT MODIFY THIS FILE ***
#
#   Copyright (c) 1996-2009 iMatix Corporation
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   For information on alternative licensing for OEMs, please contact
#   iMatix Corporation.
#  ----------------------------------------------------------------------------

#################################   MAIN   #################################

function generate_automation (pal)
  scope my.pal
    ignorecase = 0
.    template
.    open_output ("$(pal.name).c")
/*===========================================================================
    $(pal.name).c - C version of PAL script
.if defined (pal.)
    $(pal.?'')
.endif

    Generated for demo protocol using iMatix ASL/PAL.
    Don't modify this by hand unless you know what you're doing; it's
    written by a robot that is better at writing AMQP clients in C than
    you probably are.  See $(pal.name).pal for the instructions that
    caused the robot to produce this file.

.   if defined (copyright)
    $(copyright:)
.   endif
.   $(license:lower)_license (" ")
 *===========================================================================*/

#include "asl.h"
#include "demo_client_connection.h"
#include "demo_client_session.h"

#define NOWARRANTY \\
"This is free software; see the source for copying conditions.  There is NO\\n" \\
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n" \\
    "\\n"
#define USAGE1                                                                 \\
    "Syntax: $(pal.name) [options...]\\n"                                      \\
    "Options:\\n"                                                              \\
    "  -s server        Server:port to connect to (localhost)\\n"              \\
    "  -t level         Set trace level (0)\\n"                                \\
    "                   0=none, 1=low, 2=medium, 3=high\\n"                    \\
    "  -r count         Repeat script count times, 0=forever (1)\\n"           \\
.   for pal.option
    "  -$(switch) value\
                        Specify $(name) variable ($(value))\\n"                \\
.   endfor
    "  -c               Clock the script (0)\\n"                               \\
    "  -a               Animate: show script commands\\n"                      \\
    "  -e               Execute in single-step mode (0)\\n"                    \\
    "  -f filename      Load custom settings from file (wireapi.cfg)\\n"       \\
    "  -q               Quiet mode: no messages\\n"                            \\
    "  -v               Show version information\\n"                           \\
    "  -h               Show summary of command-line options\\n"               \\
    "  --help           Show detailed configuration help\\n"                   \\
    "\\n"
#define USAGE2                                                                 \\
    "\\n"                                                                      \\
    "The order of arguments is not important. Switches and filenames\\n"       \\
    "are case sensitive. See documentation for detailed information.\\n"       \\
    "\\n"

//  Local function prototypes

//  Establish or reestablish connection and session
static int s_establish_session (
    char *server_name,
    char *instance_name,
    int   trace_level,
    char *virtual_host,
    int   timeout);

//  Update symbol tables from current connection/session
static void s_get_connection_symbols (void);
static void s_get_session_symbols    (void);
static int  s_connection_alive       (void);
static int  s_connection_interrupt   (void);
static int  s_connection_failed      (void);
static int  s_session_alive          (void);

//  Perform templating using context or session symbol tables
static char *s_tpl (char *string);

//  Report an error
static void s_report_error (void);

//  Static source-global variables
static demo_client_connection_t
    *s_connection = NULL;               //  Current connection
static demo_client_session_t
    *s_session = NULL;                  //  Current session
static ipr_dict_table_t
    *s_symbols;                         //  Symbol table
static size_t
    s_body_size = 0;                    //  Content body size
static apr_time_t
    s_start_time,                       //  Start time, microseconds
    s_elapsed = 0;                      //  Elapsed time, microseconds

int
main (int argc, char *argv [])
{
    int
        argn;                           //  Argument number
    Bool
        args_ok = TRUE;                 //  Were the arguments okay?
    char
        **argparm;                      //  Argument parameter to pick-up
    char
        *opt_trace = "0",               //  Trace level argument
        *opt_repeat = "1",              //  Repeat count argument
        *opt_config = NULL,             //  -f specifies configuration file
        *server_name = "localhost",     //  Host to connect to
        *instance_name = "$(pal.name)";//   Client instance name
    Bool
        opt_animate = FALSE,            //  Animation wanted?
        opt_clock = FALSE,              //  Clock the script?
        opt_execute = FALSE;            //  Single-step mode?
    int
        trace_level,                    //  Trace level
        repeat_count;                   //  Repeat count
    long
        send_count = 0,                 //  Total messages sent
        recv_count = 0;                 //  Total messages received
    int64_t
        send_bytes = 0,                 //  Total bytes sent
        recv_bytes = 0;                 //  Total bytes received
    ipr_stat_t
        *latencies;                     //  Message latency statistics
.   for pal.option
    char
        *opt_$(name:c) = "$(value)";    //  Default setting for $(name)
.   endfor
    ipr_process_t
        *server_process = NULL;         //  Server process
    demo_content_basic_t
        *basic_content = NULL;          //  Last content sent/recieved
.   for pal.variable
.       if type = "integer"
    int
        $(name:c) = 0;                  //  Integer variable
.       else
    char
        *$(name:c) = NULL;              //  String variable
.       endif
.   endfor
    int
        content_processed = 0;
    int
        rc,                             //  Return code from API calls
        main_rc = 0;                    //  Main return code

    //  Avert grumpy compiler warnings for unused variables & functions
    content_processed = 0;
    rc = s_connection_failed ();

    //  Initialise iCL system
    icl_console_mode (ICL_CONSOLE_QUIET, TRUE);
    icl_system_initialise (argc, argv);
    icl_console_mode (ICL_CONSOLE_QUIET, FALSE);
    s_start_time = apr_time_now ();

    //  Create and initialise symbol table
    s_symbols = ipr_dict_table_new ();
    ipr_dict_assume (s_symbols, "script", "$(pal.name)");
    ipr_dict_assume (s_symbols, "FRAME_METHOD", "1");
    ipr_dict_assume (s_symbols, "FRAME_HEADER", "2");
    ipr_dict_assume (s_symbols, "FRAME_BODY", "3");
    ipr_dict_assume (s_symbols, "FRAME_OOB_METHOD", "4");
    ipr_dict_assume (s_symbols, "FRAME_OOB_HEADER", "5");
    ipr_dict_assume (s_symbols, "FRAME_OOB_BODY", "6");
    ipr_dict_assume (s_symbols, "FRAME_TRACE", "7");
    ipr_dict_assume (s_symbols, "FRAME_HEARTBEAT", "8");
    ipr_dict_assume (s_symbols, "FRAME_MIN_SIZE", "4096");
    ipr_dict_assume (s_symbols, "FRAME_END", "206");
    ipr_dict_assume (s_symbols, "REPLY_SUCCESS", "200");
    ipr_dict_assume (s_symbols, "NOT_DELIVERED", "310");
    ipr_dict_assume (s_symbols, "CONTENT_TOO_LARGE", "311");
    ipr_dict_assume (s_symbols, "CONNECTION_FORCED", "320");
    ipr_dict_assume (s_symbols, "INVALID_PATH", "402");
    ipr_dict_assume (s_symbols, "ACCESS_REFUSED", "403");
    ipr_dict_assume (s_symbols, "NOT_FOUND", "404");
    ipr_dict_assume (s_symbols, "RESOURCE_LOCKED", "405");
    ipr_dict_assume (s_symbols, "FRAME_ERROR", "501");
    ipr_dict_assume (s_symbols, "SYNTAX_ERROR", "502");
    ipr_dict_assume (s_symbols, "COMMAND_INVALID", "503");
    ipr_dict_assume (s_symbols, "CHANNEL_ERROR", "504");
    ipr_dict_assume (s_symbols, "RESOURCE_ERROR", "506");
    ipr_dict_assume (s_symbols, "NOT_ALLOWED", "530");
    ipr_dict_assume (s_symbols, "NOT_IMPLEMENTED", "540");
    ipr_dict_assume (s_symbols, "INTERNAL_ERROR", "541");

    randomize ();
    latencies = ipr_stat_new ();

    argparm = NULL;                     //  Argument parameter to pick-up
    for (argn = 1; argn < argc; argn++) {
        //  If argparm is set, we have to collect an argument parameter
        if (argparm) {
            if (*argv [argn] != '-') {  //  Parameter can't start with '-'
                *argparm = argv [argn];
                argparm = NULL;
            }
            else {
                args_ok = FALSE;
                break;
            }
        }
        else
        if (ipr_str_prefixed (argv [argn], "--"))
            argn++;                     //  Extended argument + value
        else
        if (*argv [argn] == '-') {
            switch (argv [argn][1]) {
                //  These switches take a parameter
                case 's':
                    argparm = &server_name;
                    break;
                case 'i':
                    argparm = &instance_name;
                    break;
                case 'f':
                    argparm = &opt_config;
                    break;
                case 't':
                    argparm = &opt_trace;
                    break;
                case 'r':
                    argparm = &opt_repeat;
                    break;
.   for pal.option
                case '$(switch)':
                    argparm = &opt_$(name:c);
                    break;
.   endfor

                //  These switches have an immediate effect
                case 'a':
                    opt_animate = TRUE;
                    break;
                case 'e':
                    opt_animate = TRUE;
                    opt_execute = TRUE;
                    break;
                case 'c':
                    opt_clock = TRUE;
                    break;
                case 'q':
                    icl_console_mode (ICL_CONSOLE_QUIET, TRUE);
                    break;
                case 'v':
.   if defined (copyright)
                    printf ("$(copyright)\\n");
.   endif
                    printf (NOWARRANTY);
                    printf ("Compiled with: " CCOPTS "\\n");
                    goto finished;
                case 'h':
                    printf ("$(pal.name)\\n");
.   if defined (copyright)
                    printf ("$(copyright)\\n");
.   endif
                    printf (NOWARRANTY);
                    printf (USAGE1);
                    demo_client_config_cmdline_help ();
                    printf (USAGE2);
                    goto finished;

                //  Anything else is an error
                default:
                    args_ok = FALSE;
            }
        }
        else {
            args_ok = FALSE;
            break;
        }
    }
    //  If there was a missing parameter or an argument error, quit
    if (argparm) {
        icl_console_print ("E: argument missing - use '-h' option for help");
        goto exit_failure;
    }
    else
    if (!args_ok) {
        icl_console_print ("E: invalid arguments - use '-h' option for help");
        goto exit_failure;
    }
    trace_level  = atoi (opt_trace);
    repeat_count = atoi (opt_repeat);

    //  Load configuration data, if any, into the config_table
    if (!opt_config)
        opt_config = "wireapi.cfg";
    demo_client_config = demo_client_config_new ();
    demo_client_config_load_xmlfile (demo_client_config, "wireapi.cfg", FALSE);
    demo_client_config_cmdline_parse (demo_client_config, "$(pal.name)", argc, argv);

    FOREVER {                           //  For command-line repeat requests

.   codegen_pal (pal)

        if (repeat_count && --repeat_count == 0)
            break;
    }
    goto finished;
    //  We stopped the script and want to end with a fatal error status code
    exit_failure:
        main_rc = EXIT_FAILURE;
    finished:

    //  Stop the clock, we're not doing any more work
    s_elapsed += apr_time_now () - s_start_time;
    s_elapsed /= 1000;                  //  Get into msecs
    if (opt_clock && s_elapsed) {
        send_bytes = send_bytes / 1024;
        recv_bytes = recv_bytes / 1024;
        icl_console_print ("I: elapsed time:%ld msecs", (long) s_elapsed);
        icl_console_print ("I: outgoing messages:%ld (%ld Kbytes)", send_count, (long) send_bytes);
        icl_console_print ("I: incoming messages:%ld (%ld Kbytes)", recv_count, (long) recv_bytes);
        if (send_count || recv_count)
            icl_console_print ("I: total messages:%ld (%ld Kbytes) average:%ld/sec (%ld Kbytes/sec)",
                (long) (send_count + recv_count),
                (long) (send_bytes + recv_bytes),
                (long) (((send_count + recv_count) * 1000) / s_elapsed),
                (long) (((send_bytes + recv_bytes) * 1000) / s_elapsed));
        if (ipr_stat_count (latencies))
            icl_console_print ("I: message latency min=%d max=%d mean=%d dev=%d msecs",
                (int) ipr_stat_min  (latencies),
                (int) ipr_stat_max  (latencies),
                (int) ipr_stat_mean (latencies),
                (int) ipr_stat_dev  (latencies));
    }
    //  Shutdown
    s_tpl (NULL);                       //  Garbage collect templates
.   for pal.variable where type = "string"
    icl_mem_free ($(name:c));
.   endfor
    demo_content_basic_unlink (&basic_content);
    demo_client_session_destroy (&s_session);
    demo_client_connection_destroy (&s_connection);
    demo_client_config_destroy (&demo_client_config);

    ipr_process_destroy    (&server_process);
    ipr_dict_table_unlink  (&s_symbols);
    ipr_stat_destroy       (&latencies);
    icl_system_terminate ();

    return (main_rc);
}


//  Establish connection and session
//
static int
s_establish_session (
    char *server_name,
    char *instance_name,
    int   trace_level,
    char *virtual_host,
    int   timeout)
{
    icl_longstr_t
        *auth_data;                     //  Login authorisation
    ipr_token_list_t
        *host_list;                     //  List of known hosts
    ipr_token_t
        *token;                         //  Next host to try
    int
        rc = 0;

    assert (!s_connection && !s_session);

    //  Pause the clock, as we're going to wait for the server
    //  to start-up and this can interfere with our timings
    s_elapsed += apr_time_now () - s_start_time;
    auth_data = demo_client_connection_auth_plain ("guest", "guest");
    host_list = ipr_token_split (server_name);

    token = ipr_token_list_first (host_list);
    while (token) {
        s_connection = demo_client_connection_new (
            token->value, virtual_host, auth_data, instance_name, trace_level, timeout);
        if (s_connection) {
            ipr_token_unlink (&token);
            break;
        }
        token = ipr_token_list_next (&token);
    }
    ipr_token_list_destroy (&host_list);
    icl_longstr_destroy (&auth_data);

    if (s_connection) {
        s_connection->silent = TRUE;
        s_get_connection_symbols ();
        s_session = demo_client_session_new (s_connection);
        if (s_session)
            s_start_time = apr_time_now ();     //  Restart the clock
        else {
            icl_console_print ("E: could not open session to server");
            rc = -1;
        }
    }
    else {
        icl_console_print ("E: could not connect to %s", server_name);
        rc = -1;
    }
    return (rc);
}

static void
s_get_connection_symbols (void)
{
    ipr_dict_assume_fmt (s_symbols, "channel_max", "%ld", (long) s_connection->channel_max);
    ipr_dict_assume_fmt (s_symbols, "class_id", "%ld", (long) s_connection->class_id);
    ipr_dict_assume_fmt (s_symbols, "frame_max", "%ld", (long) s_connection->frame_max);
    ipr_dict_assume_fmt (s_symbols, "heartbeat", "%ld", (long) s_connection->heartbeat);
    ipr_dict_assume     (s_symbols, "known_hosts", s_connection->known_hosts);
    ipr_dict_assume_fmt (s_symbols, "method_id", "%ld", (long) s_connection->method_id);
    ipr_dict_assume_fmt (s_symbols, "reply_code", "%ld", (long) s_connection->reply_code);
    ipr_dict_assume     (s_symbols, "reply_text", s_connection->reply_text);
    ipr_dict_assume     (s_symbols, "server_copyright", s_connection->server_copyright);
    ipr_dict_assume     (s_symbols, "server_host", s_connection->server_host);
    ipr_dict_assume     (s_symbols, "server_information", s_connection->server_information);
    ipr_dict_assume     (s_symbols, "server_platform", s_connection->server_platform);
    ipr_dict_assume     (s_symbols, "server_port", s_connection->server_port);
    ipr_dict_assume     (s_symbols, "server_product", s_connection->server_product);
    ipr_dict_assume     (s_symbols, "server_version", s_connection->server_version);
    ipr_dict_assume_fmt (s_symbols, "version_major", "%ld", (long) s_connection->version_major);
    ipr_dict_assume_fmt (s_symbols, "version_minor", "%ld", (long) s_connection->version_minor);
}

static void
s_get_session_symbols (void)
{
    ipr_dict_assume_fmt (s_symbols, "active",   "%ld", (long) s_session->active);
    ipr_dict_assume_fmt (s_symbols, "class_id",  "%ld", (long) s_session->class_id);
    ipr_dict_assume     (s_symbols, "consumer_tag", s_session->consumer_tag);
    ipr_dict_assume_fmt (s_symbols, "delivery_tag",  "%ld", (long) s_session->delivery_tag);
    ipr_dict_assume     (s_symbols, "exchange", s_session->exchange);
    ipr_dict_assume     (s_symbols, "lease", s_session->lease);
    ipr_dict_assume_fmt (s_symbols, "message_count",  "%ld", (long) s_session->message_count);
    ipr_dict_assume_fmt (s_symbols, "method_id",  "%ld", (long) s_session->method_id);
    ipr_dict_assume     (s_symbols, "queue", s_session->queue);
    ipr_dict_assume_fmt (s_symbols, "reply_code",  "%ld", (long) s_session->reply_code);
    ipr_dict_assume     (s_symbols, "reply_text", s_session->reply_text);
    ipr_dict_assume     (s_symbols, "routing_key", s_session->routing_key);
}

//  This function does string templating using a symbol table.
//  In order to make the API very simple, we keep an internal table
//  of all allocated strings, and we free these strings when the
//  table overflows, or when the function is called with a null argument.
//

static char *
s_tpl (char *string)
{
    //  Should be large enough for worst case of number of templates
    //  we might need at once - probably 2 or 3.
#   define TEMPLATE_MAX 30
    static char
        *allocated [TEMPLATE_MAX];
    static int
        head = 0,                       //  Buffer head, always free
        count = 0;                      //  Number of allocations
    char
        *template;                      //  Templated string

    //  Insert/update standard symbols
    ipr_dict_assume_fmt (s_symbols, "connection", "%d", s_connection_alive ());
    ipr_dict_assume_fmt (s_symbols, "session", "%d", s_session_alive ());
    ipr_dict_assume_fmt (s_symbols, "random", "%04x", rand ());
    ipr_dict_assume_fmt (s_symbols, "body_size", "%ld", s_body_size);

    if (string) {
        if (strchr (string, '$')) {
            template = ipr_dict_table_template (s_symbols, string);
            allocated [head] = template;
            head++;
            if (head == TEMPLATE_MAX)
                head = 0;
            if (count < TEMPLATE_MAX - 1)
                count++;
            else
                icl_mem_free (allocated [head]);
            return (template);
        }
        else
            return (string);            //  Nothing to translate
    }
    else {
        //  Free all allocated strings
        while (count) {
            if (head == 0)
                head = TEMPLATE_MAX;
            head--;
            count--;
            icl_mem_free (allocated [head]);
        }
        return (NULL);
    }
}

static int
s_connection_alive (void)
{
    if (s_connection)
        return (s_connection->alive);
    else
        return (0);
}

static int
s_connection_interrupt (void)
{
    if (s_connection && s_connection->interrupt)
        return (1);
    else
        return (0);
}

static int
s_connection_failed (void)
{
    if (s_connection && !s_connection->alive && s_connection->reply_code == 100)
        return (1);
    else
        return (0);
}

static int
s_session_alive (void)
{
    if (s_session)
        return (s_session->alive);
    else
        return (0);
}

static void
s_report_error (void)
{
    if (s_session) {
        if (s_session->reply_code)
            icl_console_print ("E: %d - %s", s_session->reply_code, s_session->reply_text);
        else
            icl_console_print ("E: %s", s_session->error_text);
    }
    else
        icl_console_print ("E: failed");
}
.    endtemplate
  endscope
endfunction


################################   FUNCTIONS

function open_output (filename)
    if !defined (switches.quiet)
        echo "Generating $(my.filename)..."
    endif
    output my.filename
endfunction

function get_field_realname (name)
    #   Replace standard variables first
    if my.name = "script"
        pal.realname = '"$(pal.name)"'
        return "string"
    elsif my.name = "connection"
        pal.realname = "s_connection_alive ()"
        return "integer"
    elsif my.name = "session"
        pal.realname = "s_session_alive ()"
        return "integer"
    elsif my.name = "random"
        pal.realname = "rand ()"
        return "integer"
    elsif my.name = "body_size"
        pal.realname = "s_body_size"
        return "integer"
    endif

    #   Session properties
    if my.name = "active"
        pal.realname = "s_session->active"
        return "integer"
    endif
    if my.name = "class_id"
        pal.realname = "s_session->class_id"
        return "integer"
    endif
    if my.name = "consumer_tag"
        pal.realname = "s_session->consumer_tag"
        return "string"
    endif
    if my.name = "delivery_tag"
        pal.realname = "s_session->delivery_tag"
        return "integer"
    endif
    if my.name = "exchange"
        pal.realname = "s_session->exchange"
        return "string"
    endif
    if my.name = "lease"
        pal.realname = "s_session->lease"
        return "string"
    endif
    if my.name = "message_count"
        pal.realname = "s_session->message_count"
        return "integer"
    endif
    if my.name = "method_id"
        pal.realname = "s_session->method_id"
        return "integer"
    endif
    if my.name = "queue"
        pal.realname = "s_session->queue"
        return "string"
    endif
    if my.name = "reply_code"
        pal.realname = "s_session->reply_code"
        return "integer"
    endif
    if my.name = "reply_text"
        pal.realname = "s_session->reply_text"
        return "string"
    endif
    if my.name = "routing_key"
        pal.realname = "s_session->routing_key"
        return "string"
    endif

    #   Connection properties
    if my.name = "channel_max"
        pal.realname = "s_connection->channel_max"
        return "integer"
    endif
    if my.name = "class_id"
        pal.realname = "s_connection->class_id"
        return "integer"
    endif
    if my.name = "frame_max"
        pal.realname = "s_connection->frame_max"
        return "integer"
    endif
    if my.name = "heartbeat"
        pal.realname = "s_connection->heartbeat"
        return "integer"
    endif
    if my.name = "known_hosts"
        pal.realname = "s_connection->known_hosts"
        return "string"
    endif
    if my.name = "method_id"
        pal.realname = "s_connection->method_id"
        return "integer"
    endif
    if my.name = "reply_code"
        pal.realname = "s_connection->reply_code"
        return "integer"
    endif
    if my.name = "reply_text"
        pal.realname = "s_connection->reply_text"
        return "string"
    endif
    if my.name = "server_copyright"
        pal.realname = "s_connection->server_copyright"
        return "string"
    endif
    if my.name = "server_host"
        pal.realname = "s_connection->server_host"
        return "string"
    endif
    if my.name = "server_information"
        pal.realname = "s_connection->server_information"
        return "string"
    endif
    if my.name = "server_platform"
        pal.realname = "s_connection->server_platform"
        return "string"
    endif
    if my.name = "server_port"
        pal.realname = "s_connection->server_port"
        return "string"
    endif
    if my.name = "server_product"
        pal.realname = "s_connection->server_product"
        return "string"
    endif
    if my.name = "server_version"
        pal.realname = "s_connection->server_version"
        return "string"
    endif
    if my.name = "version_major"
        pal.realname = "s_connection->version_major"
        return "integer"
    endif
    if my.name = "version_minor"
        pal.realname = "s_connection->version_minor"
        return "integer"
    endif

    #   Script variables
    for pal.variable where name = my.name
        pal.realname = "$(my.name:c)"
        return type
    endfor
    echo "'$(my.name)' is not a connection or session property, or variable"
    return ""
endfunction

function strvalue (property)
    my.property = string.justify (my.property? '', 0)
    if defined (string.locate (my.property, "$"))
        return 's_tpl ("' + my.property + '")'
    else
        return '"' + my.property + '"'
    endif
endfunction

function intvalue (property)
    #   Translate into variable name if property is $name
    my.property ?= "0"
    if string.substr (my.property,0,,1) = '$'
        my.variable = string.substr (my.property,1)
        my.metat = get_field_realname (my.variable)
        if my.metat = "integer" | my.metat = "char"
            return pal.realname
        elsif my.metat = "string"
            return 'atol (' + pal.realname + ')'
        endif
    else
        return my.property
    endif
endfunction


################################   SERVER

.macro produce_server ()
    if (opt_animate)
        icl_console_print ("<server name = \\"%s\\"/>", $(strvalue (name)));
    if (server_process) {
        ipr_process_destroy (&server_process);
        apr_sleep (2000 * 1000);        //  Wait for server to close correctly
    }
.   if defined (.port)
    server_process = ipr_process_new (
        $(strvalue (name + " --port " + port)), NULL, $(strvalue (stdout)), $(strvalue (stderr)));
.   else
    server_process = ipr_process_new (
        $(strvalue (name)), NULL, $(strvalue (stdout)), $(strvalue (stderr)));
.   endif
    ipr_process_start (server_process, $(strvalue ([where])));

    while (!ipr_net_ping (server_name, "$(port?'5672')"))
        apr_sleep (500 * 1000);
.endmacro


################################   TIMER

.macro produce_timer ()
.   if action = "reset"
    s_start_time = apr_time_now ();
    s_elapsed = 0;
.   elsif action = "show"
    icl_console_print ("I: elapsed time:%ld msecs",
        (long) ((s_elapsed + apr_time_now () - s_start_time) / 1000));
.   endif
.endmacro


################################   SET

.macro produce_set ()
.   using_reserved = 0
.   if name = "active"
.       echo "W: 'active' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "reply_code"
.       echo "W: 'reply_code' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "reply_text"
.       echo "W: 'reply_text' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "class_id"
.       echo "W: 'class_id' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "method_id"
.       echo "W: 'method_id' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "queue"
.       echo "W: 'queue' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "message_count"
.       echo "W: 'message_count' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "consumer_tag"
.       echo "W: 'consumer_tag' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "exchange"
.       echo "W: 'exchange' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "routing_key"
.       echo "W: 'routing_key' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "delivery_tag"
.       echo "W: 'delivery_tag' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "lease"
.       echo "W: 'lease' is a session field, you don't want to use it as a variable"
.   endif
.   if name = "version_major"
.       echo "W: 'version_major' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "version_minor"
.       echo "W: 'version_minor' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "channel_max"
.       echo "W: 'channel_max' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "frame_max"
.       echo "W: 'frame_max' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "heartbeat"
.       echo "W: 'heartbeat' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "known_hosts"
.       echo "W: 'known_hosts' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "reply_code"
.       echo "W: 'reply_code' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "reply_text"
.       echo "W: 'reply_text' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "class_id"
.       echo "W: 'class_id' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "method_id"
.       echo "W: 'method_id' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "server_host"
.       echo "W: 'server_host' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "server_port"
.       echo "W: 'server_port' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "server_product"
.       echo "W: 'server_product' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "server_version"
.       echo "W: 'server_version' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "server_platform"
.       echo "W: 'server_platform' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "server_copyright"
.       echo "W: 'server_copyright' is a connection field, you don't want to use it as a variable"
.   endif
.   if name = "server_information"
.       echo "W: 'server_information' is a connection field, you don't want to use it as a variable"
.   endif
    if (opt_animate)
        icl_console_print ("<set name = \\"$(name)\\"/>");
.   if type = "string"
    icl_mem_free ($(name:c));
.       if defined (cmdline)
    $(name:c) = icl_mem_strdup (opt_$(name:c));
.       else
    $(name:c) = icl_mem_strdup ($(strvalue (value)));
.       endif
    ipr_dict_assume (s_symbols, "$(name)", $(name:c));
.   else
.       if defined (cmdline)
    $(name:c) = atoi (opt_$(name:c));
.       else
    $(name:c) = $(intvalue (.value));
.       endif
    ipr_dict_assume_fmt (s_symbols, "$(name)", "%d", $(name:c));
.   endif
.endmacro


################################   INC

.macro produce_inc ()
    if (opt_animate)
        icl_console_print ("<inc name = \\"$(name)\\"/>");
    $(name:c)++;
    ipr_dict_assume_fmt (s_symbols, "$(name)", "%d", $(name:c));
.endmacro


################################   DEC

.macro produce_dec ()
    if (opt_animate)
        icl_console_print ("<dec name = \\"$(name)\\"/>");
    if (--$(name:c) < 0) {
        icl_console_print ("E: '$(name)' went negative - aborting");
        goto exit_failure;
    }
    else
        ipr_dict_assume_fmt (s_symbols, "$(name)", "%d", $(name:c));
.endmacro


################################   READ

.macro produce_read ()
    {
    if (opt_animate)
        icl_console_print ("<read name = \\"$(name)\\"/>");

.   if defined (.prompt)
    fprintf (stdout, "$(prompt)");
.   endif
    if ($(name:c))
        icl_mem_free ($(name:c));
    $(name:c) = icl_mem_alloc (1024);
    fgets ($(name:c), 1024, stdin);
    //  Truncate trailing newline
    $(name:c) [strlen ($(name:c)) - 1] = 0;
    ipr_dict_assume (s_symbols, "$(name)", $(name:c));
    }
.endmacro


################################   RANDOM

.macro produce_random ()
    if (opt_animate)
        icl_console_print ("<random name = \\"$(name)\\"/>");
    $(name:c) = ((rand () % ($(intvalue (.max)) - $(intvalue (.min))))) + $(intvalue (.min));
    ipr_dict_assume_fmt (s_symbols, "$(name)", "%d", $(name:c));
.endmacro


################################   ECHO

.macro produce_echo
    if (opt_animate)
        icl_console_print ("<echo />");
.   if trace
    if (trace_level >= $([0].trace))
        puts ($(strvalue (.)));
        fflush (stdout);
.   else
        puts ($(strvalue (.)));
        fflush (stdout);
.   endif
.endmacro


################################   ASSERT

function get_condition_expr
    my.metat = get_field_realname (name)

    #   Provide useful defaults for the test and value
    if !defined ([0].test)
        if defined ([0].value)
            .test = "eq"
        else
            .test = "ne"
            if my.metat = "integer"
                .value = "0"
            elsif my.metat = "char"
                .value = " "
            else
                .value = ""
            endif
        endif
    elsif !defined ([0].value)
        abort "E: conditional block needs a value"
    endif

    if my.metat = "integer"
        if    test = "eq"
            .expr = "$(realname) == $(intvalue (.value))"
        elsif test = "ne"
            .expr = "$(realname) != $(intvalue (.value))"
        elsif test = "gt"
            .expr = "$(realname) > $(intvalue (.value))"
        elsif test = "lt"
            .expr = "$(realname) < $(intvalue (.value))"
        elsif test = "ge"
            .expr = "$(realname) >= $(intvalue (.value))"
        elsif test = "le"
            .expr = "$(realname) <= $(intvalue (.value))"
        endif

    elsif my.metat = "char"
        if    test = "eq"
            .expr = "$(realname) == '$(.value)'"
        elsif test = "ne"
            .expr = "$(realname) != '$(.value)'"
        elsif test = "gt"
            .expr = "$(realname) > '$(.value)'"
        elsif test = "lt"
            .expr = "$(realname) < '$(.value)'"
        elsif test = "ge"
            .expr = "$(realname) >= '$(.value)'"
        elsif test = "le"
            .expr = "$(realname) <= '$(.value)'"
        endif

    elsif my.metat = "string"
        my.value = "$(strvalue (.value))"
        if    test = "eq"
            .expr = 'streq ($(realname), $(my.value))'
        elsif test = "ne"
            .expr = 'strneq ($(realname), $(my.value))'
        elsif test = "gt"
            .expr = 'strcmp ($(realname), $(my.value)) > 0'
        elsif test = "lt"
            .expr = 'strcmp ($(realname), $(my.value)) < 0'
        elsif test = "ge"
            .expr = 'strcmp ($(realname), $(my.value)) >= 0'
        elsif test = "le"
            .expr = 'strcmp ($(realname), $(my.value)) <= 0'
        endif
    endif
endfunction

function produce_assert
    get_condition_expr ()
    >    if (opt_animate)
    >        icl_console_print ("<assert />");
    >    if (!($(expr))) {
    if defined ([0].)
        >         icl_console_print ($(strvalue (.)));
    endif
    >        icl_console_print ("E: assertion '$(string.replace(expr, '"|\\"'))' failed at line number %d", __LINE__);
    >        goto exit_failure;
    >    }
endfunction


################################   ABORT

.macro produce_abort
    if (opt_animate)
        icl_console_print ("<echo />");
    icl_console_print ($(strvalue (.)));
    goto exit_failure;
.endmacro


################################   EXIT

.macro produce_exit
    if (opt_animate)
        icl_console_print ("<exit />");
    main_rc = $(status);
    goto finished;
.endmacro


################################   REPEAT

function produce_repeat_header
    >
    if defined ([0].progress)
    >    fprintf (stderr, ".");
    >    fflush  (stderr);
    endif
    if defined ([0].times)
        >    for ($(counter:c) = 0; $(counter:c) < $(intvalue (times)); $(counter:c)++) {
    else
        >    for ($(counter:c) = 0;; $(counter:c)++) {
    endif
    if defined ([0].progress)
        >        static int
        >            progress_indicator = 0;
    endif
    >        if (opt_animate)
    >            icl_console_print ("<repeat>");
    if show_counter
        >        ipr_dict_assume_fmt (s_symbols, "$(counter)", "%d", $(counter:c));
    endif
    >        if (s_connection_interrupt ())
    >            goto finished;
    if failover?0
        >        if (s_session && s_connection_failed ())
        >            goto exit_failover_$(pal.session_index);
    else
        >        if (s_session && !s_connection_alive ())
        >            break;
    endif
endfunction

function produce_repeat_footer
    if defined ([0].progress)
        >        if (++progress_indicator == $(progress)) {
        >            progress_indicator = 0;
        >            fprintf (stderr, ".");
        >            fflush  (stderr);
        >        }
    endif
    >        if (opt_animate)
    >            icl_console_print ("</repeat>");
    >    }
    if defined ([0].progress)
    >    fprintf (stderr, "\\n");
    >    fflush  (stderr);
    endif
endfunction


################################   WHILE

function produce_while_header
    get_condition_expr ()
    >
    if defined ([0].counter)
    >    $(.counter:c) = 0;
    >    ipr_dict_assume_fmt (s_symbols, "$(counter)", "%d", $(counter:c));
    endif
    if defined ([0].progress)
    >    fprintf (stderr, ".");
    >    fflush  (stderr);
    endif
    >    while ($(expr)) {
    if defined ([0].progress)
        >        static int
        >            progress_indicator = 0;
    endif
    >        if (opt_animate)
    >            icl_console_print ("<while>");
    >        if (s_connection_interrupt ())
    >            goto finished;
    if failover?0
        >        if (s_session && s_connection_failed ())
        >            goto exit_failover_$(pal.session_index);
    else
        >        if (s_session && !s_connection_alive ())
        >            break;
    endif
    if defined ([0].counter)
    >        $(.counter:c)++;
    >        ipr_dict_assume_fmt (s_symbols, "$(counter)", "%d", $(counter:c));
    endif
endfunction

function produce_while_footer
    if defined ([0].progress)
        >        if (++progress_indicator == $(progress)) {
        >            progress_indicator = 0;
        >            fprintf (stderr, ".");
        >            fflush  (stderr);
        >        }
    endif
    >        if (opt_animate)
    >            icl_console_print ("</while>");
    >    }
    if defined ([0].progress)
    >    fprintf (stderr, "\\n");
    >    fflush  (stderr);
    endif
endfunction


################################   BREAK

function produce_break
    >        if (opt_animate)
    >            icl_console_print ("<break/>");
    >        break;
endfunction


################################   IF

function produce_if_header
    get_condition_expr ()
    >
    >    if ($(expr)) {
    >        if (opt_animate)
    >            icl_console_print ("<if>");
endfunction

function produce_if_footer
    >        if (opt_animate)
    >            icl_console_print ("</if>");
    >    }
endfunction


################################   ELSE

function produce_else_header
    >    else {
    >        if (opt_animate)
    >            icl_console_print ("<else>");
endfunction

function produce_else_footer
    >        if (opt_animate)
    >            icl_console_print ("</else>");
    >    }
endfunction


################################   ELSIF

function produce_elsif_header
    get_condition_expr ()
    >    else
    >    if ($(expr)) {
    >        if (opt_animate)
    >            icl_console_print ("<elsif>");
endfunction

function produce_elsif_footer
    >        if (opt_animate)
    >            icl_console_print ("</elsif>");
    >    }
endfunction


################################   WAIT

function produce_wait
    >    if (opt_animate)
    >        icl_console_print ("<wait/>");
    >    if (s_session)
    >        rc = demo_client_session_wait (s_session, $(intvalue (timeout)));
    >    else
    >    if (s_connection)
    >        rc = demo_client_connection_wait (s_connection, $(intvalue (timeout)));
    >    else {
    >        apr_sleep ($(intvalue (timeout)) * 1000);
    >        rc = 0;
    >    }
    >    if (s_connection_interrupt ())
    >        goto finished;
    if failover?0
        >    if (s_connection_failed ())
        >        goto exit_failover_$(pal.session_index);
        >    else
    endif
    >    if (rc) {
    >        s_report_error ();
    >        goto exit_failure;
    >    }
endfunction


################################   SLEEP

function produce_sleep
    >    if (opt_animate)
    >        icl_console_print ("<sleep/>");
    >    apr_sleep ($(intvalue (timeout)) * 1000);
    >    if (s_connection_interrupt ())
    >        goto finished;
    if failover?0
        >    if (s_connection_failed ())
        >        goto exit_failover_$(pal.session_index);
    endif
endfunction


################################   SESSION

.macro produce_session_header
    //
    //  Session script
    FOREVER {                      //  Enclosing session_$(pal.session_index) scope

    if (opt_animate)
        icl_console_print ("<session>");
    if (opt_execute)
        fgetc (stdin);

.   if defined (server)
    rc = s_establish_session ("$(server)", instance_name, trace_level, "$(virtual_host)", $(timeout));
.   else
    rc = s_establish_session (server_name, instance_name, trace_level, "$(virtual_host)", $(timeout));
.   endif
    if (rc)
        goto exit_failure;
.   if direct = 1
    s_connection->direct = TRUE;
.   endif
.endmacro

.macro produce_session_footer
    if (opt_animate)
        icl_console_print ("</session>");

    break;                         //  By default, run session just once
.   if failover?0
    //  Try once more to connect to all listed servers
    exit_failover_$(pal.session_index):
        icl_console_print ("W: connection to server was lost, failing over");
        demo_client_session_destroy (&s_session);
        demo_client_connection_destroy (&s_connection);
        apr_sleep ($(failover) * 1000);
        continue;                  //  Start session once again
.   endif
    }                              //  Enclosing session_$(pal.session_index) scope
    //  Clean exit from session block, disconnect from server
    demo_client_session_destroy (&s_session);
    demo_client_connection_destroy (&s_connection);
.endmacro


################################   METHODS


.macro produce_channel_flow
    //
    //  channel.flow
    {

        if (opt_animate)
            icl_console_print ("<channel_flow/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_channel_flow (
            s_session,                  //  Session reference
            $(intvalue (.active)));     //  start/stop content frames
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_channel_flow_ok
    //
    //  channel.flow_ok
    {

        if (opt_animate)
            icl_console_print ("<channel_flow_ok/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_channel_flow_ok (
            s_session,                  //  Session reference
            $(intvalue (.active)));     //  current flow setting
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_exchange_declare
    //
    //  exchange.declare
    {

        if (opt_animate)
            icl_console_print ("<exchange_declare/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_exchange_declare (
            s_session,                  //  Session reference
            $(strvalue (.exchange)),    //  exchange name
            $(strvalue (.type)),        //  exchange class
            $(intvalue (.passive)),     //  do not create exchange
            $(intvalue (.durable)),     //  request a durable exchange
            $(intvalue (.auto_delete)));  //  auto-delete when unused
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_exchange_delete
    //
    //  exchange.delete
    {

        if (opt_animate)
            icl_console_print ("<exchange_delete/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_exchange_delete (
            s_session,                  //  Session reference
            $(strvalue (.exchange)),    //  exchange name
            $(intvalue (.if_unused)));  //  delete only if unused
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_queue_declare
    //
    //  queue.declare
    {

        if (opt_animate)
            icl_console_print ("<queue_declare/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_queue_declare (
            s_session,                  //  Session reference
            $(strvalue (.queue)),       //  queue name
            $(intvalue (.passive)),     //  do not create queue
            $(intvalue (.durable)),     //  request a durable queue
            $(intvalue (.exclusive)),   //  request an exclusive queue
            $(intvalue (.auto_delete)));  //  auto-delete queue when unused
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_queue_bind
    //
    //  queue.bind
    {
        asl_field_list_t
            *field_list = NULL;
        icl_longstr_t
            *arguments_table = NULL;

        if (opt_animate)
            icl_console_print ("<queue_bind/>");
        if (opt_execute)
            fgetc (stdin);

        //  Build arguments field as necessary
        field_list = asl_field_list_new (NULL);
.   for arguments
.       for field
.           if type = "string"
        asl_field_new_string (field_list, "$(name)", $(strvalue (value)));
.           elsif type = "void"
        asl_field_new_void (field_list, "$(name)");
.           else
        asl_field_new_integer (field_list, "$(name)", $(intvalue (value)));
.           endif
.       endfor
.   endfor
        arguments_table = asl_field_list_flatten (field_list);
        asl_field_list_unlink (&field_list);

        rc = demo_client_session_queue_bind (
            s_session,                  //  Session reference
            $(strvalue (.queue)),       //  queue name
            $(strvalue (.exchange)),    //  exchange name
            arguments_table);           //  arguments for binding
        s_get_session_symbols ();
        icl_longstr_destroy (&arguments_table);
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_queue_purge
    //
    //  queue.purge
    {

        if (opt_animate)
            icl_console_print ("<queue_purge/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_queue_purge (
            s_session,                  //  Session reference
            $(strvalue (.queue)));      //  queue name
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_queue_delete
    //
    //  queue.delete
    {

        if (opt_animate)
            icl_console_print ("<queue_delete/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_queue_delete (
            s_session,                  //  Session reference
            $(strvalue (.queue)),       //  queue name
            $(intvalue (.if_unused)),   //  delete only if unused
            $(intvalue (.if_empty)));   //  delete only if empty
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_basic_consume
    //
    //  basic.consume
    {

        if (opt_animate)
            icl_console_print ("<basic_consume/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_basic_consume (
            s_session,                  //  Session reference
            $(strvalue (.queue)));      //  queue name
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_basic_cancel
    //
    //  basic.cancel
    {

        if (opt_animate)
            icl_console_print ("<basic_cancel/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_basic_cancel (
            s_session,                  //  Session reference
            $(strvalue (.consumer_tag)));  //  consumer tag
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_basic_publish
    //
    //  basic.publish
    {

        if (opt_animate)
            icl_console_print ("<basic_publish/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_basic_publish (
            s_session,                  //  Session reference
            basic_content,              //  Message content
            $(strvalue (.exchange)),    //  exchange name
            $(strvalue (.routing_key)));  //  Message routing key
        send_count++;                   //  For transfer speed calculations
        send_bytes += s_body_size;
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro
.macro produce_basic_get
    //
    //  basic.get
    {

        if (opt_animate)
            icl_console_print ("<basic_get/>");
        if (opt_execute)
            fgetc (stdin);

        rc = demo_client_session_basic_get (
            s_session,                  //  Session reference
            $(strvalue (.queue)));      //  queue name
        s_get_session_symbols ();
    if (s_connection_interrupt ())
        goto finished;
.   if failover?0
    if (s_connection_failed ())
        goto exit_failover_$(pal.session_index);    //  Clean death - failover
.   else
    if (!s_connection_alive ()) {
        icl_console_print ("E: connection was closed unexpectedly");
        goto exit_failure;
    }
.   endif
        if (rc) {
            s_report_error ();
            goto exit_failure;
        }
    }
.endmacro


################################   CONTENT

.macro produce_basic_content
    //
    //  Create content
    {
        ipr_bucket_t
            *bucket = NULL;             //  Content bucket
.       if defined ([0].exec)
        ipr_process_t
            *process;                   //  Process that we run
.           if headers = 1
        FILE
            *file_stream = NULL;        //  Stdout file returned by command
        size_t
            last_posn,                  //  Last position in file
            file_size;                  //  Full size of stdout
        icl_shortstr_t
            header;                     //  Header line
        ipr_regexp_t
            *regexp;                    //  Compiled regexp
        char
            *name = NULL,               //  Field name
            *value = NULL;              //  Field value
.           endif
.       endif
        icl_shortstr_t
            timestamp;                  //  Formatted timestamp value
        asl_field_list_t
            *headers_list = NULL;
        icl_longstr_t
            *headers_table = NULL;

        if (opt_animate)
            icl_console_print ("<basic_content/>");
.       if defined ([0].exec)
        //  Save content body to stdin file
        if (basic_content)
            demo_content_basic_save_body (basic_content, "$(pal.name).in");
        else
            ipr_file_truncate ("$(pal.name).in");

.       endif
        //  Create new content object
        demo_content_basic_unlink (&basic_content);
        basic_content = demo_content_basic_new ();

        //  Set content properties
.   if defined (.content_type)
        demo_content_basic_set_content_type (basic_content, $(strvalue (.content_type)));
.   endif
.   if defined (.content_encoding)
        demo_content_basic_set_content_encoding (basic_content, $(strvalue (.content_encoding)));
.   endif
        headers_list = asl_field_list_new (NULL);
.   for headers
.       for field
.           if field.type = "string"
        asl_field_new_string (headers_list, "$(name)", $(strvalue (value)));
.           elsif field.type = "integer"
        asl_field_new_integer (headers_list, "$(name)", $(value));
.           elsif field.type = "void"
        asl_field_new_void (headers_list, "$(name)");
.           endif
.       endfor
.   endfor
.   if defined (.reply_to)
        demo_content_basic_set_reply_to (basic_content, $(strvalue (.reply_to)));
.   endif
.   if defined (.message_id)
        demo_content_basic_set_message_id (basic_content, $(strvalue (.message_id)));
.   endif
.   if defined (.correlation_id)
        demo_content_basic_set_correlation_id (basic_content, $(strvalue (.correlation_id)));
.   endif
.
.       if defined ([0].exec)
        //  Get content body by running the command '$(exec)'
        process = ipr_process_new ($(strvalue (exec)), "$(pal.name).in", "$(pal.name).out", NULL);
        ipr_process_start (process, ".");
        ipr_process_wait  (process, TRUE);
        rc = process->exitcode;
        ipr_process_destroy (&process);
        if (rc == -1) {
            icl_console_print ("E: '%s' not found", $(strvalue (exec)));
            goto exit_failure;
        }
        else
        if (rc) {
            icl_console_print ("E: '%s' exited with status value %d", $(strvalue (exec)), rc);
            goto exit_failure;
        }
.           if headers = 0
        bucket = ipr_file_slurp ("$(pal.name).out");
.           else
        //  Parse headers and then body, ended by a blank line
        file_stream = fopen ("$(pal.name).out", "rb");
        assert (file_stream);
        last_posn = 0;                  //  Start of next line in file

        //  Read until blank line or end of file
        regexp = ipr_regexp_new ("^([^:]+):`s*(.*)");
        while (icl_shortstr_read (header, file_stream)) {
            if (ipr_regexp_match (regexp, header, &name, &value) == 2) {
                last_posn = ftell (file_stream);
                ipr_str_lower (name);
                ipr_str_clean (name, '-', '_');
                if (streq (name, "content_type"))
                    demo_content_basic_set_content_type (basic_content, value);
                else
                if (streq (name, "content_encoding"))
                    demo_content_basic_set_content_encoding (basic_content, value);
                else
                if (strlen (name) > 9
                &&  memcmp (name, "x_headers", 9) == 0)
                    asl_field_new_string (headers_list, name + 9, value);
                else
                if (streq (name, "reply_to"))
                    demo_content_basic_set_reply_to (basic_content, value);
                else
                if (streq (name, "message_id"))
                    demo_content_basic_set_message_id (basic_content, value);
                else
                if (streq (name, "correlation_id"))
                    demo_content_basic_set_correlation_id (basic_content, value);
                else
                    icl_console_print ("Invalid message property '%s' - discarded", name);
            }
            else
            if (last_posn == 0) {
                //  If first line does not match regexp, we don't have headers
                fseek (file_stream, 0, SEEK_SET);
                break;
            }
        }
        ipr_regexp_destroy (&regexp);
        icl_mem_free (name);
        icl_mem_free (value);

        file_size = (size_t) (ipr_file_size ("$(pal.name).out") - last_posn);
        if (file_size > IPR_BUCKET_MAX_SIZE)
            file_size = IPR_BUCKET_MAX_SIZE;

        bucket = ipr_bucket_new (file_size);
        bucket->cur_size = file_size;
        if (fread (bucket->data, file_size, 1, file_stream) != 1)
            ipr_bucket_unlink (&bucket);
        if (bucket) {
            demo_content_basic_record_body (basic_content, bucket);
            ipr_bucket_unlink (&bucket);
        }
.           endif
        ipr_file_delete ("$(pal.name).in");
        ipr_file_delete ("$(pal.name).out");
.
.       elsif defined ([0].read)
        //  Set content body by reading the file '$(read)'
        bucket = ipr_file_slurp ($(strvalue (read)));
        if (!bucket) {
            icl_console_print ("E: cannot read content body from '%s'", $(strvalue (read)));
            goto exit_failure;
        }
        if (bucket) {
            demo_content_basic_record_body (basic_content, bucket);
            ipr_bucket_unlink (&bucket);
        }
.
.       else
        //  Set content as specified, or repeat to required size
        {
.           if defined ([0].)
        char
            *content_string = NULL;     //  String content, if any
.           endif
        size_t
            content_size,               //  Total/remaining content size
            bucket_size;                //  Size of current bucket

.           if defined ([0].)
        content_string = $(strvalue (.));
        content_size = $(size??intvalue (.size)?'strlen (content_string)');
.           else
        content_size = $(intvalue (.size?1024));
.           endif
        for (;
             (bucket_size = (content_size > IPR_BUCKET_MAX_SIZE) ?
                 IPR_BUCKET_MAX_SIZE : content_size);
             content_size -= bucket_size) {
.           if defined ([0].)
            //  Set content body from a string
            bucket = ipr_bucket_new (bucket_size);
            ipr_bucket_fill_repeat (bucket,
                (byte *) content_string, strlen (content_string), bucket_size);
            //  Text is printable string, so null-terminate it
            bucket->data [bucket->cur_size] = 0;
.
.           elsif [0].fill = "random"
            //  Set content body from a bucket of randomized data
            bucket = ipr_bucket_new (bucket_size);
            ipr_bucket_fill_random (bucket, bucket_size);
.
.           elsif [0].fill = "null" | [0].fill = "repeat"
            //  Set content body from a bucket of null data
            bucket = ipr_bucket_new (bucket_size);
            ipr_bucket_fill_null (bucket, bucket_size);
.
.           endif
            assert (bucket);
            demo_content_basic_record_body (basic_content, bucket);
            ipr_bucket_unlink (&bucket);
        }
        }
.
.       endif

        s_body_size = (size_t) basic_content->body_size;
        //  Insert timestamps
        icl_shortstr_fmt (timestamp, "%ld", (long) (s_start_time / 1000000));
        asl_field_new_string (headers_list, "X-Timestamp-Base", timestamp);
        icl_shortstr_fmt (timestamp, "%ld", (long) ((apr_time_now () - s_start_time) / 1000));
        asl_field_new_string (headers_list, "X-Timestamp-Delta", timestamp);
        //  Save headers field table
        headers_table = asl_field_list_flatten (headers_list);
        asl_field_list_unlink (&headers_list);
        demo_content_basic_set_headers (basic_content, headers_table);
        icl_longstr_destroy (&headers_table);
    }
.endmacro

################################   ARRIVED / RETURNED

.macro get_basic_content_properties
        //  Standard content fields
        s_body_size = (size_t) basic_content->body_size;
        s_get_session_symbols ();

        //  Get content properties
        ipr_dict_assume     (s_symbols, "content_type", basic_content->content_type);
        ipr_dict_assume     (s_symbols, "content_encoding", basic_content->content_encoding);

        field_list = asl_field_list_new (basic_content->headers);
        field = asl_field_list_first (field_list);
        while (field) {
            icl_shortstr_fmt (field_name, "headers-%s", field->name);
            ipr_dict_assume (s_symbols, field_name, asl_field_string (field));
            if (streq (field->name, "X-Timestamp-Base"))
                time_base = atol (asl_field_string (field));
            else
            if (streq (field->name, "X-Timestamp-Delta")
            &&  time_base == (long) (s_start_time / 1000000)) {
                latency = (long) ((apr_time_now () - s_start_time) / 1000) - atol (asl_field_string (field));
                ipr_stat_record (latencies, (double) latency);
            }
            field = asl_field_list_next (&field);
        }
        asl_field_list_unlink (&field_list);
        ipr_dict_assume     (s_symbols, "reply_to", basic_content->reply_to);
        ipr_dict_assume     (s_symbols, "message_id", basic_content->message_id);
        ipr_dict_assume     (s_symbols, "correlation_id", basic_content->correlation_id);
.endmacro

.macro produce_basic_arrived_header (which)
    content_processed = 0;
    while (demo_client_session_get_basic_$(my.which)_count (s_session)) {
        asl_field_list_t
            *field_list;                //  Field table from content
        asl_field_t
            *field;                     //  One field from field table
        icl_shortstr_t
            field_name;                 //  Name of field in table
        long
            time_base = 0,              //  When script was started
            latency;                    //  Message latency, msecs
        asl_reader_t
            reader;                     //  Body reader
        ipr_bucket_t
            *bucket;                    //  Body bucket
        char
            *body_text;                 //  Content body text

        if (opt_animate)
            icl_console_print ("<basic_$(my.which)>");

        demo_content_basic_unlink (&basic_content);
        basic_content = demo_client_session_basic_$(my.which) (s_session);
        assert (basic_content);
.   get_basic_content_properties ()
        recv_count++;                   //  For transfer speed calculations
        recv_bytes += s_body_size;
        content_processed++;

        //  Create body_text symbol from body of message
        demo_content_basic_set_reader (basic_content, &reader, 65535);
        bucket = demo_content_basic_replay_body (basic_content, &reader);
        if (bucket) {
            body_text = icl_mem_alloc (bucket->cur_size + 1);
            memcpy (body_text, bucket->data, bucket->cur_size);
            body_text [bucket->cur_size] = 0;
            ipr_dict_assume (s_symbols, "body_text", ipr_str_filter (body_text));
            icl_mem_free (body_text);
        }
        else
            ipr_dict_assume (s_symbols, "body_text", "(empty)");
        ipr_bucket_unlink (&bucket);
.endmacro

function produce_basic_arrived_footer (which)
    >    if (opt_animate)
    >        icl_console_print ("</basic_$(my.which)>");
    >    }
endfunction

################################   EMPTY

function produce_empty_header
    >    if (content_processed == 0) {
    >        if (opt_animate)
    >            icl_console_print ("<empty>");
endfunction

function produce_empty_footer
    >        if (opt_animate)
    >            icl_console_print ("</empty>");
    >    }
endfunction
