#   'Parse' engine for demo_pal
#
#   Generated by iMatix GSL/4
#   
#   Copyright (c) 1996-2009 iMatix Corporation
#   
#   This file is licensed under the GPL as follows:
#   
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
#   
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#   
#   For information on alternative licensing for OEMs, please contact
#   iMatix Corporation.
#

function parse_pal ([pal])
    my.entity = my.[pal]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_pal ? 0
       echo "<parse_pal location = \"$(my.location)\""
    endif

    pal.in_session = 0
    pal.name ?= file.basename (filename)
    if !defined (my.[pal].[abstract])
        my.[pal].[abstract] = "0"
    endif
    if defined (my.[pal].[abstract])
        if    my.[pal].[abstract] ?= "0"
        elsif my.[pal].[abstract] ?= "1"
        else
            parse_error ("Attribute 'abstract' has illegal value '$(0.[abstract]?)'$(my.location)")
        endif
    endif
    if !defined (my.[pal].[license])
        my.[pal].[license] = "gpl"
    endif
    if defined (my.[pal].[license])
        if    my.[pal].[license] ?= "bsd"
        elsif my.[pal].[license] ?= "gpl"
        else
            parse_error ("Attribute 'license' has illegal value '$(0.[license]?)'$(my.location)")
        endif
    endif
    if !defined (my.[pal].[target])
        my.[pal].[target] = "stdc"
    endif
    if !defined (my.[pal].[export])
        my.[pal].[export] = "default"
    endif
    if defined (my.[pal].[export])
        if    my.[pal].[export] ?= "none"
        elsif my.[pal].[export] ?= "default"
        elsif my.[pal].[export] ?= "before"
        elsif my.[pal].[export] ?= "after"
        else
            parse_error ("Attribute 'export' has illegal value '$(0.[export]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[pal]. where defined (name ()) as entity
        if    name () = "option"
        elsif name () = "inherit"
        elsif name () = "doc"
        elsif name () = "macro"
        elsif name () = "include"
        elsif name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[pal].[option] as [option]
        parse_option ([option])
    endfor

    for my.[pal].[inherit] as [inherit]
        parse_inherit ([inherit])
    endfor

    for my.[pal].[doc] as [doc]
        parse_doc ([doc])
    endfor

    for my.[pal].[macro] as [macro]
        parse_macro ([macro])
    endfor

    for my.[pal].[include] as [include]
        parse_include ([include])
    endfor

    for my.[pal].[session] as [session]
        parse_session ([session])
    endfor

    for my.[pal].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[pal].[server] as [server]
        parse_server ([server])
    endfor

    for my.[pal].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[pal].[set] as [set]
        parse_set ([set])
    endfor

    for my.[pal].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[pal].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[pal].[read] as [read]
        parse_read ([read])
    endfor

    for my.[pal].[random] as [random]
        parse_random ([random])
    endfor

    for my.[pal].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[pal].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[pal].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[pal].[while] as [while]
        parse_while ([while])
    endfor

    for my.[pal].[break] as [break]
        parse_break ([break])
    endfor

    for my.[pal].[if] as [if]
        parse_if ([if])
    endfor

    for my.[pal].[else] as [else]
        parse_else ([else])
    endfor

    for my.[pal].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[pal].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[pal].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[pal].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[pal].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[pal].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[pal].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[pal].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[pal].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[pal].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[pal].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[pal].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[pal].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[pal].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[pal].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[pal].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[pal].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[pal].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[pal].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[pal].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[pal].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[pal].[option] as [option] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <option name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[pal].[macro] as [macro] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <macro name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[pal].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[pal].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[pal].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[pal].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[pal].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[pal].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[pal].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_doc ([doc])
    my.entity = my.[doc]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_doc ? 0
       echo "<parse_doc location = \"$(my.location)\""
    endif

    for my.[doc]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_include ([include])
    my.entity = my.[include]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_include ? 0
       echo "<parse_include location = \"$(my.location)\""
    endif

    for my.[include]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_macro ([macro])
    my.entity = my.[macro]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_macro ? 0
       echo "<parse_macro location = \"$(my.location)\""
    endif

    if !defined (my.[macro].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
endfunction

function parse_scripting ([scripting])
    my.entity = my.[scripting]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_scripting ? 0
       echo "<parse_scripting location = \"$(my.location)\""
    endif

    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[scripting]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[scripting].[session] as [session]
        parse_session ([session])
    endfor

    for my.[scripting].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[scripting].[server] as [server]
        parse_server ([server])
    endfor

    for my.[scripting].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[scripting].[set] as [set]
        parse_set ([set])
    endfor

    for my.[scripting].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[scripting].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[scripting].[read] as [read]
        parse_read ([read])
    endfor

    for my.[scripting].[random] as [random]
        parse_random ([random])
    endfor

    for my.[scripting].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[scripting].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[scripting].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[scripting].[while] as [while]
        parse_while ([while])
    endfor

    for my.[scripting].[break] as [break]
        parse_break ([break])
    endfor

    for my.[scripting].[if] as [if]
        parse_if ([if])
    endfor

    for my.[scripting].[else] as [else]
        parse_else ([else])
    endfor

    for my.[scripting].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[scripting].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[scripting].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[scripting].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[scripting].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[scripting].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[scripting].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[scripting].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[scripting].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[scripting].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[scripting].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[scripting].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[scripting].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[scripting].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[scripting].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[scripting].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[scripting].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[scripting].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[scripting].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[scripting].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[scripting].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[scripting].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[scripting].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[scripting].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[scripting].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[scripting].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[scripting].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[scripting].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_session ([session])
    my.entity = my.[session]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_session ? 0
       echo "<parse_session location = \"$(my.location)\""
    endif

    if pal.in_session
        abort "E: session not allowed inside another session"
    endif
    pal.in_session = 1
    if !defined (my.[session].[virtual_host])
        my.[session].[virtual_host] = "/"
    endif
    if !defined (my.[session].[timeout])
        my.[session].[timeout] = "30000"
    endif
    if !defined (my.[session].[direct])
        my.[session].[direct] = "0"
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[session]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[session].[session] as [session]
        parse_session ([session])
    endfor

    for my.[session].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[session].[server] as [server]
        parse_server ([server])
    endfor

    for my.[session].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[session].[set] as [set]
        parse_set ([set])
    endfor

    for my.[session].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[session].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[session].[read] as [read]
        parse_read ([read])
    endfor

    for my.[session].[random] as [random]
        parse_random ([random])
    endfor

    for my.[session].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[session].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[session].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[session].[while] as [while]
        parse_while ([while])
    endfor

    for my.[session].[break] as [break]
        parse_break ([break])
    endfor

    for my.[session].[if] as [if]
        parse_if ([if])
    endfor

    for my.[session].[else] as [else]
        parse_else ([else])
    endfor

    for my.[session].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[session].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[session].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[session].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[session].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[session].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[session].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[session].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[session].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[session].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[session].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[session].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[session].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[session].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[session].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[session].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[session].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[session].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[session].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[session].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[session].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[session].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[session].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[session].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[session].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[session].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[session].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[session].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    pal.in_session = 0
endfunction

function parse_invoke ([invoke])
    my.entity = my.[invoke]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_invoke ? 0
       echo "<parse_invoke location = \"$(my.location)\""
    endif

    for pal.macro where name = .macro
        for . as child
            copy child to invoke
        endfor
    endfor
    if !defined (my.[invoke].[macro])
        parse_error ("Required attribute 'macro' not defined$(my.location)")
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[invoke]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[invoke].[session] as [session]
        parse_session ([session])
    endfor

    for my.[invoke].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[invoke].[server] as [server]
        parse_server ([server])
    endfor

    for my.[invoke].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[invoke].[set] as [set]
        parse_set ([set])
    endfor

    for my.[invoke].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[invoke].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[invoke].[read] as [read]
        parse_read ([read])
    endfor

    for my.[invoke].[random] as [random]
        parse_random ([random])
    endfor

    for my.[invoke].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[invoke].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[invoke].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[invoke].[while] as [while]
        parse_while ([while])
    endfor

    for my.[invoke].[break] as [break]
        parse_break ([break])
    endfor

    for my.[invoke].[if] as [if]
        parse_if ([if])
    endfor

    for my.[invoke].[else] as [else]
        parse_else ([else])
    endfor

    for my.[invoke].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[invoke].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[invoke].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[invoke].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[invoke].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[invoke].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[invoke].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[invoke].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[invoke].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[invoke].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[invoke].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[invoke].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[invoke].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[invoke].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[invoke].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[invoke].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[invoke].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[invoke].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[invoke].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[invoke].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[invoke].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[invoke].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[invoke].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[invoke].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[invoke].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[invoke].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[invoke].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[invoke].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_server ([server])
    my.entity = my.[server]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_server ? 0
       echo "<parse_server location = \"$(my.location)\""
    endif

    if !defined (my.[server].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[server].[stdout])
        my.[server].[stdout] = ""
    endif
    if !defined (my.[server].[stderr])
        my.[server].[stderr] = ""
    endif
    if !defined (my.[server].[where])
        my.[server].[where] = "."
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[server]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[server].[session] as [session]
        parse_session ([session])
    endfor

    for my.[server].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[server].[server] as [server]
        parse_server ([server])
    endfor

    for my.[server].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[server].[set] as [set]
        parse_set ([set])
    endfor

    for my.[server].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[server].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[server].[read] as [read]
        parse_read ([read])
    endfor

    for my.[server].[random] as [random]
        parse_random ([random])
    endfor

    for my.[server].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[server].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[server].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[server].[while] as [while]
        parse_while ([while])
    endfor

    for my.[server].[break] as [break]
        parse_break ([break])
    endfor

    for my.[server].[if] as [if]
        parse_if ([if])
    endfor

    for my.[server].[else] as [else]
        parse_else ([else])
    endfor

    for my.[server].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[server].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[server].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[server].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[server].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[server].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[server].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[server].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[server].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[server].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[server].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[server].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[server].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[server].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[server].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[server].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[server].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[server].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[server].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[server].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[server].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[server].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[server].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[server].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[server].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[server].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[server].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[server].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_timer ([timer])
    my.entity = my.[timer]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_timer ? 0
       echo "<parse_timer location = \"$(my.location)\""
    endif

    if !defined (my.[timer].[action])
        my.[timer].[action] = "reset"
    endif
    if defined (my.[timer].[action])
        if    my.[timer].[action] ?= "reset"
        elsif my.[timer].[action] ?= "show"
        else
            parse_error ("Attribute 'action' has illegal value '$(0.[action]?)'$(my.location)")
        endif
    endif
    for my.[timer]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_set ([set])
    my.entity = my.[set]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_set ? 0
       echo "<parse_set location = \"$(my.location)\""
    endif

    set.value ?= ""
    if !defined (set.type)
        if regexp.match ("^[0-9]+$", set.value)
            set.type = "integer"
        else
            set.type = "string"
        endif
    endif

    assume_variable (name, type, value)
    if defined (.cmdline)
        new pal.option
            option.name   = name
            option.type   = type
            option.value  = value
            option.switch = cmdline
        endnew
    endif
    if !defined (my.[set].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[set].[value])
        my.[set].[value] = ""
    endif
    if defined (my.[set].[type])
        if    my.[set].[type] ?= "string"
        elsif my.[set].[type] ?= "integer"
        else
            parse_error ("Attribute 'type' has illegal value '$(0.[type]?)'$(my.location)")
        endif
    endif
    for my.[set]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_inc ([inc])
    my.entity = my.[inc]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_inc ? 0
       echo "<parse_inc location = \"$(my.location)\""
    endif

    assume_variable (name, "integer", 0)
    if !defined (my.[inc].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    for my.[inc]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_dec ([dec])
    my.entity = my.[dec]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_dec ? 0
       echo "<parse_dec location = \"$(my.location)\""
    endif

    assume_variable (name, "integer", 0)
    if !defined (my.[dec].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    for my.[dec]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_read ([read])
    my.entity = my.[read]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_read ? 0
       echo "<parse_read location = \"$(my.location)\""
    endif

    read.value ?= ""
    read.type = "string"
    assume_variable (name, type, value)
    if !defined (my.[read].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    for my.[read]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_random ([random])
    my.entity = my.[random]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_random ? 0
       echo "<parse_random location = \"$(my.location)\""
    endif

    random.value ?= ""
    random.type = "integer"
    assume_variable (name, type, value)
    if !defined (my.[random].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[random].[min])
        my.[random].[min] = "0"
    endif
    if !defined (my.[random].[max])
        parse_error ("Required attribute 'max' not defined$(my.location)")
    endif
    for my.[random]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_echo ([echo])
    my.entity = my.[echo]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_echo ? 0
       echo "<parse_echo location = \"$(my.location)\""
    endif

    if !defined (my.[echo].[trace])
        my.[echo].[trace] = "0"
    endif
    for my.[echo]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_assert ([assert])
    my.entity = my.[assert]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_assert ? 0
       echo "<parse_assert location = \"$(my.location)\""
    endif

    if !defined (my.[assert].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if defined (my.[assert].[test])
        if    my.[assert].[test] ?= "eq"
        elsif my.[assert].[test] ?= "ne"
        elsif my.[assert].[test] ?= "gt"
        elsif my.[assert].[test] ?= "lt"
        elsif my.[assert].[test] ?= "ge"
        elsif my.[assert].[test] ?= "le"
        else
            parse_error ("Attribute 'test' has illegal value '$(0.[test]?)'$(my.location)")
        endif
    endif
    for my.[assert]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
        if defined (condition) & ! gsl.exec ("\$(("+condition+")?0)",1)
            my.entity.delete ()
        endif
endfunction

function parse_repeat ([repeat])
    my.entity = my.[repeat]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_repeat ? 0
       echo "<parse_repeat location = \"$(my.location)\""
    endif

    pal.nesting = (pal.nesting?0) + 1
    if defined ([0].counter)
        repeat.show_counter = 1
    else
        pal.counters = (pal.counters?0) + 1
        repeat.counter = "repeat_counter_$(pal.counters)"
        repeat.show_counter = 0
    endif
    counter = "$(counter:c)"
    assume_variable (counter, "integer", 0)
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[repeat]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[repeat].[session] as [session]
        parse_session ([session])
    endfor

    for my.[repeat].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[repeat].[server] as [server]
        parse_server ([server])
    endfor

    for my.[repeat].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[repeat].[set] as [set]
        parse_set ([set])
    endfor

    for my.[repeat].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[repeat].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[repeat].[read] as [read]
        parse_read ([read])
    endfor

    for my.[repeat].[random] as [random]
        parse_random ([random])
    endfor

    for my.[repeat].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[repeat].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[repeat].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[repeat].[while] as [while]
        parse_while ([while])
    endfor

    for my.[repeat].[break] as [break]
        parse_break ([break])
    endfor

    for my.[repeat].[if] as [if]
        parse_if ([if])
    endfor

    for my.[repeat].[else] as [else]
        parse_else ([else])
    endfor

    for my.[repeat].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[repeat].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[repeat].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[repeat].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[repeat].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[repeat].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[repeat].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[repeat].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[repeat].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[repeat].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[repeat].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[repeat].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[repeat].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[repeat].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[repeat].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[repeat].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[repeat].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[repeat].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[repeat].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[repeat].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[repeat].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[repeat].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[repeat].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[repeat].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[repeat].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[repeat].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[repeat].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[repeat].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    pal.nesting = pal.nesting - 1
endfunction

function parse_while ([while])
    my.entity = my.[while]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_while ? 0
       echo "<parse_while location = \"$(my.location)\""
    endif

    pal.nesting = (pal.nesting?0) + 1
    if defined ([0].counter)
        counter = "$(counter:c)"
        assume_variable (counter, "integer", 0)
    endif
    if !defined (my.[while].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if defined (my.[while].[test])
        if    my.[while].[test] ?= "eq"
        elsif my.[while].[test] ?= "ne"
        elsif my.[while].[test] ?= "gt"
        elsif my.[while].[test] ?= "lt"
        elsif my.[while].[test] ?= "ge"
        elsif my.[while].[test] ?= "le"
        else
            parse_error ("Attribute 'test' has illegal value '$(0.[test]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[while]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[while].[session] as [session]
        parse_session ([session])
    endfor

    for my.[while].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[while].[server] as [server]
        parse_server ([server])
    endfor

    for my.[while].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[while].[set] as [set]
        parse_set ([set])
    endfor

    for my.[while].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[while].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[while].[read] as [read]
        parse_read ([read])
    endfor

    for my.[while].[random] as [random]
        parse_random ([random])
    endfor

    for my.[while].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[while].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[while].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[while].[while] as [while]
        parse_while ([while])
    endfor

    for my.[while].[break] as [break]
        parse_break ([break])
    endfor

    for my.[while].[if] as [if]
        parse_if ([if])
    endfor

    for my.[while].[else] as [else]
        parse_else ([else])
    endfor

    for my.[while].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[while].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[while].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[while].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[while].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[while].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[while].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[while].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[while].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[while].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[while].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[while].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[while].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[while].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[while].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[while].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[while].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[while].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[while].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[while].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[while].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[while].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[while].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[while].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[while].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[while].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[while].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[while].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    pal.nesting = pal.nesting - 1
        if defined (condition) & ! gsl.exec ("\$(("+condition+")?0)",1)
            my.entity.delete ()
        endif
endfunction

function parse_if ([if])
    my.entity = my.[if]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_if ? 0
       echo "<parse_if location = \"$(my.location)\""
    endif

    if !defined (my.[if].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if defined (my.[if].[test])
        if    my.[if].[test] ?= "eq"
        elsif my.[if].[test] ?= "ne"
        elsif my.[if].[test] ?= "gt"
        elsif my.[if].[test] ?= "lt"
        elsif my.[if].[test] ?= "ge"
        elsif my.[if].[test] ?= "le"
        else
            parse_error ("Attribute 'test' has illegal value '$(0.[test]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[if]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[if].[session] as [session]
        parse_session ([session])
    endfor

    for my.[if].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[if].[server] as [server]
        parse_server ([server])
    endfor

    for my.[if].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[if].[set] as [set]
        parse_set ([set])
    endfor

    for my.[if].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[if].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[if].[read] as [read]
        parse_read ([read])
    endfor

    for my.[if].[random] as [random]
        parse_random ([random])
    endfor

    for my.[if].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[if].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[if].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[if].[while] as [while]
        parse_while ([while])
    endfor

    for my.[if].[break] as [break]
        parse_break ([break])
    endfor

    for my.[if].[if] as [if]
        parse_if ([if])
    endfor

    for my.[if].[else] as [else]
        parse_else ([else])
    endfor

    for my.[if].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[if].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[if].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[if].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[if].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[if].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[if].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[if].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[if].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[if].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[if].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[if].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[if].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[if].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[if].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[if].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[if].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[if].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[if].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[if].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[if].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[if].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[if].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[if].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[if].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[if].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[if].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[if].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
        if defined (condition) & ! gsl.exec ("\$(("+condition+")?0)",1)
            my.entity.delete ()
        endif
endfunction

function parse_else ([else])
    my.entity = my.[else]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_else ? 0
       echo "<parse_else location = \"$(my.location)\""
    endif

    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[else]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[else].[session] as [session]
        parse_session ([session])
    endfor

    for my.[else].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[else].[server] as [server]
        parse_server ([server])
    endfor

    for my.[else].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[else].[set] as [set]
        parse_set ([set])
    endfor

    for my.[else].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[else].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[else].[read] as [read]
        parse_read ([read])
    endfor

    for my.[else].[random] as [random]
        parse_random ([random])
    endfor

    for my.[else].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[else].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[else].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[else].[while] as [while]
        parse_while ([while])
    endfor

    for my.[else].[break] as [break]
        parse_break ([break])
    endfor

    for my.[else].[if] as [if]
        parse_if ([if])
    endfor

    for my.[else].[else] as [else]
        parse_else ([else])
    endfor

    for my.[else].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[else].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[else].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[else].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[else].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[else].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[else].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[else].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[else].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[else].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[else].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[else].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[else].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[else].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[else].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[else].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[else].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[else].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[else].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[else].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[else].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[else].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[else].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[else].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[else].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[else].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[else].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[else].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_elsif ([elsif])
    my.entity = my.[elsif]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_elsif ? 0
       echo "<parse_elsif location = \"$(my.location)\""
    endif

    if !defined (my.[elsif].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if defined (my.[elsif].[test])
        if    my.[elsif].[test] ?= "eq"
        elsif my.[elsif].[test] ?= "ne"
        elsif my.[elsif].[test] ?= "gt"
        elsif my.[elsif].[test] ?= "lt"
        elsif my.[elsif].[test] ?= "ge"
        elsif my.[elsif].[test] ?= "le"
        else
            parse_error ("Attribute 'test' has illegal value '$(0.[test]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[elsif]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[elsif].[session] as [session]
        parse_session ([session])
    endfor

    for my.[elsif].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[elsif].[server] as [server]
        parse_server ([server])
    endfor

    for my.[elsif].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[elsif].[set] as [set]
        parse_set ([set])
    endfor

    for my.[elsif].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[elsif].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[elsif].[read] as [read]
        parse_read ([read])
    endfor

    for my.[elsif].[random] as [random]
        parse_random ([random])
    endfor

    for my.[elsif].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[elsif].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[elsif].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[elsif].[while] as [while]
        parse_while ([while])
    endfor

    for my.[elsif].[break] as [break]
        parse_break ([break])
    endfor

    for my.[elsif].[if] as [if]
        parse_if ([if])
    endfor

    for my.[elsif].[else] as [else]
        parse_else ([else])
    endfor

    for my.[elsif].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[elsif].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[elsif].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[elsif].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[elsif].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[elsif].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[elsif].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[elsif].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[elsif].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[elsif].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[elsif].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[elsif].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[elsif].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[elsif].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[elsif].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[elsif].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[elsif].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[elsif].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[elsif].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[elsif].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[elsif].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[elsif].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[elsif].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[elsif].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[elsif].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[elsif].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[elsif].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[elsif].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
        if defined (condition) & ! gsl.exec ("\$(("+condition+")?0)",1)
            my.entity.delete ()
        endif
endfunction

function parse_wait ([wait])
    my.entity = my.[wait]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_wait ? 0
       echo "<parse_wait location = \"$(my.location)\""
    endif

    if !defined (my.[wait].[timeout])
        my.[wait].[timeout] = "0"
    endif
    for my.[wait]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_sleep ([sleep])
    my.entity = my.[sleep]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_sleep ? 0
       echo "<parse_sleep location = \"$(my.location)\""
    endif

    if !defined (my.[sleep].[timeout])
        parse_error ("Required attribute 'timeout' not defined$(my.location)")
    endif
    for my.[sleep]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_break ([break])
    my.entity = my.[break]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_break ? 0
       echo "<parse_break location = \"$(my.location)\""
    endif

    if (pal.nesting?0) = 0
        abort "E: break not valid outside a repeated block"
    endif
    for my.[break]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_abort ([abort])
    my.entity = my.[abort]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_abort ? 0
       echo "<parse_abort location = \"$(my.location)\""
    endif

    for my.[abort]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_exit ([exit])
    my.entity = my.[exit]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_exit ? 0
       echo "<parse_exit location = \"$(my.location)\""
    endif

    if !defined (my.[exit].[status])
        my.[exit].[status] = "0"
    endif
    for my.[exit]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_channel_flow ([channel_flow])
    my.entity = my.[channel_flow]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_channel_flow ? 0
       echo "<parse_channel_flow location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: channel_flow only valid in a session"
    endif
    for my.[channel_flow]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_channel_flow_ok ([channel_flow_ok])
    my.entity = my.[channel_flow_ok]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_channel_flow_ok ? 0
       echo "<parse_channel_flow_ok location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: channel_flow_ok only valid in a session"
    endif
    for my.[channel_flow_ok]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_exchange_declare ([exchange_declare])
    my.entity = my.[exchange_declare]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_exchange_declare ? 0
       echo "<parse_exchange_declare location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: exchange_declare only valid in a session"
    endif
    for my.[exchange_declare]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_exchange_delete ([exchange_delete])
    my.entity = my.[exchange_delete]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_exchange_delete ? 0
       echo "<parse_exchange_delete location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: exchange_delete only valid in a session"
    endif
    for my.[exchange_delete]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_queue_declare ([queue_declare])
    my.entity = my.[queue_declare]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_queue_declare ? 0
       echo "<parse_queue_declare location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: queue_declare only valid in a session"
    endif
    for my.[queue_declare]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_queue_bind ([queue_bind])
    my.entity = my.[queue_bind]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_queue_bind ? 0
       echo "<parse_queue_bind location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: queue_bind only valid in a session"
    endif
    #    Recurse into child entities
    if count (my.[queue_bind].[arguments]) > 1
        parse_error ("more than one <arguments> defined$(my.location)")
    endif
    #    Check that all entities are valid here
    for my.[queue_bind]. where defined (name ()) as entity
        if    name () = "arguments"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[queue_bind].[arguments] as [queue_bind_arguments]
        parse_queue_bind_arguments ([queue_bind_arguments])
    endfor

endfunction

function parse_queue_bind_arguments ([queue_bind_arguments])
    my.entity = my.[queue_bind_arguments]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_queue_bind_arguments ? 0
       echo "<parse_queue_bind_arguments location = \"$(my.location)\""
    endif

    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[queue_bind_arguments]. where defined (name ()) as entity
        if    name () = "field"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[queue_bind_arguments].[field] as [table field]
        parse_table_field ([table field])
    endfor

    my.last_key =
    for my.[queue_bind_arguments].[field] as [table field] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <field name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_table_field ([table field])
    my.entity = my.[table field]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_table_field ? 0
       echo "<parse_table_field location = \"$(my.location)\""
    endif

    if !defined (my.[table field].[name])
        parse_error ("Required attribute 'name' not defined$(my.location)")
    endif
    if !defined (my.[table field].[type])
        my.[table field].[type] = "string"
    endif
    if defined (my.[table field].[type])
        if    my.[table field].[type] ?= "string"
        elsif my.[table field].[type] ?= "integer"
        elsif my.[table field].[type] ?= "void"
        else
            parse_error ("Attribute 'type' has illegal value '$(0.[type]?)'$(my.location)")
        endif
    endif
    for my.[table field]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_queue_purge ([queue_purge])
    my.entity = my.[queue_purge]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_queue_purge ? 0
       echo "<parse_queue_purge location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: queue_purge only valid in a session"
    endif
    for my.[queue_purge]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_queue_delete ([queue_delete])
    my.entity = my.[queue_delete]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_queue_delete ? 0
       echo "<parse_queue_delete location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: queue_delete only valid in a session"
    endif
    for my.[queue_delete]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_basic_consume ([basic_consume])
    my.entity = my.[basic_consume]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_basic_consume ? 0
       echo "<parse_basic_consume location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: basic_consume only valid in a session"
    endif
    for my.[basic_consume]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_basic_cancel ([basic_cancel])
    my.entity = my.[basic_cancel]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_basic_cancel ? 0
       echo "<parse_basic_cancel location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: basic_cancel only valid in a session"
    endif
    for my.[basic_cancel]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_basic_publish ([basic_publish])
    my.entity = my.[basic_publish]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_basic_publish ? 0
       echo "<parse_basic_publish location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: basic_publish only valid in a session"
    endif
    for my.[basic_publish]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_basic_get ([basic_get])
    my.entity = my.[basic_get]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_basic_get ? 0
       echo "<parse_basic_get location = \"$(my.location)\""
    endif

    if !in_session
        abort "E: basic_get only valid in a session"
    endif
    for my.[basic_get]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction

function parse_basic_content ([basic_content])
    my.entity = my.[basic_content]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_basic_content ? 0
       echo "<parse_basic_content location = \"$(my.location)\""
    endif

    if defined (content.)
        size = string.length (content.)
    endif
    if !defined (my.[basic_content].[fill])
        my.[basic_content].[fill] = "random"
    endif
    if defined (my.[basic_content].[fill])
        if    my.[basic_content].[fill] ?= "random"
        elsif my.[basic_content].[fill] ?= "null"
        elsif my.[basic_content].[fill] ?= "repeat"
        else
            parse_error ("Attribute 'fill' has illegal value '$(0.[fill]?)'$(my.location)")
        endif
    endif
    if !defined (my.[basic_content].[headers])
        my.[basic_content].[headers] = "1"
    endif
    #    Recurse into child entities
    if count (my.[basic_content].[headers]) > 1
        parse_error ("more than one <headers> defined$(my.location)")
    endif
    #    Check that all entities are valid here
    for my.[basic_content]. where defined (name ()) as entity
        if    name () = "headers"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[basic_content].[headers] as [basic_content_headers]
        parse_basic_content_headers ([basic_content_headers])
    endfor

endfunction

function parse_basic_content_headers ([basic_content_headers])
    my.entity = my.[basic_content_headers]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_basic_content_headers ? 0
       echo "<parse_basic_content_headers location = \"$(my.location)\""
    endif

    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[basic_content_headers]. where defined (name ()) as entity
        if    name () = "field"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[basic_content_headers].[field] as [table field]
        parse_table_field ([table field])
    endfor

    my.last_key =
    for my.[basic_content_headers].[field] as [table field] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <field name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_basic_arrived ([basic_arrived])
    my.entity = my.[basic_arrived]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_basic_arrived ? 0
       echo "<parse_basic_arrived location = \"$(my.location)\""
    endif

    pal.nesting = (pal.nesting?0) + 1
    if defined ([0].counter)
        counter = "$(counter:c)"
        assume_variable (counter, "integer", 0)
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[basic_arrived]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[basic_arrived].[session] as [session]
        parse_session ([session])
    endfor

    for my.[basic_arrived].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[basic_arrived].[server] as [server]
        parse_server ([server])
    endfor

    for my.[basic_arrived].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[basic_arrived].[set] as [set]
        parse_set ([set])
    endfor

    for my.[basic_arrived].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[basic_arrived].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[basic_arrived].[read] as [read]
        parse_read ([read])
    endfor

    for my.[basic_arrived].[random] as [random]
        parse_random ([random])
    endfor

    for my.[basic_arrived].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[basic_arrived].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[basic_arrived].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[basic_arrived].[while] as [while]
        parse_while ([while])
    endfor

    for my.[basic_arrived].[break] as [break]
        parse_break ([break])
    endfor

    for my.[basic_arrived].[if] as [if]
        parse_if ([if])
    endfor

    for my.[basic_arrived].[else] as [else]
        parse_else ([else])
    endfor

    for my.[basic_arrived].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[basic_arrived].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[basic_arrived].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[basic_arrived].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[basic_arrived].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[basic_arrived].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[basic_arrived].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[basic_arrived].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[basic_arrived].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[basic_arrived].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[basic_arrived].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[basic_arrived].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[basic_arrived].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[basic_arrived].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[basic_arrived].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[basic_arrived].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[basic_arrived].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[basic_arrived].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[basic_arrived].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[basic_arrived].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[basic_arrived].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[basic_arrived].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_arrived].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_arrived].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_arrived].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_arrived].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_arrived].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_arrived].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    pal.nesting = pal.nesting - 1
endfunction

function parse_basic_returned ([basic_returned])
    my.entity = my.[basic_returned]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_basic_returned ? 0
       echo "<parse_basic_returned location = \"$(my.location)\""
    endif

    pal.nesting = (pal.nesting?0) + 1
    if defined ([0].counter)
        counter = "$(counter:c)"
        assume_variable (counter, "integer", 0)
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[basic_returned]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[basic_returned].[session] as [session]
        parse_session ([session])
    endfor

    for my.[basic_returned].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[basic_returned].[server] as [server]
        parse_server ([server])
    endfor

    for my.[basic_returned].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[basic_returned].[set] as [set]
        parse_set ([set])
    endfor

    for my.[basic_returned].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[basic_returned].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[basic_returned].[read] as [read]
        parse_read ([read])
    endfor

    for my.[basic_returned].[random] as [random]
        parse_random ([random])
    endfor

    for my.[basic_returned].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[basic_returned].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[basic_returned].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[basic_returned].[while] as [while]
        parse_while ([while])
    endfor

    for my.[basic_returned].[break] as [break]
        parse_break ([break])
    endfor

    for my.[basic_returned].[if] as [if]
        parse_if ([if])
    endfor

    for my.[basic_returned].[else] as [else]
        parse_else ([else])
    endfor

    for my.[basic_returned].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[basic_returned].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[basic_returned].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[basic_returned].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[basic_returned].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[basic_returned].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[basic_returned].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[basic_returned].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[basic_returned].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[basic_returned].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[basic_returned].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[basic_returned].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[basic_returned].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[basic_returned].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[basic_returned].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[basic_returned].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[basic_returned].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[basic_returned].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[basic_returned].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[basic_returned].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[basic_returned].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[basic_returned].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_returned].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_returned].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_returned].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_returned].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_returned].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[basic_returned].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    pal.nesting = pal.nesting - 1
endfunction

function parse_empty ([empty])
    my.entity = my.[empty]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_empty ? 0
       echo "<parse_empty location = \"$(my.location)\""
    endif

    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[empty]. where defined (name ()) as entity
        if    name () = "session"
        elsif name () = "invoke"
        elsif name () = "server"
        elsif name () = "timer"
        elsif name () = "set"
        elsif name () = "inc"
        elsif name () = "dec"
        elsif name () = "read"
        elsif name () = "random"
        elsif name () = "echo"
        elsif name () = "assert"
        elsif name () = "repeat"
        elsif name () = "while"
        elsif name () = "break"
        elsif name () = "if"
        elsif name () = "else"
        elsif name () = "elsif"
        elsif name () = "wait"
        elsif name () = "sleep"
        elsif name () = "abort"
        elsif name () = "exit"
        elsif name () = "channel_flow"
        elsif name () = "channel_flow_ok"
        elsif name () = "exchange_declare"
        elsif name () = "exchange_delete"
        elsif name () = "queue_declare"
        elsif name () = "queue_bind"
        elsif name () = "queue_purge"
        elsif name () = "queue_delete"
        elsif name () = "basic_consume"
        elsif name () = "basic_cancel"
        elsif name () = "basic_publish"
        elsif name () = "basic_get"
        elsif name () = "basic_content"
        elsif name () = "basic_arrived"
        elsif name () = "basic_returned"
        elsif name () = "empty"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[empty].[session] as [session]
        parse_session ([session])
    endfor

    for my.[empty].[invoke] as [invoke]
        parse_invoke ([invoke])
    endfor

    for my.[empty].[server] as [server]
        parse_server ([server])
    endfor

    for my.[empty].[timer] as [timer]
        parse_timer ([timer])
    endfor

    for my.[empty].[set] as [set]
        parse_set ([set])
    endfor

    for my.[empty].[inc] as [inc]
        parse_inc ([inc])
    endfor

    for my.[empty].[dec] as [dec]
        parse_dec ([dec])
    endfor

    for my.[empty].[read] as [read]
        parse_read ([read])
    endfor

    for my.[empty].[random] as [random]
        parse_random ([random])
    endfor

    for my.[empty].[echo] as [echo]
        parse_echo ([echo])
    endfor

    for my.[empty].[assert] as [assert]
        parse_assert ([assert])
    endfor

    for my.[empty].[repeat] as [repeat]
        parse_repeat ([repeat])
    endfor

    for my.[empty].[while] as [while]
        parse_while ([while])
    endfor

    for my.[empty].[break] as [break]
        parse_break ([break])
    endfor

    for my.[empty].[if] as [if]
        parse_if ([if])
    endfor

    for my.[empty].[else] as [else]
        parse_else ([else])
    endfor

    for my.[empty].[elsif] as [elsif]
        parse_elsif ([elsif])
    endfor

    for my.[empty].[wait] as [wait]
        parse_wait ([wait])
    endfor

    for my.[empty].[sleep] as [sleep]
        parse_sleep ([sleep])
    endfor

    for my.[empty].[abort] as [abort]
        parse_abort ([abort])
    endfor

    for my.[empty].[exit] as [exit]
        parse_exit ([exit])
    endfor

    for my.[empty].[channel_flow] as [channel_flow]
        parse_channel_flow ([channel_flow])
    endfor

    for my.[empty].[channel_flow_ok] as [channel_flow_ok]
        parse_channel_flow_ok ([channel_flow_ok])
    endfor

    for my.[empty].[exchange_declare] as [exchange_declare]
        parse_exchange_declare ([exchange_declare])
    endfor

    for my.[empty].[exchange_delete] as [exchange_delete]
        parse_exchange_delete ([exchange_delete])
    endfor

    for my.[empty].[queue_declare] as [queue_declare]
        parse_queue_declare ([queue_declare])
    endfor

    for my.[empty].[queue_bind] as [queue_bind]
        parse_queue_bind ([queue_bind])
    endfor

    for my.[empty].[queue_purge] as [queue_purge]
        parse_queue_purge ([queue_purge])
    endfor

    for my.[empty].[queue_delete] as [queue_delete]
        parse_queue_delete ([queue_delete])
    endfor

    for my.[empty].[basic_consume] as [basic_consume]
        parse_basic_consume ([basic_consume])
    endfor

    for my.[empty].[basic_cancel] as [basic_cancel]
        parse_basic_cancel ([basic_cancel])
    endfor

    for my.[empty].[basic_publish] as [basic_publish]
        parse_basic_publish ([basic_publish])
    endfor

    for my.[empty].[basic_get] as [basic_get]
        parse_basic_get ([basic_get])
    endfor

    for my.[empty].[basic_content] as [basic_content]
        parse_basic_content ([basic_content])
    endfor

    for my.[empty].[basic_arrived] as [basic_arrived]
        parse_basic_arrived ([basic_arrived])
    endfor

    for my.[empty].[basic_returned] as [basic_returned]
        parse_basic_returned ([basic_returned])
    endfor

    for my.[empty].[empty] as [empty]
        parse_empty ([empty])
    endfor

    my.last_key =
    for my.[empty].[server] as [server] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <server name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[empty].[set] as [set] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <set name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[empty].[inc] as [inc] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <inc name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[empty].[dec] as [dec] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <dec name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[empty].[read] as [read] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <read name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[empty].[random] as [random] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <random name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
    my.last_key =
    for my.[empty].[basic_content] as [basic_content] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <basic_content name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_inherit ([inherit])
    my.entity = my.[inherit]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_inherit ? 0
       echo "<parse_inherit location = \"$(my.location)\""
    endif

    if defined (my.[inherit].[phase])
        if    my.[inherit].[phase] ?= "preproc"
        elsif my.[inherit].[phase] ?= "parse"
        else
            parse_error ("Attribute 'phase' has illegal value '$(0.[phase]?)'$(my.location)")
        endif
    endif
    #    Recurse into child entities
    #    Check that all entities are valid here
    for my.[inherit]. where defined (name ()) as entity
        if    name () = "option"
        else
            parse_error ("<$(name ())> not allowed$(my.location)")
        endif
    endfor

    for my.[inherit].[option] as [option]
        parse_option ([option])
    endfor

    my.last_key =
    for my.[inherit].[option] as [option] by 0.[name] ? ""
        if (0.[name] ?<> "") & (0.[name] ?= my.last_key)
            parse_error ("Duplicate <option name = \"$(0.[name])\"/>$(my.location)")
        endif
        my.last_key = 0.[name] ? ""
    endfor
endfunction

function parse_option ([option])
    my.entity = my.[option]
    my.location = location ("pal")

    if switches.trace ? 0 | switches.trace_option ? 0
       echo "<parse_option location = \"$(my.location)\""
    endif

    for my.[option]. where defined (name ())
        parse_error ("<$(name ())> not allowed$(my.location)")
    endfor
endfunction


function parse_error (message)
    echo (my.message)
    global.errno = 1
endfunction
