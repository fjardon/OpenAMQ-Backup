/*===========================================================================*
 *                                                                           *
 *  smtschm.c - Libero schema for SMT agents                                 *
 *                                                                           *
 *  Copyright (c) 1991-2009 iMatix Corporation                               *
 *                                                                           *
 *  ------------------ GPL Licensed Source Code ------------------           *
 *  iMatix makes this software available under the GNU General               *
 *  Public License (GPL) license for open source projects.  For              *
 *  details of the GPL license please see www.gnu.org or read the            *
 *  file license.gpl provided in this package.                               *
 *                                                                           *
 *  This program is free software; you can redistribute it and/or            *
 *  modify it under the terms of the GNU General Public License as           *
 *  published by the Free Software Foundation; either version 2 of           *
 *  the License, or (at your option) any later version.                      *
 *                                                                           *
 *  This program is distributed in the hope that it will be useful,          *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of           *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 *  GNU General Public License for more details.                             *
 *                                                                           *
 *  You should have received a copy of the GNU General Public                *
 *  License along with this program in the file 'license.gpl'; if            *
 *  not, write to the Free Software Foundation, Inc., 59 Temple              *
 *  Place - Suite 330, Boston, MA 02111-1307, USA.                           *
 *                                                                           *
 *  You can also license this software under iMatix's General Terms          *
 *  of Business (GTB) for commercial projects.  If you have not              *
 *  explicitly licensed this software under the iMatix GTB you may           *
 *  only use it under the terms of the GNU General Public License.           *
 *                                                                           *
 *  For more information, send an email to info@imatix.com.                  *
 *  --------------------------------------------------------------           *
 *===========================================================================*/

:if module "dialog-call"
:  if not event "Return"
:     echo "lr E: you must define the 'Return' event"
:     exit 1
:  endif
:endif
:declare string rowbuf
:if not exist $source.c
:echo "lr I: creating skeleton program $source.c..."
:output $source.c
/*===========================================================================*
 *                                                                           *
 *  $source.c   description...                                               *
 *                                                                           *
 *  Written:    $date       $author                                          *
 *  Revised:    $date                                                        *
 *                                                                           *
 *  Skeleton generated by LIBERO $version on $fulldate, $time.               *
 *===========================================================================*/

#include "sfl.h"                        /*  SFL library header file          */
#include "smtlib.h"                     /*  SMT kernel functions             */


/*- Definitions -------------------------------------------------------------*/

#define AGENT_NAME   "$source"          /*  Our public name                  */

typedef struct                          /*  Thread context block:            */
{
    int handle;                         /*    Handle for i/o                 */
} TCB;


/*- Function prototypes -----------------------------------------------------*/


/*- Global variables used in this source file only --------------------------*/

static TCB
    *tcb;                               /*  Address thread context block     */


#include "$dialog.d"                    /*  Include dialog data              */

/********************   INITIALISE AGENT - ENTRY POINT   *********************/

int $source\_init (void)
{
    AGENT *agent;                       /*  Handle for our agent             */
#   include "$dialog.i"                 /*  Include dialog interpreter       */

    /*  Change any of the agent properties that you need to                  */
    agent-> router      = FALSE;        /*  FALSE = default                  */
    agent-> max_threads = 0;            /*  0 = default                      */

    /*  Shutdown event comes from Kernel                                     */
    declare_smtlib_shutdown   (shutdown_event,    SMT_PRIORITY_MAX);

    /*  Public methods supported by this agent                               */
    method_declare (agent, "XXX",           ok_event,        0);

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}


/*************************   INITIALISE THE THREAD   *************************/

MODULE $"initialise_the_thread" (THREAD *thread)
{
    tcb = thread-> tcb;                 /*  Point to thread's context        */
    tcb-> handle = 0;                   /*  For example...                   */
    $"the_next_event" = $"ok_event";
}


/*************************   TERMINATE THE THREAD   **************************/

MODULE $"terminate_the_thread" (THREAD *thread)
{
    tcb = thread-> tcb;                 /*  Point to thread's context        */
    $"the_next_event" = $"terminate_event";
}


:close
:endif

:output $dialog.d
:echo "lr I: building $dialog.d..."
/*---------------------------------------------------------------------------*
 *  $dialog.d - LIBERO dialog data definitions for $source.c.                *
 *  Generated by LIBERO $version on $fulldate, $time.                        *
 *  Schema file used: $schema.                                               *
 *---------------------------------------------------------------------------*/

/*- Symbolic constants and event numbers ------------------------------------*/

:if check
#define _LR_STOP                        0xFFFFL
#define _LR_NULL_EVENT                  -2
#define _LR_NULL_STATE                  -1
:endif
#define $"terminate_event"              -1
:do event
#define $name                           $number
:enddo
:do state
#define _LR_STATE_$name                 $number
:enddo
:if defaults
#define _LR_defaults_state              $defaults
:endif


/*- Function prototypes and macros ------------------------------------------*/

#ifndef MODULE
#define MODULE  static void             /*  Libero dialog modules            */
#endif

MODULE $"initialise_the_thread"     (THREAD *thread);
:do module
MODULE $name                        (THREAD *thread);
:enddo

#define $"the_next_event"           _the_next_event
#define $"the_exception_event"      _the_exception_event
#define $"the_external_event"       _the_external_event
#define $"exception_raised"         _exception_raised
#define $"io_completed"             _io_completed


/*- Static areas shared by all threads --------------------------------------*/

static word _LR_nextst [$states][$events] =
{
:do nextst
:  if $overflow = 0
    { $row }$comma
:  else
    { $row
:    do overflow
     $row
:    enddo
    }$comma
:  endif
:enddo
};

static word _LR_action [$states][$events] =
{
:set array_base=1
:do action
:  if $overflow = 0
    { $row }$comma
:  else
    { $row
:    do overflow
     $row
:    enddo
    }$comma
:  endif
:enddo
:set array_base=0
};

#if (defined (SMT_PROFILE))
static word _LR_count [$modules];
static long _LR_time  [$modules];
static word _LR_flow  [$states][$events];
#endif

static word _LR_offset [] =
{
    0,
:do vector
    $offset$comma
:enddo
};

static word _LR_vector [] =
{
:do vector
:  if "$row" = ""
    _LR_STOP$comma
:  else
:    if $overflow = 0
    $row,_LR_STOP$comma
:    else
:      set rowbuf="$row"
:      do overflow
    $rowbuf
:        set rowbuf="$row"
:      enddo
    $rowbuf,_LR_STOP$comma
:    endif
:  endif
:enddo
};

static HOOK *_LR_module [$modules] = {
:do module
    $name$comma
:enddo
};

:if not animate
#if (defined (DEBUG))
:endif
:push $style
:option -style=normal
static char *_LR_mname [$modules] =
{
:  do module
     "$name"$comma
:  enddo
};

static char *_LR_sname [$states] =
{
:  do state
     "$name"$comma
:  enddo
};

static char *_LR_ename [$events] =
{
:  do event
     "$name"$comma
:  enddo
};
:pop $style
:option -style=$style
:if not animate
#else
static char *_LR_mname [$modules] =
{
:  do module
     "$number"$comma
:  enddo
};

static char *_LR_sname [$states] =
{
:  do state
     "$number"$comma
:  enddo
};

static char *_LR_ename [$events] =
{
:  do event
     "$number"$comma
:  enddo
};
#endif
:endif
:if module "dialog-call"

MODULE $"dialog_call" (THREAD *thread)
{
    LR_LOCATION
        *location;

        
    if (LR_location_cache)
      {
        location = LR_location_cache;
        LR_location_cache = location-> next;
        location-> next = NULL;
      }
    else
        location = memt_alloc (NULL, sizeof (LR_LOCATION));
        
    location-> state  = thread-> LR_savest;
    location-> event  = return_event;
    location-> number = 0;
    location-> next   = thread-> LR_location_stack;
    thread-> LR_location_stack = location;
}

:endif
:if module "dialog-push"
MODULE $"dialog_push" (THREAD *thread)
{
    _dialog_push (thread);
}

:endif
:if module "dialog-return"
MODULE $"dialog_return" (THREAD *thread)
{
    _dialog_return (thread);
}

:endif
:if module "dialog-pop"
MODULE $"dialog_pop" (THREAD *thread)
{
    _dialog_pop (thread);
}

:endif
:close

:output $dialog.i
:echo "lr I: building $dialog.i..."
/*---------------------------------------------------------------------------*
 *  $dialog.i - LIBERO dialog interpreter for $source.c.                     *
 *  Generated by LIBERO $version on $fulldate, $time.                        *
 *  Schema file used: $schema.                                               *
 *---------------------------------------------------------------------------*/
    if (agent_lookup (AGENT_NAME))
        return (0);                     /*  Agent already declared           */
    if ((agent = agent_declare (AGENT_NAME)) == NULL)
        return (-1);                    /*  Could not declare agent          */

#if (defined (SINGLE_THREADED))
    agent-> tcb_size     = 0;           /*  No context block                 */
    agent-> max_threads  = 1;           /*    and max. 1 thread              */
#else
    agent-> tcb_size     = sizeof (TCB);
#endif
    agent-> initialise   = initialise_the_thread;
    agent-> maxevent     = $events;
    agent-> maxmodule    = $modules;
    agent-> maxstate     = $states;
    agent-> priority     = SMT_PRIORITY_NORMAL;
    agent-> LR_defaults  = $defaults;
    agent-> LR_nextst    = &_LR_nextst [0][0];
    agent-> LR_action    = &_LR_action [0][0];
    agent-> LR_offset    = _LR_offset;
    agent-> LR_vector    = _LR_vector;
    agent-> LR_module    = _LR_module;
    agent-> LR_mname     = _LR_mname;
    agent-> LR_sname     = _LR_sname;
    agent-> LR_ename     = _LR_ename;
:if animate
    agent-> animate      = TRUE;
:endif
#if (defined (SMT_PROFILE))
    agent-> LR_count     = &_LR_count [0];
    agent-> LR_time      = &_LR_time  [0];
    agent-> LR_flow      = &_LR_flow  [0][0];

    memset (_LR_count, 0, sizeof (_LR_count));
    memset (_LR_time,  0, sizeof (_LR_time));
#endif
:close

!   Generate stubs for all modules not yet defined in source file

:internal initialise_the_thread
:set module_line="MODULE %s (THREAD *thread)"
:do stubs $source.c $dialog.d

MODULE $name (THREAD *thread)
{
    tcb = thread-> tcb;                 /*  Point to thread's context        */
}

:enddo
