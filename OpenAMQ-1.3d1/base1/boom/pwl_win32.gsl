#
#   pwl_win32.gsl - PWL script for Win32 command extensions
#
#   Copyright (c) 1996-2009 iMatix Corporation
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
# 
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
# 
#   For information on alternative licensing for OEMs, please contact
#   iMatix Corporation.
#

##################################   MAIN   #################################

function win32_main
    >@echo off
    >:-
    >:-  Boom builder for $(pdl.name:) $(version)
    >:-  Generated by iMatix Boom from $(pdl.workflow)
    bsd_license (":-")
    >:-
    >:-  Start CMD.EXE version detection
    >verify other 2>nul
    >setlocal enableextensions
    >if errorlevel 0 goto __cmd_ok
    >echo %0: This command requires command extensions version 2 in CMD.EXE.  
    >echo %0: Please use a supported system (Windows 2000 or newer).
    >exit
    >:__cmd_ok
    >setlocal enabledelayedexpansion
    >:-  End CMD.EXE version detection
    >goto :init
    >:-
    >:-  Subroutine: boom_model_init
    >:-  Initialises BOOM_MODEL to default if not set
    >:-  Expands BOOM_MODEL components into individual environment variables
    >:-
    >:boom_model_init
    >if "!BOOM_MODEL!"=="" (
    >    set BOOM_MODEL=release,st
    >)
    >set BOOM_MODEL__PLACEHOLDER=1
    >for /f "usebackq delims==" %%v in (`set BOOM_MODEL_`) do set %%v=
    >set BOOM_MODEL__PLACEHOLDER=
    >for %%m in (!BOOM_MODEL!) do set BOOM_MODEL_%%m=1
    >:-  If the user set BOOM_MODEL but did not include release/debug or st/mt
    >:-  set these to defaults.
    >if not "!BOOM_MODEL_RELEASE!"=="1" (
    >    if not "!BOOM_MODEL_DEBUG!"=="1" (
    >        set BOOM_MODEL_RELEASE=1
    >        set BOOM_MODEL=!BOOM_MODEL!,release
    >    )
    >)
    >if not "!BOOM_MODEL_ST!"=="1" (
    >    if not "!BOOM_MODEL_MT!"=="1" (
    >        set BOOM_MODEL_ST=1
    >        set BOOM_MODEL=!BOOM_MODEL!,st
    >    )
    >)
    >goto :eof
    >:init
    >setlocal
    >:-
    >:-  Set environment variables to point to install location
    >:-  Start by using final IBASE, then handle -install path
    win32_prepare_project ()
    >set self=%0
    for pdl.set where (target?"win32") = "win32"
        >set $(name:)=$(value:)
    endfor
    >set MY_VERSION=$(version)
    >set OLDPATH=!PATH!
    >set OLDPERLLIB=!PERLLIB!
    >if .!IBASE!==. (
    >    echo boom E: [$(pdl.acronym)]: The IBASE variable is not set.  Please set it to the location where $(pdl.name) should be installed.
    >    exit /b 1
    >)
    >if .%1==.-v (
    >    set BOOM_TRACE=1
    >    shift
    >)
    >call :boom_model_init
    if pdl.install <> ""
        >:-  Let project access bin resources from IBASE
        >set PATH=!IBASE!\\bin;!PATH!
        >set PERLLIB=!IBASE!\\bin;!PERLLIB!
        >set IBASE=!IBASE!$(pdl.install)
    endif
    >if .%1==.-install goto tempinst
        >:-  Normal use, use IBASE
        >    set PATH=!IBASE!\\bin;!PATH!
        >    set PERLLIB=!IBASE!\\bin;!PERLLIB!
        >    set INCDIR_ALT=!IBASE!\\include
        >    set _INSTALL_ROOT=!IBASE!$(pdl.deploy)
        >    goto process
        >
    >:tempinst
        >:-  Building product, we use -install directory first, then IBASE
        >    if not exist %2 (
        >       echo "Invalid command syntax - please contact imatix-tech"
        >       exit /b 1
        >    )
        >    pushd %2
        >    set _LOCAL_BASE=!cd!$(pdl.install)
        >    popd
        >    set PATH=!_LOCAL_BASE!\\bin;!IBASE!\\bin;!PATH!
        >    set PERLLIB=!_LOCAL_BASE!\\bin;!IBASE!\\bin;!PERLLIB!
        >    set INCDIR_ALT=!_LOCAL_BASE!\\include;!IBASE!\\include
        >    set _INSTALL_ROOT=!_LOCAL_BASE!$(pdl.deploy)
        >    shift
        >    shift
        >    goto process
        >
    >:batch
    >    shift
    >
    >:process
    >    set state=$(pwl-> state.name)
    >    set event=ok
    >    set debug=0
    >    goto s_!state!
    >
    for pwl.action by name
        >:-$(format_title (action.name, 77, "-"):)
        >
        >:a_$(name:c)
        invoke_rule (name)
        >    goto :eof
        >
    endfor
    for pwl.state
        >:s_$(name:c)
        >    if "!debug!"=="1" echo State: $(name)
        >    if "!event!"=="" goto s_$(index (state))_empty
        for event
            >    if "!event!"=="$(name)" goto s_$(index (state))_$(index ())
        endfor
        if defined (inherit)
            >    goto s_$(inherit:c)
        else
            >    echo Unknown command - use one of:
            >    echo.
            >    goto r_!state!
        endif
        for event
            >:s_$(index (state))_$(index ())
            >    if "!debug!"=="1" echo Event: $(name)
            >    set event=
            for action
                >    if "!debug!"=="1" echo Action: $(name)
                >    set _exception=
                >    call :a_$(name:c)
                >    if "!_exception!"=="1" exit /b 1
            endfor
            if defined (nextstate)
                >    set state=$(nextstate:c)
                >    goto s_!state!
            else
                #    Process multiple actions on command line
                >    if not "%1"=="" goto process
                >    exit /b 0
            endif
        endfor
        >:s_$(index (state))_empty
        >    if "!debug!"=="1" echo Get event from user
        >    set event=%1
        >    shift
        >    if "!event!"=="" set event=empty
        >    goto s_$(name:c)
        >:r_$(name:c)
        for event where (internal?0) = 0
            >echo $(event.name):
            >$(format_block (event., "    echo   ", "", "."):)
        endfor
        if defined (inherit)
            >    goto r_$(inherit:c)
        else
            >    exit /b 0
        endif
        >
    endfor
    >
    >exit /b 0
endfunction

function win32_prepare_project
    #   Ensure PDL paths are correctly formatted
    pdl.rootdir = format_pathname (pdl.rootdir)
    pdl.deploy  = format_pathname (pdl.deploy)
    pdl.install = format_pathname (pdl.install)
    #   Force install path to start with slash if not empty
    if pdl.install <> "" & string.substr (pdl.install, 0,,1) <> "\\"
        pdl.install = "\\" + pdl.install
    endif
    if pdl.deploy <> "" & string.substr (pdl.deploy, 0,,1) <> "\\"
        pdl.deploy = "\\" + pdl.deploy
    endif
    walk_project ("", , "win32_resolve_filetypes", "resolve_directories")
endfunction

#   Resolve non-portable filetypes, define 'extension' in all file entries
#
function win32_resolve_filetypes (path)
    file.location = format_pathname (file.location)
    if    filetype = "object"
        if file.model?"" = "cpp"
            file.ext = ".opp"
        else
            file.ext = ".obj"
        endif
        file.binary  = 1
    elsif filetype = "command"
        file.ext    = ".exe"
        file.binary = 1
    elsif filetype = "library"
        file.ext    = ".lib"
        file.binary = 1
    else
        file.ext    = ""
        file.binary = 0
    endif
endfunction


########################   REPORT HELP INFORMATION   ########################

.macro win32_report_help_information
    echo The commands you can currently use on this project are:
    echo.
    goto r_!state!
.endmacro


########################   REPORT PROJECT VERSION   #########################

.macro win32_report_project_version ()
    echo $(pdl.acronym)-$(pdl.version)
.endmacro


########################   CHECK OPERATING CONTEXT   ########################

.macro win32_check_operating_context ()
    set event=repository
    if exist stamp_source   set event=source
    if exist stamp_stripped set event=stripped
.endmacro


#######################   CHECK PROJECT FILES EXIST   #######################

.macro win32_check_project_files_exist
.   walk_project ("", , "win32_check_project_files", "win32_check_push_dir", "win32_pop_dir")
.endmacro

.macro win32_check_project_files (path)
.   if file.generated = 0
.       win32_require_file (my.path, "")
.   endif
.endmacro

.macro win32_check_push_dir (path)
    if not exist $(directory.name)\\nul (
        echo boom E: [$(pdl.acronym)]: directory $(directory.name) is missing, cannot continue
        set _exception=1
        goto :eof
    )
.   win32_push_dir (my.path)
.endmacro

.macro win32_push_dir (path)
    pushd $(my.path)
.endmacro

.macro win32_pop_dir (path)
    popd
.endmacro

.macro win32_require_file (path, type, all_models)
.   if (target?"win32") = "win32" & shared = 0
.       if my.type = "" | count (distrib, count.[as] = my.type, count)
.           if defined (model) & !defined (my.all_models)
    if "!BOOM_MODEL_$(model:UPPER)!"=="1" (
.           endif
    if not exist $(name)$(ext) (
        echo boom E: [$(pdl.acronym)]: $(name)$(ext) is missing, cannot continue
.           if my.path <> ""
.               win32_pop_dir ()
.           endif
        set _exception=1
        goto :eof
    )
.           if defined (model) & !defined (my.all_models)
    )
.           endif
.       endif
.   endif
.endmacro


#######################   CHECK SOURCE FILES EXIST   ########################

.macro win32_check_source_files_exist
.   walk_project ("", , "win32_check_source_files", "win32_push_dir", "win32_pop_dir")
.endmacro

.macro win32_check_source_files (path)
.   win32_require_file (my.path, "source")
.endmacro


#####################   CHECK ALL SOURCE FILES EXIST   ######################

.macro win32_check_all_source_files_exist ()
.   walk_project ("", , "win32_check_all_source_files", "win32_push_dir", "win32_pop_dir")
.endmacro

.macro win32_check_all_source_files (path)
.   win32_require_file (my.path, "source", 1)
.endmacro


#######################   CHECK BINARY FILES EXIST   ########################

.macro win32_check_binary_files_exist
.   walk_project ("", , "win32_check_binary_files", "win32_push_dir", "win32_pop_dir")
.endmacro

.macro win32_check_binary_files (path)
.   win32_require_file (my.path, "binary")
.endmacro


########################   PRODUCE GENERATED FILES   ########################

.macro win32_produce_generated_files
    echo boom I: [$(pdl.acronym)]: Generating files...
.   walk_project ("", "win32_generate", "win32_generate", "win32_push_dir", "win32_pop_dir")
.   walk_project ("", "win32_gen_copy", "win32_gen_copy")
    echo Source files successfully generated>stamp_generate
.endmacro

.macro win32_generate (path)
.   for generate
.       win32_handle_process_step ()
.   endfor
.endmacro

.macro win32_handle_process_step (all_models)
.   for . as entity
.       if name () = "execute" & (target?"win32") = "win32"
.           if defined (.command)
.               if scope (file)
.                   win32_command ("$(command:) $(file.name?)$(ext?)", my.all_models)
.               else
.                   win32_command (command, my.all_models)
.               endif
.           elsif defined (.script)
.               include .script
.           else
.               filename = "$(file.name?)$(ext?)"
.               gsl (.?'')
.           endif
.       elsif name () = "run"
    if "!BOOM_TRACE!"=="1" (
        set RUN_COMMAND=$(basename)
    ) else (
        set RUN_COMMAND=$(basename) -q
    )
.           win32_command ("!RUN_COMMAND!", my.all_models)
.       elsif name () = "collect"
    if exist $(into) del $(into)
.           if scope (directory)
.               parent = "directory"
.           else
.               parent = "pdl"
.           endif
.           for file
.               if count ($(parent).file, count.name = file.name, count) = 0
.                   abort ("File '$(name)' specified in collection but not in project")
.               endif
.               win32_command ("type $(name)>>$(into)", my.all_models)
.           endfor
.       endif
.   endfor
.endmacro

#   I would use WinDOS's 'if (..)' command but that dies horribly if the
#   command contains '(' or ')', as it often does.  Even in quotes.  :-|
#   The pseudo-OS leaves the errorlevel dangling from previous commands,
#   so we force it to zero by doing something that resets it: verify>nul. :(
.macro win32_command (string, all_models)
.   if defined (model) & !defined (my.all_models)
    if "!BOOM_MODEL_$(model:UPPER)!"=="1" (
        if "!BOOM_TRACE!"=="1" echo $(my.string)
    )
    verify>nul
    if "!BOOM_MODEL_$(model:UPPER)!"=="1" call $(my.string:)
.   else
    if "!BOOM_TRACE!"=="1" echo $(my.string)
    verify>nul
    call $(my.string:)
.   endif
    if errorlevel 1 (
        echo boom E: [$(pdl.acronym)]: '$(my.string)' failed - stop.
        set _exception=1
        goto :eof
    )
.endmacro

.macro win32_gen_copy (path)
.   for generate
.       win32_handle_copy (my.path)
.   endfor
.endmacro

#   This has to be done outside a push/pop dir, because we use paths
#   relative to the project root directory.
#   copy from = directory                    in files
#   copy from = directory filename = name    in project/directory actions

function win32_handle_copy (path)
    if my.path = ""
        my.path = "."
    endif
    for copy
        my.pathname = format_pathname ([from])
        if scope (file)
            win32_command ('copy/y $(my.pathname)\\$(name)$(ext) $(my.path)>nul')
        else
            win32_command ('copy/y $(my.pathname)\\$(filename) $(my.path)>nul')
        endif
    endfor
endfunction


######################   PRODUCE ALL GENERATED FILES   ######################

.macro win32_produce_all_generated_files
    echo boom I: [$(pdl.acronym)]: Generating files...
.   walk_project ("", "win32_generate_all", "win32_generate_all", "win32_push_dir", "win32_pop_dir")
.   walk_project ("", "win32_gen_copy", "win32_gen_copy")
    echo Source files successfully generated>stamp_generate
.endmacro

.macro win32_generate_all (path)
.   for generate
.       win32_handle_process_step (1)
.   endfor
.endmacro


##########################   BUILD BINARY FILES   ###########################

.macro win32_build_binary_files
    echo boom I: [$(pdl.acronym)]: Building $(pdl.name)...
    if "!MSVCDir!"=="" set MSVCDir=C:\\Program Files\\Microsoft Visual Studio\\VC98
    if not exist "!MSVCDir!\\bin" (
        echo boom E: [$(pdl.acronym)]: Cannot find MSVC compiler in !MSVCdir!.
        echo boom E: [$(pdl.acronym)]: Please set MSVCDir environment variable to VC98 directory.
        set _exception=1
        goto :eof
    )
    set INCDIR=
    set LIBDIR=
    if "!BOOM_TRACE!"=="1" (
        set MY_COPTS=-v
    ) else (
        set MY_COPTS=-q
    )
    if not "!_LOCAL_BASE!"=="" (
        set MY_COPTS=!MY_COPTS! -li !_LOCAL_BASE!\\include -ll !_LOCAL_BASE!\\lib
    )
.   win32_build_directory ("")
.endmacro

function win32_build_directory (path)
    pathsep = target.pathsep?"/"
    if my.path = ""
        my.parent = "pdl"
    else
        my.parent = ""
    endif

    #   Handle any 'copy' commands
    for $(my.parent).file where (target?"win32") = "win32"
        for build
            win32_handle_copy (my.path)
        endfor
    endfor

    #   We now work in the local directory
    if my.path <> ""
        win32_push_dir (my.path)
    endif

    #   Do any 'before' build actions
    for $(my.parent).actions where when = "before"
        for build
            win32_handle_process_step ()
        endfor
    endfor

    #   Build and compile files locally
    for $(my.parent).file where (target?"win32") = "win32"
        for build
            win32_handle_process_step ()
        endfor
        for build where count (compile, (count.[as]?"c") = "c", count)
            win32_command ('c !MY_COPTS! $(basename)')
        endfor
        for build where count (compile, (count.[as]?"c") = "c++", count)
            win32_command ('c -p !MY_COPTS! $(basename)')
        endfor
    endfor

    #   Replace compiled programs into local library
    if $(my.parent).library ?<> ""
        for $(my.parent).file where (target?"win32") = "win32"
            for build where count (replace, (count.[as]?"c") = "c", count)
                win32_command ('c !MY_COPTS! -r $(library).lib $(basename)')
            endfor
            for build where count (replace, (count.[as]?"c") = "c++", count)
                win32_command ('c -p !MY_COPTS! -r $(library).lib $(basename)')
            endfor
        endfor
    endif

    #   Link main programs locally
    for $(my.parent).file where (target?"win32") = "win32"
        for build where count (link, (count.[as]?"c") = "c", count)
            win32_command ('c !MY_COPTS! -L $(basename)')
        endfor
        for build where count (link, (count.[as]?"c") = "c++", count)
            win32_command ('c -p !MY_COPTS! -L $(basename)')
        endfor
    endfor

    #   Do any 'after' build actions
    for $(my.parent).actions where when = "after"
        for build
            win32_handle_process_step ()
        endfor
    endfor

    #   We now switch back to the project root directory
    if my.path <> ""
        win32_pop_dir ()
    endif

    #   Replace compiled programs into project library
    #   This will be done only if we compiled in a child directory
    #   but the library is defined at the project (PDL) level.
    if ($(my.parent).library?"") = ""
        for $(my.parent).file where (target?"win32") = "win32"
            for build where count (replace, (count.[as]?"c") = "c", count)
                if library <> ""
                    win32_command ('c !MY_COPTS! -r $(library).lib $(my.path)$(basename)')
                endif
            endfor
            for build where count (replace, (count.[as]?"c") = "c++", count)
                if library <> ""
                    win32_command ('c -p !MY_COPTS! -r $(library).lib $(my.path)$(basename)')
                endif
            endfor
        endfor
    endif

    #   Recurse into all child directories
    for $(my.parent).directory where (target?"win32") = "win32"
        win32_build_directory (my.path + directory.name + pathsep)
    endfor
endfunction


######################   USE SOURCE CONTROL REVISION   ######################

.macro win32_use_source_control_revision
    set SVN_REVISION=svn
    if exist .svn\nul (
        for /f "usebackq tokens=1,2 delims=: " %%v in (`svn info`) do if "%%v"=="Revision" set SVN_REVISION=%%w
    )
    set MY_VERSION=!MY_VERSION!-!SVN_REVISION!
.endmacro


#########################   BUILD SOURCE PACKAGES   #########################

function win32_build_source_packages
    >   if exist _package.lst del _package.lst
    package_type = "source"
    walk_project ("", , "win32_package_file")
    win32_package_sources ()
endfunction

#   Packages a zip file from _packages.lst

.macro win32_package_sources
.   archive = "$(acronym:c)-!MY_VERSION!"
    echo "Source package successfully generated">stamp_source
    echo "stamp_source">>_package.lst
    echo boom I: [$(pdl.acronym)]: Building $(archive)-src.zip...
    zip  -rq _package -@<_package.lst
    unzip -q _package -d $(archive)
    if exist  $(archive)-src.zip del $(archive)-src.zip
    zip -rmq $(archive)-src.zip $(archive)
    del _package.zip
    del _package.lst
    del stamp_source
.endmacro

.macro win32_package_file (path)
.   if count (distrib, count.[as] = package_type, count)
.       fullname = rootdir + my.path + name + ext
    if exist $(fullname) echo $(fullname)>>_package.lst
.   endif
.endmacro


#########################   INSTALL DELIVERABLES   ##########################

.macro win32_install_deliverables
.   walk_project ("", , "check_install_file")
    echo boom I: [$(pdl.acronym)]: installing $(pdl.name:) into !_INSTALL_ROOT!...
    if not exist !_INSTALL_ROOT! mkdir !_INSTALL_ROOT!
.   walk_project_remap ("", "win32_install_action", "win32_install_file")
    if exist installer.bat (
.       win32_command ("installer")
    )
.endmacro

.macro win32_install_action (path)
.   for install
.       win32_handle_process_step ()
.   endfor
.endmacro

.macro win32_install_file (path)
.   if defined (file.install) & (target?"win32") = "win32"
.       if pdl.deploy = ""
.           cur_path = file.install + "\\"
.       else
.           cur_path = my.path
.       endif
.       last_path ?= ""
.       if cur_path <> last_path
    if not exist !_INSTALL_ROOT!\\$(cur_path)nul mkdir !_INSTALL_ROOT!\\$(cur_path)
.           last_path = cur_path
.       endif
.       if shared = 0 | file.exists (my.path + name + ext)
.           win32_command ('copy/y $(location)$(name)$(ext) !_INSTALL_ROOT!\\$(cur_path)$(rename?"")>nul')
.       endif
.   endif
.endmacro


#######################   REMOVE GENERATED SOURCES   ########################

.macro win32_remove_generated_sources
.   walk_project ("", , "win32_remove_generated_source")
.   walk_project ("", "win32_degen", "win32_degen", "win32_push_dir", "win32_pop_dir")
    if exist $(acronym:c)_*.zip del $(acronym:c)_*.zip
.endmacro

.macro win32_remove_generated_source (path)
.   if generated & (file.binary?0) ?= 0
    if exist $(my.path)$(name)$(ext) del $(my.path)$(name)$(ext)
.   endif
.endmacro

.macro win32_degen (path)
.   for degen
.       win32_handle_process_step ()
.   endfor
.endmacro


#######################   REMOVE GENERATED BINARIES   #######################

.macro win32_remove_generated_binaries
.   walk_project ("", , "win32_remove_generated_binary")
.   walk_project ("", "win32_clean", "win32_clean", "win32_push_dir", "win32_pop_dir")
    if exist vc60.pdb del vc60.pdb
.endmacro

.macro win32_remove_generated_binary (path)
.   if generated & (file.binary?0) ?= 1
    if exist $(my.path)$(basename)$(ext) del $(my.path)$(basename)$(ext)
.   endif
.endmacro

.macro win32_clean (path)
.   for clean
.       win32_handle_process_step ()
.   endfor
.endmacro


#########################   RUN REGRESSION TESTS   ##########################

.macro win32_run_regression_tests
.   have_tests = 0
.   walk_project ("", "win32_tests", "win32_tests", "win32_push_dir", "win32_pop_dir")
    :-  Run local selftest script if present
    if exist selftest.bat (
.       win32_command ("selftest")
    )
.endmacro

function win32_tests (path)
    for test
        if !have_tests
            >    echo boom I: [$(pdl.acronym)]: Running regression tests...
            have_tests = 1
        endif
        win32_handle_process_step ()
    endfor
endfunction


############################   BUILD PROJECTS   #############################

.macro win32_build_projects ()
    if exist _install\\nul rmdir /s /q _install
    mkdir _install
.   if pdl.install <> ""
    mkdir _install$(pdl.install)
.   endif
    mkdir _install$(pdl.install)\\lib
    mkdir _install$(pdl.install)\\include
    mkdir _install$(pdl.install)\\bin
.   win32_do_projects ("-install ..\\_install build install")
.endmacro

.macro win32_do_projects (action)
.   for pdl.project
.   win32_push_dir (directory)
    if exist boomake.bat (
        call boomake $(my.action)
    ) else (
        echo boom E: [$(pdl.acronym)]: project is not configured - run 'boom configure'
    )
.   win32_pop_dir (directory)
.   endfor
.endmacro


###########################   COMPILE PROJECTS   ############################

function win32_compile_projects ()
    win32_do_projects ("compile")
endfunction


############################   REGEN PROJECTS   #############################

function win32_regen_projects ()
    win32_do_projects ("regen")
endfunction


############################   ALLGEN PROJECTS   ############################

function win32_allgen_projects ()
    win32_do_projects ("allgen")
endfunction


#############################   TEST PROJECTS   #############################

.macro win32_test_projects ()
.   win32_do_projects ("test")
    if exist selftest.bat (
.       win32_command ("selftest")
    )
.endmacro


###########################   INSTALL PROJECTS   ############################

.macro win32_install_projects ()
.   win32_do_projects ("install")
    if exist installer.bat (
.       win32_command ("installer")
    )
.endmacro


############################   CLEAN PROJECTS   #############################

.macro win32_clean_projects ()
    if exist _install\\nul rmdir /s /q _install
.   win32_do_projects ("clean")
.endmacro


#####################   BUILD PRODUCT SOURCE PACKAGES   #####################

function win32_build_product_source_packages ()
    for pdl.distrib where type = "source"
        >    if exist _package.lst del _package.lst
        walk_project ("", , "win32_package_file")
        for pdl.actions
            for distsrc
                win32_handle_process_step ()
            endfor
        endfor
        package_type = "source"
        for project as distrib_project
            for pdl.project where directory = distrib_project.directory
                for pdl
                    for set where (target?"win32") = "win32"
                        >    set $(name:)=$(value:)
                    endfor
                    win32_push_dir (directory)
                    for actions
                        for distsrc
                            win32_handle_process_step ()
                        endfor
                    endfor
                    win32_pop_dir ()
                    win32_prepare_project ()
                    walk_project ("", , "win32_package_file")
                endfor
            endfor
        endfor
        for project
            >    echo "Source package successfully generated">$(directory)\\stamp_source
            >    echo "$(directory)\\stamp_source">>_package.lst
        endfor
        win32_package_sources ()
        for project
            >    del $(directory)\\stamp_source
        endfor
    endfor
endfunction


####################   BUILD PRODUCT INSTALL PACKAGES   #####################

function win32_build_product_install_packages ()
    for pdl.distrib where type = "install"
        >    echo boom I: [$(pdl.acronym)]: building $(name)...
        >    if exist _install\\nul rmdir /s /q _install
        >    mkdir _install
        if pdl.install <> ""
            >    mkdir _install$(pdl.install)
        endif
        >    mkdir _install$(pdl.install)\\lib
        >    mkdir _install$(pdl.install)\\include
        >    mkdir _install$(pdl.install)\\bin
        for project as distrib_project
            win32_push_dir (directory)
            >    if exist boomake.bat (
            >    call boomake -install ..\\_install install
            >    ) else (
            >        echo boom E: [$(pdl.acronym)]: project is not configured - run 'boom configure'
            >    )
            win32_pop_dir (directory)
        endfor
        for prune
            filename = format_pathname (filename)
            >    if exist _install$(pdl.install)\\$(filename)\\nul (
            >        rmdir /s /q _install$(pdl.install)\\$(filename)
            >    ) else (
            >        del _install$(pdl.install)\\$(filename) 2>nul
            >    )
        endfor

        archive = "$(acronym:c)-!MY_VERSION!"

        #  Rename install tree to create a package root
        >    if exist $(archive) rmdir /s/q $(archive)
        >    ren _install $(archive)

        #  Default packager for Windows is pkg_zip.bat
        if count (packager) = 0
            win32_command ('pkg_zip $(archive)')
        else
            for packager where target ?= "win32"
                win32_command ('$(name) $(archive)')
            endfor
        endif

        >    rmdir /s/q $(archive)
    endfor
endfunction


